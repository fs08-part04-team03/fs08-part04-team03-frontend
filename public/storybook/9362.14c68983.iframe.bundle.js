/*! For license information please see 9362.14c68983.iframe.bundle.js.LICENSE.txt */
(self.webpackChunkproject_name = self.webpackChunkproject_name || []).push([
  [9362],
  {
    './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        CF: () => autoBatchEnhancer,
        U1: () => configureStore,
        VP: () => createAction,
        Nc: () => createListenerMiddleware,
        Z0: () => createSlice,
        aA: () => prepareAutoBatched,
      });
      var immer = __webpack_require__(
          './node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs'
        ),
        redux = __webpack_require__('./node_modules/redux/dist/redux.mjs');
      function createThunkMiddleware(extraArgument) {
        return ({ dispatch, getState }) =>
          (next) =>
          (action) =>
            'function' == typeof action ? action(dispatch, getState, extraArgument) : next(action);
      }
      var redux_thunk_thunk = createThunkMiddleware(),
        withExtraArgument = createThunkMiddleware,
        console = __webpack_require__('./node_modules/console-browserify/index.js'),
        composeWithDevTools =
          (__webpack_require__('./node_modules/process/browser.js'),
          'undefined' != typeof window && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
            ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
            : function () {
                if (0 !== arguments.length)
                  return 'object' == typeof arguments[0]
                    ? redux.Zz
                    : redux.Zz.apply(null, arguments);
              });
      'undefined' != typeof window &&
        window.__REDUX_DEVTOOLS_EXTENSION__ &&
        window.__REDUX_DEVTOOLS_EXTENSION__;
      function createAction(type, prepareAction) {
        function actionCreator(...args) {
          if (prepareAction) {
            let prepared = prepareAction(...args);
            if (!prepared) throw new Error(formatProdErrorMessage(0));
            return {
              type,
              payload: prepared.payload,
              ...('meta' in prepared && { meta: prepared.meta }),
              ...('error' in prepared && { error: prepared.error }),
            };
          }
          return { type, payload: args[0] };
        }
        return (
          (actionCreator.toString = () => `${type}`),
          (actionCreator.type = type),
          (actionCreator.match = (action) => (0, redux.ve)(action) && action.type === type),
          actionCreator
        );
      }
      var Tuple = class _Tuple extends Array {
        constructor(...items) {
          (super(...items), Object.setPrototypeOf(this, _Tuple.prototype));
        }
        static get [Symbol.species]() {
          return _Tuple;
        }
        concat(...arr) {
          return super.concat.apply(this, arr);
        }
        prepend(...arr) {
          return 1 === arr.length && Array.isArray(arr[0])
            ? new _Tuple(...arr[0].concat(this))
            : new _Tuple(...arr.concat(this));
        }
      };
      function freezeDraftable(val) {
        return (0, immer.a6)(val) ? (0, immer.jM)(val, () => {}) : val;
      }
      function getOrInsertComputed(map, key, compute) {
        return map.has(key) ? map.get(key) : map.set(key, compute(key)).get(key);
      }
      var SHOULD_AUTOBATCH = 'RTK_autoBatch',
        prepareAutoBatched = () => (payload) => ({ payload, meta: { [SHOULD_AUTOBATCH]: !0 } }),
        createQueueWithTimer = (timeout) => (notify) => {
          setTimeout(notify, timeout);
        },
        autoBatchEnhancer =
          (options = { type: 'raf' }) =>
          (next) =>
          (...args) => {
            const store = next(...args);
            let notifying = !0,
              shouldNotifyAtEndOfTick = !1,
              notificationQueued = !1;
            const listeners = new Set(),
              queueCallback =
                'tick' === options.type
                  ? queueMicrotask
                  : 'raf' === options.type
                    ? 'undefined' != typeof window && window.requestAnimationFrame
                      ? window.requestAnimationFrame
                      : createQueueWithTimer(10)
                    : 'callback' === options.type
                      ? options.queueNotification
                      : createQueueWithTimer(options.timeout),
              notifyListeners = () => {
                ((notificationQueued = !1),
                  shouldNotifyAtEndOfTick &&
                    ((shouldNotifyAtEndOfTick = !1), listeners.forEach((l) => l())));
              };
            return Object.assign({}, store, {
              subscribe(listener2) {
                const unsubscribe = store.subscribe(() => notifying && listener2());
                return (
                  listeners.add(listener2),
                  () => {
                    (unsubscribe(), listeners.delete(listener2));
                  }
                );
              },
              dispatch(action) {
                try {
                  return (
                    (notifying = !action?.meta?.RTK_autoBatch),
                    (shouldNotifyAtEndOfTick = !notifying),
                    shouldNotifyAtEndOfTick &&
                      (notificationQueued ||
                        ((notificationQueued = !0), queueCallback(notifyListeners))),
                    store.dispatch(action)
                  );
                } finally {
                  notifying = !0;
                }
              },
            });
          };
      function configureStore(options) {
        const getDefaultMiddleware = function getDefaultMiddleware(options) {
            const {
              thunk = !0,
              immutableCheck = !0,
              serializableCheck = !0,
              actionCreatorCheck = !0,
            } = options ?? {};
            let middlewareArray = new Tuple();
            return (
              thunk &&
                ((function isBoolean(x) {
                  return 'boolean' == typeof x;
                })(thunk)
                  ? middlewareArray.push(redux_thunk_thunk)
                  : middlewareArray.push(withExtraArgument(thunk.extraArgument))),
              middlewareArray
            );
          },
          {
            reducer,
            middleware,
            devTools = !0,
            duplicateMiddlewareCheck = !0,
            preloadedState,
            enhancers,
          } = options || {};
        let rootReducer, finalMiddleware;
        if ('function' == typeof reducer) rootReducer = reducer;
        else {
          if (!(0, redux.Qd)(reducer)) throw new Error(formatProdErrorMessage(1));
          rootReducer = (0, redux.HY)(reducer);
        }
        finalMiddleware =
          'function' == typeof middleware
            ? middleware(getDefaultMiddleware)
            : getDefaultMiddleware();
        let finalCompose = redux.Zz;
        devTools &&
          (finalCompose = composeWithDevTools({
            trace: !1,
            ...('object' == typeof devTools && devTools),
          }));
        const getDefaultEnhancers = ((middlewareEnhancer) =>
          function getDefaultEnhancers(options) {
            const { autoBatch = !0 } = options ?? {};
            let enhancerArray = new Tuple(middlewareEnhancer);
            return (
              autoBatch &&
                enhancerArray.push(
                  autoBatchEnhancer('object' == typeof autoBatch ? autoBatch : void 0)
                ),
              enhancerArray
            );
          })((0, redux.Tw)(...finalMiddleware));
        const composedEnhancer = finalCompose(
          ...('function' == typeof enhancers
            ? enhancers(getDefaultEnhancers)
            : getDefaultEnhancers())
        );
        return (0, redux.y$)(rootReducer, preloadedState, composedEnhancer);
      }
      function executeReducerBuilderCallback(builderCallback) {
        const actionsMap = {},
          actionMatchers = [];
        let defaultCaseReducer;
        const builder = {
          addCase(typeOrActionCreator, reducer) {
            const type =
              'string' == typeof typeOrActionCreator
                ? typeOrActionCreator
                : typeOrActionCreator.type;
            if (!type) throw new Error(formatProdErrorMessage(28));
            if (type in actionsMap) throw new Error(formatProdErrorMessage(29));
            return ((actionsMap[type] = reducer), builder);
          },
          addAsyncThunk: (asyncThunk, reducers) => (
            reducers.pending && (actionsMap[asyncThunk.pending.type] = reducers.pending),
            reducers.rejected && (actionsMap[asyncThunk.rejected.type] = reducers.rejected),
            reducers.fulfilled && (actionsMap[asyncThunk.fulfilled.type] = reducers.fulfilled),
            reducers.settled &&
              actionMatchers.push({ matcher: asyncThunk.settled, reducer: reducers.settled }),
            builder
          ),
          addMatcher: (matcher, reducer) => (actionMatchers.push({ matcher, reducer }), builder),
          addDefaultCase: (reducer) => ((defaultCaseReducer = reducer), builder),
        };
        return (builderCallback(builder), [actionsMap, actionMatchers, defaultCaseReducer]);
      }
      var nanoid = (size = 21) => {
        let id = '',
          i = size;
        for (; i--; )
          id += 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW'[
            (64 * Math.random()) | 0
          ];
        return id;
      };
      var asyncThunkSymbol = Symbol.for('rtk-slice-createasyncthunk');
      function getType(slice, actionKey) {
        return `${slice}/${actionKey}`;
      }
      function buildCreateSlice({ creators } = {}) {
        const cAT = creators?.asyncThunk?.[asyncThunkSymbol];
        return function createSlice2(options) {
          const { name, reducerPath = name } = options;
          if (!name) throw new Error(formatProdErrorMessage(11));
          const reducers =
              ('function' == typeof options.reducers
                ? options.reducers(
                    (function buildReducerCreators() {
                      function asyncThunk(payloadCreator, config) {
                        return { _reducerDefinitionType: 'asyncThunk', payloadCreator, ...config };
                      }
                      return (
                        (asyncThunk.withTypes = () => asyncThunk),
                        {
                          reducer: (caseReducer) =>
                            Object.assign(
                              { [caseReducer.name]: (...args) => caseReducer(...args) }[
                                caseReducer.name
                              ],
                              { _reducerDefinitionType: 'reducer' }
                            ),
                          preparedReducer: (prepare, reducer) => ({
                            _reducerDefinitionType: 'reducerWithPrepare',
                            prepare,
                            reducer,
                          }),
                          asyncThunk,
                        }
                      );
                    })()
                  )
                : options.reducers) || {},
            reducerNames = Object.keys(reducers),
            context = {
              sliceCaseReducersByName: {},
              sliceCaseReducersByType: {},
              actionCreators: {},
              sliceMatchers: [],
            },
            contextMethods = {
              addCase(typeOrActionCreator, reducer2) {
                const type =
                  'string' == typeof typeOrActionCreator
                    ? typeOrActionCreator
                    : typeOrActionCreator.type;
                if (!type) throw new Error(formatProdErrorMessage(12));
                if (type in context.sliceCaseReducersByType)
                  throw new Error(formatProdErrorMessage(13));
                return ((context.sliceCaseReducersByType[type] = reducer2), contextMethods);
              },
              addMatcher: (matcher, reducer2) => (
                context.sliceMatchers.push({ matcher, reducer: reducer2 }),
                contextMethods
              ),
              exposeAction: (name2, actionCreator) => (
                (context.actionCreators[name2] = actionCreator),
                contextMethods
              ),
              exposeCaseReducer: (name2, reducer2) => (
                (context.sliceCaseReducersByName[name2] = reducer2),
                contextMethods
              ),
            };
          function buildReducer() {
            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer] =
                'function' == typeof options.extraReducers
                  ? executeReducerBuilderCallback(options.extraReducers)
                  : [options.extraReducers],
              finalCaseReducers = { ...extraReducers, ...context.sliceCaseReducersByType };
            return (function createReducer(initialState, mapOrBuilderCallback) {
              let getInitialState,
                [actionsMap, finalActionMatchers, finalDefaultCaseReducer] =
                  executeReducerBuilderCallback(mapOrBuilderCallback);
              if (
                (function isStateFunction(x) {
                  return 'function' == typeof x;
                })(initialState)
              )
                getInitialState = () => freezeDraftable(initialState());
              else {
                const frozenInitialState = freezeDraftable(initialState);
                getInitialState = () => frozenInitialState;
              }
              function reducer(state = getInitialState(), action) {
                let caseReducers = [
                  actionsMap[action.type],
                  ...finalActionMatchers
                    .filter(({ matcher }) => matcher(action))
                    .map(({ reducer: reducer2 }) => reducer2),
                ];
                return (
                  0 === caseReducers.filter((cr) => !!cr).length &&
                    (caseReducers = [finalDefaultCaseReducer]),
                  caseReducers.reduce((previousState, caseReducer) => {
                    if (caseReducer) {
                      if ((0, immer.Qx)(previousState)) {
                        const result = caseReducer(previousState, action);
                        return void 0 === result ? previousState : result;
                      }
                      if ((0, immer.a6)(previousState))
                        return (0, immer.jM)(previousState, (draft) => caseReducer(draft, action));
                      {
                        const result = caseReducer(previousState, action);
                        if (void 0 === result) {
                          if (null === previousState) return previousState;
                          throw Error(
                            'A case reducer on a non-draftable value must not return undefined'
                          );
                        }
                        return result;
                      }
                    }
                    return previousState;
                  }, state)
                );
              }
              return ((reducer.getInitialState = getInitialState), reducer);
            })(options.initialState, (builder) => {
              for (let key in finalCaseReducers) builder.addCase(key, finalCaseReducers[key]);
              for (let sM of context.sliceMatchers) builder.addMatcher(sM.matcher, sM.reducer);
              for (let m of actionMatchers) builder.addMatcher(m.matcher, m.reducer);
              defaultCaseReducer && builder.addDefaultCase(defaultCaseReducer);
            });
          }
          reducerNames.forEach((reducerName) => {
            const reducerDefinition = reducers[reducerName],
              reducerDetails = {
                reducerName,
                type: getType(name, reducerName),
                createNotation: 'function' == typeof options.reducers,
              };
            !(function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
              return 'asyncThunk' === reducerDefinition._reducerDefinitionType;
            })(reducerDefinition)
              ? (function handleNormalReducerDefinition(
                  { type, reducerName, createNotation },
                  maybeReducerWithPrepare,
                  context
                ) {
                  let caseReducer, prepareCallback;
                  if ('reducer' in maybeReducerWithPrepare) {
                    if (
                      createNotation &&
                      !(function isCaseReducerWithPrepareDefinition(reducerDefinition) {
                        return 'reducerWithPrepare' === reducerDefinition._reducerDefinitionType;
                      })(maybeReducerWithPrepare)
                    )
                      throw new Error(formatProdErrorMessage(17));
                    ((caseReducer = maybeReducerWithPrepare.reducer),
                      (prepareCallback = maybeReducerWithPrepare.prepare));
                  } else caseReducer = maybeReducerWithPrepare;
                  context
                    .addCase(type, caseReducer)
                    .exposeCaseReducer(reducerName, caseReducer)
                    .exposeAction(
                      reducerName,
                      prepareCallback ? createAction(type, prepareCallback) : createAction(type)
                    );
                })(reducerDetails, reducerDefinition, contextMethods)
              : (function handleThunkCaseReducerDefinition(
                  { type, reducerName },
                  reducerDefinition,
                  context,
                  cAT
                ) {
                  if (!cAT) throw new Error(formatProdErrorMessage(18));
                  const { payloadCreator, fulfilled, pending, rejected, settled, options } =
                      reducerDefinition,
                    thunk = cAT(type, payloadCreator, options);
                  (context.exposeAction(reducerName, thunk),
                    fulfilled && context.addCase(thunk.fulfilled, fulfilled));
                  pending && context.addCase(thunk.pending, pending);
                  rejected && context.addCase(thunk.rejected, rejected);
                  settled && context.addMatcher(thunk.settled, settled);
                  context.exposeCaseReducer(reducerName, {
                    fulfilled: fulfilled || noop,
                    pending: pending || noop,
                    rejected: rejected || noop,
                    settled: settled || noop,
                  });
                })(reducerDetails, reducerDefinition, contextMethods, cAT);
          });
          const selectSelf = (state) => state,
            injectedSelectorCache = new Map(),
            injectedStateCache = new WeakMap();
          let _reducer;
          function reducer(state, action) {
            return (_reducer || (_reducer = buildReducer()), _reducer(state, action));
          }
          function getInitialState() {
            return (_reducer || (_reducer = buildReducer()), _reducer.getInitialState());
          }
          function makeSelectorProps(reducerPath2, injected = !1) {
            function selectSlice(state) {
              let sliceState = state[reducerPath2];
              return (
                void 0 === sliceState &&
                  injected &&
                  (sliceState = getOrInsertComputed(
                    injectedStateCache,
                    selectSlice,
                    getInitialState
                  )),
                sliceState
              );
            }
            function getSelectors(selectState = selectSelf) {
              const selectorCache = getOrInsertComputed(
                injectedSelectorCache,
                injected,
                () => new WeakMap()
              );
              return getOrInsertComputed(selectorCache, selectState, () => {
                const map = {};
                for (const [name2, selector] of Object.entries(options.selectors ?? {}))
                  map[name2] = wrapSelector(
                    selector,
                    selectState,
                    () => getOrInsertComputed(injectedStateCache, selectState, getInitialState),
                    injected
                  );
                return map;
              });
            }
            return {
              reducerPath: reducerPath2,
              getSelectors,
              get selectors() {
                return getSelectors(selectSlice);
              },
              selectSlice,
            };
          }
          const slice = {
            name,
            reducer,
            actions: context.actionCreators,
            caseReducers: context.sliceCaseReducersByName,
            getInitialState,
            ...makeSelectorProps(reducerPath),
            injectInto(injectable, { reducerPath: pathOpt, ...config } = {}) {
              const newReducerPath = pathOpt ?? reducerPath;
              return (
                injectable.inject({ reducerPath: newReducerPath, reducer }, config),
                { ...slice, ...makeSelectorProps(newReducerPath, !0) }
              );
            },
          };
          return slice;
        };
      }
      function wrapSelector(selector, selectState, getInitialState, injected) {
        function wrapper(rootState, ...args) {
          let sliceState = selectState(rootState);
          return (
            void 0 === sliceState && injected && (sliceState = getInitialState()),
            selector(sliceState, ...args)
          );
        }
        return ((wrapper.unwrapped = selector), wrapper);
      }
      var createSlice = buildCreateSlice();
      function noop() {}
      var TaskAbortError = class {
          constructor(code) {
            ((this.code = code), (this.message = `task cancelled (reason: ${code})`));
          }
          name = 'TaskAbortError';
          message;
        },
        assertFunction = (func, expected) => {
          if ('function' != typeof func) throw new TypeError(formatProdErrorMessage(32));
        },
        noop2 = () => {},
        catchRejection = (promise, onError = noop2) => (promise.catch(onError), promise),
        addAbortSignalListener = (abortSignal, callback) => (
          abortSignal.addEventListener('abort', callback, { once: !0 }),
          () => abortSignal.removeEventListener('abort', callback)
        ),
        validateActive = (signal) => {
          if (signal.aborted) throw new TaskAbortError(signal.reason);
        };
      function raceWithSignal(signal, promise) {
        let cleanup = noop2;
        return new Promise((resolve, reject) => {
          const notifyRejection = () => reject(new TaskAbortError(signal.reason));
          signal.aborted
            ? notifyRejection()
            : ((cleanup = addAbortSignalListener(signal, notifyRejection)),
              promise.finally(() => cleanup()).then(resolve, reject));
        }).finally(() => {
          cleanup = noop2;
        });
      }
      var createPause = (signal) => (promise) =>
          catchRejection(
            raceWithSignal(signal, promise).then((output) => (validateActive(signal), output))
          ),
        createDelay = (signal) => {
          const pause = createPause(signal);
          return (timeoutMs) => pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));
        },
        { assign: redux_toolkit_modern_assign } = Object,
        INTERNAL_NIL_TOKEN = {},
        alm = 'listenerMiddleware',
        createFork = (parentAbortSignal, parentBlockingPromises) => (taskExecutor, opts) => {
          assertFunction(taskExecutor);
          const childAbortController = new AbortController();
          var controller;
          ((controller = childAbortController),
            addAbortSignalListener(parentAbortSignal, () =>
              controller.abort(parentAbortSignal.reason)
            ));
          const result = (async (task2, cleanUp) => {
            try {
              return (await Promise.resolve(), { status: 'ok', value: await task2() });
            } catch (error) {
              return { status: error instanceof TaskAbortError ? 'cancelled' : 'rejected', error };
            } finally {
              cleanUp?.();
            }
          })(
            async () => {
              (validateActive(parentAbortSignal), validateActive(childAbortController.signal));
              const result2 = await taskExecutor({
                pause: createPause(childAbortController.signal),
                delay: createDelay(childAbortController.signal),
                signal: childAbortController.signal,
              });
              return (validateActive(childAbortController.signal), result2);
            },
            () => childAbortController.abort('task-completed')
          );
          return (
            opts?.autoJoin && parentBlockingPromises.push(result.catch(noop2)),
            {
              result: createPause(parentAbortSignal)(result),
              cancel() {
                childAbortController.abort('task-cancelled');
              },
            }
          );
        },
        createTakePattern = (startListening, signal) => (predicate, timeout) =>
          catchRejection(
            (async (predicate, timeout) => {
              validateActive(signal);
              let unsubscribe = () => {};
              const promises = [
                new Promise((resolve, reject) => {
                  let stopListening = startListening({
                    predicate,
                    effect: (action, listenerApi) => {
                      (listenerApi.unsubscribe(),
                        resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]));
                    },
                  });
                  unsubscribe = () => {
                    (stopListening(), reject());
                  };
                }),
              ];
              null != timeout &&
                promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));
              try {
                const output = await raceWithSignal(signal, Promise.race(promises));
                return (validateActive(signal), output);
              } finally {
                unsubscribe();
              }
            })(predicate, timeout)
          ),
        getListenerEntryPropsFrom = (options) => {
          let { type, actionCreator, matcher, predicate, effect } = options;
          if (type) predicate = createAction(type).match;
          else if (actionCreator) ((type = actionCreator.type), (predicate = actionCreator.match));
          else if (matcher) predicate = matcher;
          else if (!predicate) throw new Error(formatProdErrorMessage(21));
          return (assertFunction(effect), { predicate, type, effect });
        },
        createListenerEntry = redux_toolkit_modern_assign(
          (options) => {
            const { type, predicate, effect } = getListenerEntryPropsFrom(options);
            return {
              id: nanoid(),
              effect,
              type,
              predicate,
              pending: new Set(),
              unsubscribe: () => {
                throw new Error(formatProdErrorMessage(22));
              },
            };
          },
          { withTypes: () => createListenerEntry }
        ),
        findListenerEntry = (listenerMap, options) => {
          const { type, effect, predicate } = getListenerEntryPropsFrom(options);
          return Array.from(listenerMap.values()).find(
            (entry) =>
              ('string' == typeof type ? entry.type === type : entry.predicate === predicate) &&
              entry.effect === effect
          );
        },
        cancelActiveListeners = (entry) => {
          entry.pending.forEach((controller) => {
            controller.abort('listener-cancelled');
          });
        },
        safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {
          try {
            errorHandler(errorToNotify, errorInfo);
          } catch (errorHandlerError) {
            setTimeout(() => {
              throw errorHandlerError;
            }, 0);
          }
        },
        addListener = redux_toolkit_modern_assign(createAction(`${alm}/add`), {
          withTypes: () => addListener,
        }),
        clearAllListeners = createAction(`${alm}/removeAll`),
        removeListener = redux_toolkit_modern_assign(createAction(`${alm}/remove`), {
          withTypes: () => removeListener,
        }),
        defaultErrorHandler = (...args) => {
          console.error(`${alm}/error`, ...args);
        },
        createListenerMiddleware = (middlewareOptions = {}) => {
          const listenerMap = new Map(),
            executingListeners = new Map(),
            { extra, onError = defaultErrorHandler } = middlewareOptions;
          assertFunction(onError);
          const startListening = (options) =>
            ((entry) => (
              (entry.unsubscribe = () => listenerMap.delete(entry.id)),
              listenerMap.set(entry.id, entry),
              (cancelOptions) => {
                (entry.unsubscribe(), cancelOptions?.cancelActive && cancelActiveListeners(entry));
              }
            ))(findListenerEntry(listenerMap, options) ?? createListenerEntry(options));
          redux_toolkit_modern_assign(startListening, { withTypes: () => startListening });
          const stopListening = (options) => {
            const entry = findListenerEntry(listenerMap, options);
            return (
              entry && (entry.unsubscribe(), options.cancelActive && cancelActiveListeners(entry)),
              !!entry
            );
          };
          redux_toolkit_modern_assign(stopListening, { withTypes: () => stopListening });
          const notifyListener = async (entry, action, api, getOriginalState) => {
              const internalTaskController = new AbortController(),
                take = createTakePattern(startListening, internalTaskController.signal),
                autoJoinPromises = [];
              try {
                (entry.pending.add(internalTaskController),
                  ((entry) => {
                    const count = executingListeners.get(entry) ?? 0;
                    executingListeners.set(entry, count + 1);
                  })(entry),
                  await Promise.resolve(
                    entry.effect(
                      action,
                      redux_toolkit_modern_assign({}, api, {
                        getOriginalState,
                        condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),
                        take,
                        delay: createDelay(internalTaskController.signal),
                        pause: createPause(internalTaskController.signal),
                        extra,
                        signal: internalTaskController.signal,
                        fork: createFork(internalTaskController.signal, autoJoinPromises),
                        unsubscribe: entry.unsubscribe,
                        subscribe: () => {
                          listenerMap.set(entry.id, entry);
                        },
                        cancelActiveListeners: () => {
                          entry.pending.forEach((controller, _, set) => {
                            controller !== internalTaskController &&
                              (controller.abort('listener-cancelled'), set.delete(controller));
                          });
                        },
                        cancel: () => {
                          (internalTaskController.abort('listener-cancelled'),
                            entry.pending.delete(internalTaskController));
                        },
                        throwIfCancelled: () => {
                          validateActive(internalTaskController.signal);
                        },
                      })
                    )
                  ));
              } catch (listenerError) {
                listenerError instanceof TaskAbortError ||
                  safelyNotifyError(onError, listenerError, { raisedBy: 'effect' });
              } finally {
                (await Promise.all(autoJoinPromises),
                  internalTaskController.abort('listener-completed'),
                  ((entry) => {
                    const count = executingListeners.get(entry) ?? 1;
                    1 === count
                      ? executingListeners.delete(entry)
                      : executingListeners.set(entry, count - 1);
                  })(entry),
                  entry.pending.delete(internalTaskController));
              }
            },
            clearListenerMiddleware = ((listenerMap, executingListeners) => () => {
              for (const listener2 of executingListeners.keys()) cancelActiveListeners(listener2);
              listenerMap.clear();
            })(listenerMap, executingListeners);
          return {
            middleware: (api) => (next) => (action) => {
              if (!(0, redux.ve)(action)) return next(action);
              if (addListener.match(action)) return startListening(action.payload);
              if (clearAllListeners.match(action)) return void clearListenerMiddleware();
              if (removeListener.match(action)) return stopListening(action.payload);
              let originalState = api.getState();
              const getOriginalState = () => {
                if (originalState === INTERNAL_NIL_TOKEN)
                  throw new Error(formatProdErrorMessage(23));
                return originalState;
              };
              let result;
              try {
                if (((result = next(action)), listenerMap.size > 0)) {
                  const currentState = api.getState(),
                    listenerEntries = Array.from(listenerMap.values());
                  for (const entry of listenerEntries) {
                    let runListener = !1;
                    try {
                      runListener = entry.predicate(action, currentState, originalState);
                    } catch (predicateError) {
                      ((runListener = !1),
                        safelyNotifyError(onError, predicateError, { raisedBy: 'predicate' }));
                    }
                    runListener && notifyListener(entry, action, api, getOriginalState);
                  }
                }
              } finally {
                originalState = INTERNAL_NIL_TOKEN;
              }
              return result;
            },
            startListening,
            stopListening,
            clearListeners: clearListenerMiddleware,
          };
        };
      Symbol.for('rtk-state-proxy-original');
      function formatProdErrorMessage(code) {
        return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
      }
    },
    './node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        Qx: () => isDraft,
        a6: () => isDraftable,
        jM: () => produce,
        ss: () => current,
      });
      var NOTHING = Symbol.for('immer-nothing'),
        DRAFTABLE = Symbol.for('immer-draftable'),
        DRAFT_STATE = Symbol.for('immer-state');
      function die(error, ...args) {
        throw new Error(
          `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
        );
      }
      var O = Object,
        getPrototypeOf = O.getPrototypeOf,
        CONFIGURABLE = 'configurable',
        ENUMERABLE = 'enumerable',
        WRITABLE = 'writable',
        VALUE = 'value',
        isDraft = (value) => !!value && !!value[DRAFT_STATE];
      function isDraftable(value) {
        return (
          !!value &&
          (isPlainObject(value) ||
            isArray(value) ||
            !!value[DRAFTABLE] ||
            !!value.constructor?.[DRAFTABLE] ||
            isMap(value) ||
            isSet(value))
        );
      }
      var objectCtorString = O.prototype.constructor.toString(),
        cachedCtorStrings = new WeakMap();
      function isPlainObject(value) {
        if (!value || !isObjectish(value)) return !1;
        const proto = getPrototypeOf(value);
        if (null === proto || proto === O.prototype) return !0;
        const Ctor = O.hasOwnProperty.call(proto, 'constructor') && proto.constructor;
        if (Ctor === Object) return !0;
        if (!isFunction(Ctor)) return !1;
        let ctorString = cachedCtorStrings.get(Ctor);
        return (
          void 0 === ctorString &&
            ((ctorString = Function.toString.call(Ctor)), cachedCtorStrings.set(Ctor, ctorString)),
          ctorString === objectCtorString
        );
      }
      function each(obj, iter, strict = !0) {
        if (0 === getArchtype(obj)) {
          (strict ? Reflect.ownKeys(obj) : O.keys(obj)).forEach((key) => {
            iter(key, obj[key], obj);
          });
        } else obj.forEach((entry, index) => iter(index, entry, obj));
      }
      function getArchtype(thing) {
        const state = thing[DRAFT_STATE];
        return state ? state.type_ : isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
      }
      var has = (thing, prop, type = getArchtype(thing)) =>
          2 === type ? thing.has(prop) : O.prototype.hasOwnProperty.call(thing, prop),
        get = (thing, prop, type = getArchtype(thing)) =>
          2 === type ? thing.get(prop) : thing[prop],
        set = (thing, propOrOldValue, value, type = getArchtype(thing)) => {
          2 === type
            ? thing.set(propOrOldValue, value)
            : 3 === type
              ? thing.add(value)
              : (thing[propOrOldValue] = value);
        };
      var isArray = Array.isArray,
        isMap = (target) => target instanceof Map,
        isSet = (target) => target instanceof Set,
        isObjectish = (target) => 'object' == typeof target,
        isFunction = (target) => 'function' == typeof target,
        isBoolean = (target) => 'boolean' == typeof target;
      var latest = (state) => state.copy_ || state.base_,
        getFinalValue = (state) => (state.modified_ ? state.copy_ : state.base_);
      function shallowCopy(base, strict) {
        if (isMap(base)) return new Map(base);
        if (isSet(base)) return new Set(base);
        if (isArray(base)) return Array.prototype.slice.call(base);
        const isPlain = isPlainObject(base);
        if (!0 === strict || ('class_only' === strict && !isPlain)) {
          const descriptors = O.getOwnPropertyDescriptors(base);
          delete descriptors[DRAFT_STATE];
          let keys = Reflect.ownKeys(descriptors);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i],
              desc = descriptors[key];
            (!1 === desc.writable && ((desc.writable = !0), (desc.configurable = !0)),
              (desc.get || desc.set) &&
                (descriptors[key] = {
                  [CONFIGURABLE]: !0,
                  [WRITABLE]: !0,
                  [ENUMERABLE]: desc.enumerable,
                  [VALUE]: base[key],
                }));
          }
          return O.create(getPrototypeOf(base), descriptors);
        }
        {
          const proto = getPrototypeOf(base);
          if (null !== proto && isPlain) return { ...base };
          const obj = O.create(proto);
          return O.assign(obj, base);
        }
      }
      function freeze(obj, deep = !1) {
        return (
          isFrozen(obj) ||
            isDraft(obj) ||
            !isDraftable(obj) ||
            (getArchtype(obj) > 1 &&
              O.defineProperties(obj, {
                set: dontMutateMethodOverride,
                add: dontMutateMethodOverride,
                clear: dontMutateMethodOverride,
                delete: dontMutateMethodOverride,
              }),
            O.freeze(obj),
            deep &&
              each(
                obj,
                (_key, value) => {
                  freeze(value, !0);
                },
                !1
              )),
          obj
        );
      }
      var dontMutateMethodOverride = {
        [VALUE]: function dontMutateFrozenCollections() {
          die(2);
        },
      };
      function isFrozen(obj) {
        return null === obj || !isObjectish(obj) || O.isFrozen(obj);
      }
      var plugins = {};
      function getPlugin(pluginKey) {
        const plugin = plugins[pluginKey];
        return (plugin || die(0), plugin);
      }
      var currentScope,
        isPluginLoaded = (pluginKey) => !!plugins[pluginKey];
      var getCurrentScope = () => currentScope;
      function usePatchesInScope(scope, patchListener) {
        patchListener &&
          ((scope.patchPlugin_ = getPlugin('Patches')),
          (scope.patches_ = []),
          (scope.inversePatches_ = []),
          (scope.patchListener_ = patchListener));
      }
      function revokeScope(scope) {
        (leaveScope(scope), scope.drafts_.forEach(revokeDraft), (scope.drafts_ = null));
      }
      function leaveScope(scope) {
        scope === currentScope && (currentScope = scope.parent_);
      }
      var enterScope = (immer2) =>
        (currentScope = {
          drafts_: [],
          parent_: currentScope,
          immer_: immer2,
          canAutoFreeze_: !0,
          unfinalizedDrafts_: 0,
          handledSet_: new Set(),
          processedForPatches_: new Set(),
          mapSetPlugin_: isPluginLoaded('MapSet') ? getPlugin('MapSet') : void 0,
          arrayMethodsPlugin_: isPluginLoaded('ArrayMethods') ? getPlugin('ArrayMethods') : void 0,
        });
      function revokeDraft(draft) {
        const state = draft[DRAFT_STATE];
        0 === state.type_ || 1 === state.type_ ? state.revoke_() : (state.revoked_ = !0);
      }
      function processResult(result, scope) {
        scope.unfinalizedDrafts_ = scope.drafts_.length;
        const baseDraft = scope.drafts_[0];
        if (void 0 !== result && result !== baseDraft) {
          (baseDraft[DRAFT_STATE].modified_ && (revokeScope(scope), die(4)),
            isDraftable(result) && (result = finalize(scope, result)));
          const { patchPlugin_ } = scope;
          patchPlugin_ &&
            patchPlugin_.generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope);
        } else result = finalize(scope, baseDraft);
        return (
          (function maybeFreeze(scope, value, deep = !1) {
            !scope.parent_ &&
              scope.immer_.autoFreeze_ &&
              scope.canAutoFreeze_ &&
              freeze(value, deep);
          })(scope, result, !0),
          revokeScope(scope),
          scope.patches_ && scope.patchListener_(scope.patches_, scope.inversePatches_),
          result !== NOTHING ? result : void 0
        );
      }
      function finalize(rootScope, value) {
        if (isFrozen(value)) return value;
        const state = value[DRAFT_STATE];
        if (!state) {
          return handleValue(value, rootScope.handledSet_, rootScope);
        }
        if (!isSameScope(state, rootScope)) return value;
        if (!state.modified_) return state.base_;
        if (!state.finalized_) {
          const { callbacks_ } = state;
          if (callbacks_)
            for (; callbacks_.length > 0; ) {
              callbacks_.pop()(rootScope);
            }
          generatePatchesAndFinalize(state, rootScope);
        }
        return state.copy_;
      }
      function markStateFinalized(state) {
        ((state.finalized_ = !0), state.scope_.unfinalizedDrafts_--);
      }
      var isSameScope = (state, rootScope) => state.scope_ === rootScope,
        EMPTY_LOCATIONS_RESULT = [];
      function updateDraftInParent(parent, draftValue, finalizedValue, originalKey) {
        const parentCopy = latest(parent),
          parentType = parent.type_;
        if (void 0 !== originalKey) {
          if (get(parentCopy, originalKey, parentType) === draftValue)
            return void set(parentCopy, originalKey, finalizedValue, parentType);
        }
        if (!parent.draftLocations_) {
          const draftLocations = (parent.draftLocations_ = new Map());
          each(parentCopy, (key, value) => {
            if (isDraft(value)) {
              const keys = draftLocations.get(value) || [];
              (keys.push(key), draftLocations.set(value, keys));
            }
          });
        }
        const locations = parent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT;
        for (const location of locations) set(parentCopy, location, finalizedValue, parentType);
      }
      function generatePatchesAndFinalize(state, rootScope) {
        if (
          state.modified_ &&
          !state.finalized_ &&
          (3 === state.type_ ||
            (1 === state.type_ && state.allIndicesReassigned_) ||
            (state.assigned_?.size ?? 0) > 0)
        ) {
          const { patchPlugin_ } = rootScope;
          if (patchPlugin_) {
            const basePath = patchPlugin_.getPath(state);
            basePath && patchPlugin_.generatePatches_(state, basePath, rootScope);
          }
          markStateFinalized(state);
        }
      }
      function handleCrossReference(target, key, value) {
        const { scope_ } = target;
        if (isDraft(value)) {
          const state = value[DRAFT_STATE];
          isSameScope(state, scope_) &&
            state.callbacks_.push(function crossReferenceCleanup() {
              prepareCopy(target);
              const finalizedValue = getFinalValue(state);
              updateDraftInParent(target, value, finalizedValue, key);
            });
        } else
          isDraftable(value) &&
            target.callbacks_.push(function nestedDraftCleanup() {
              const targetCopy = latest(target);
              3 === target.type_
                ? targetCopy.has(value) && handleValue(value, scope_.handledSet_, scope_)
                : get(targetCopy, key, target.type_) === value &&
                  scope_.drafts_.length > 1 &&
                  !0 === (target.assigned_.get(key) ?? !1) &&
                  target.copy_ &&
                  handleValue(get(target.copy_, key, target.type_), scope_.handledSet_, scope_);
            });
      }
      function handleValue(target, handledSet, rootScope) {
        return (
          (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) ||
            isDraft(target) ||
            handledSet.has(target) ||
            !isDraftable(target) ||
            isFrozen(target) ||
            (handledSet.add(target),
            each(target, (key, value) => {
              if (isDraft(value)) {
                const state = value[DRAFT_STATE];
                if (isSameScope(state, rootScope)) {
                  const updatedValue = getFinalValue(state);
                  (set(target, key, updatedValue, target.type_), markStateFinalized(state));
                }
              } else isDraftable(value) && handleValue(value, handledSet, rootScope);
            })),
          target
        );
      }
      var objectTraps = {
          get(state, prop) {
            if (prop === DRAFT_STATE) return state;
            let arrayPlugin = state.scope_.arrayMethodsPlugin_;
            const isArrayWithStringProp = 1 === state.type_ && 'string' == typeof prop;
            if (isArrayWithStringProp && arrayPlugin?.isArrayOperationMethod(prop))
              return arrayPlugin.createMethodInterceptor(state, prop);
            const source = latest(state);
            if (!has(source, prop, state.type_))
              return (function readPropFromProto(state, source, prop) {
                const desc = getDescriptorFromProto(source, prop);
                return desc
                  ? 'value' in desc
                    ? desc.value
                    : desc.get?.call(state.draft_)
                  : void 0;
              })(state, source, prop);
            const value = source[prop];
            if (state.finalized_ || !isDraftable(value)) return value;
            if (
              isArrayWithStringProp &&
              state.operationMethod &&
              arrayPlugin?.isMutatingArrayMethod(state.operationMethod) &&
              (function isArrayIndex(value) {
                const n = +value;
                return Number.isInteger(n) && String(n) === value;
              })(prop)
            )
              return value;
            if (value === peek(state.base_, prop)) {
              prepareCopy(state);
              const childKey = 1 === state.type_ ? +prop : prop,
                childDraft = createProxy(state.scope_, value, state, childKey);
              return (state.copy_[childKey] = childDraft);
            }
            return value;
          },
          has: (state, prop) => prop in latest(state),
          ownKeys: (state) => Reflect.ownKeys(latest(state)),
          set(state, prop, value) {
            const desc = getDescriptorFromProto(latest(state), prop);
            if (desc?.set) return (desc.set.call(state.draft_, value), !0);
            if (!state.modified_) {
              const current2 = peek(latest(state), prop),
                currentState = current2?.[DRAFT_STATE];
              if (currentState && currentState.base_ === value)
                return ((state.copy_[prop] = value), state.assigned_.set(prop, !1), !0);
              if (
                (function is(x, y) {
                  return x === y ? 0 !== x || 1 / x == 1 / y : x != x && y != y;
                })(value, current2) &&
                (void 0 !== value || has(state.base_, prop, state.type_))
              )
                return !0;
              (prepareCopy(state), markChanged(state));
            }
            return (
              (state.copy_[prop] === value && (void 0 !== value || prop in state.copy_)) ||
                (Number.isNaN(value) && Number.isNaN(state.copy_[prop])) ||
                ((state.copy_[prop] = value),
                state.assigned_.set(prop, !0),
                handleCrossReference(state, prop, value)),
              !0
            );
          },
          deleteProperty: (state, prop) => (
            prepareCopy(state),
            void 0 !== peek(state.base_, prop) || prop in state.base_
              ? (state.assigned_.set(prop, !1), markChanged(state))
              : state.assigned_.delete(prop),
            state.copy_ && delete state.copy_[prop],
            !0
          ),
          getOwnPropertyDescriptor(state, prop) {
            const owner = latest(state),
              desc = Reflect.getOwnPropertyDescriptor(owner, prop);
            return desc
              ? {
                  [WRITABLE]: !0,
                  [CONFIGURABLE]: 1 !== state.type_ || 'length' !== prop,
                  [ENUMERABLE]: desc.enumerable,
                  [VALUE]: owner[prop],
                }
              : desc;
          },
          defineProperty() {
            die(11);
          },
          getPrototypeOf: (state) => getPrototypeOf(state.base_),
          setPrototypeOf() {
            die(12);
          },
        },
        arrayTraps = {};
      for (let key in objectTraps) {
        let fn = objectTraps[key];
        arrayTraps[key] = function () {
          const args = arguments;
          return ((args[0] = args[0][0]), fn.apply(this, args));
        };
      }
      function peek(draft, prop) {
        const state = draft[DRAFT_STATE];
        return (state ? latest(state) : draft)[prop];
      }
      function getDescriptorFromProto(source, prop) {
        if (!(prop in source)) return;
        let proto = getPrototypeOf(source);
        for (; proto; ) {
          const desc = Object.getOwnPropertyDescriptor(proto, prop);
          if (desc) return desc;
          proto = getPrototypeOf(proto);
        }
      }
      function markChanged(state) {
        state.modified_ || ((state.modified_ = !0), state.parent_ && markChanged(state.parent_));
      }
      function prepareCopy(state) {
        state.copy_ ||
          ((state.assigned_ = new Map()),
          (state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_)));
      }
      ((arrayTraps.deleteProperty = function (state, prop) {
        return arrayTraps.set.call(this, state, prop, void 0);
      }),
        (arrayTraps.set = function (state, prop, value) {
          return objectTraps.set.call(this, state[0], prop, value, state[0]);
        }));
      function createProxy(rootScope, value, parent, key) {
        const [draft, state] = isMap(value)
          ? getPlugin('MapSet').proxyMap_(value, parent)
          : isSet(value)
            ? getPlugin('MapSet').proxySet_(value, parent)
            : (function createProxyProxy(base, parent) {
                const baseIsArray = isArray(base),
                  state = {
                    type_: baseIsArray ? 1 : 0,
                    scope_: parent ? parent.scope_ : getCurrentScope(),
                    modified_: !1,
                    finalized_: !1,
                    assigned_: void 0,
                    parent_: parent,
                    base_: base,
                    draft_: null,
                    copy_: null,
                    revoke_: null,
                    isManual_: !1,
                    callbacks_: void 0,
                  };
                let target = state,
                  traps = objectTraps;
                baseIsArray && ((target = [state]), (traps = arrayTraps));
                const { revoke, proxy } = Proxy.revocable(target, traps);
                return ((state.draft_ = proxy), (state.revoke_ = revoke), [proxy, state]);
              })(value, parent);
        return (
          (parent?.scope_ ?? getCurrentScope()).drafts_.push(draft),
          (state.callbacks_ = parent?.callbacks_ ?? []),
          (state.key_ = key),
          parent && void 0 !== key
            ? (function registerChildFinalizationCallback(parent, child, key) {
                parent.callbacks_.push(function childCleanup(rootScope) {
                  const state = child;
                  if (!state || !isSameScope(state, rootScope)) return;
                  rootScope.mapSetPlugin_?.fixSetContents(state);
                  const finalizedValue = getFinalValue(state);
                  (updateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key),
                    generatePatchesAndFinalize(state, rootScope));
                });
              })(parent, state, key)
            : state.callbacks_.push(function rootDraftCleanup(rootScope2) {
                rootScope2.mapSetPlugin_?.fixSetContents(state);
                const { patchPlugin_ } = rootScope2;
                state.modified_ &&
                  patchPlugin_ &&
                  patchPlugin_.generatePatches_(state, [], rootScope2);
              }),
          draft
        );
      }
      function current(value) {
        return (isDraft(value) || die(10), currentImpl(value));
      }
      function currentImpl(value) {
        if (!isDraftable(value) || isFrozen(value)) return value;
        const state = value[DRAFT_STATE];
        let copy,
          strict = !0;
        if (state) {
          if (!state.modified_) return state.base_;
          ((state.finalized_ = !0),
            (copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)),
            (strict = state.scope_.immer_.shouldUseStrictIteration()));
        } else copy = shallowCopy(value, !0);
        return (
          each(
            copy,
            (key, childValue) => {
              set(copy, key, currentImpl(childValue));
            },
            strict
          ),
          state && (state.finalized_ = !1),
          copy
        );
      }
      var immer = new (class {
          constructor(config) {
            ((this.autoFreeze_ = !0),
              (this.useStrictShallowCopy_ = !1),
              (this.useStrictIteration_ = !1),
              (this.produce = (base, recipe, patchListener) => {
                if (isFunction(base) && !isFunction(recipe)) {
                  const defaultBase = recipe;
                  recipe = base;
                  const self = this;
                  return function curriedProduce(base2 = defaultBase, ...args) {
                    return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
                  };
                }
                let result;
                if (
                  (isFunction(recipe) || die(6),
                  void 0 === patchListener || isFunction(patchListener) || die(7),
                  isDraftable(base))
                ) {
                  const scope = enterScope(this),
                    proxy = createProxy(scope, base, void 0);
                  let hasError = !0;
                  try {
                    ((result = recipe(proxy)), (hasError = !1));
                  } finally {
                    hasError ? revokeScope(scope) : leaveScope(scope);
                  }
                  return (usePatchesInScope(scope, patchListener), processResult(result, scope));
                }
                if (!base || !isObjectish(base)) {
                  if (
                    ((result = recipe(base)),
                    void 0 === result && (result = base),
                    result === NOTHING && (result = void 0),
                    this.autoFreeze_ && freeze(result, !0),
                    patchListener)
                  ) {
                    const p = [],
                      ip = [];
                    (getPlugin('Patches').generateReplacementPatches_(base, result, {
                      patches_: p,
                      inversePatches_: ip,
                    }),
                      patchListener(p, ip));
                  }
                  return result;
                }
                die(1);
              }),
              (this.produceWithPatches = (base, recipe) => {
                if (isFunction(base))
                  return (state, ...args) =>
                    this.produceWithPatches(state, (draft) => base(draft, ...args));
                let patches, inversePatches;
                return [
                  this.produce(base, recipe, (p, ip) => {
                    ((patches = p), (inversePatches = ip));
                  }),
                  patches,
                  inversePatches,
                ];
              }),
              isBoolean(config?.autoFreeze) && this.setAutoFreeze(config.autoFreeze),
              isBoolean(config?.useStrictShallowCopy) &&
                this.setUseStrictShallowCopy(config.useStrictShallowCopy),
              isBoolean(config?.useStrictIteration) &&
                this.setUseStrictIteration(config.useStrictIteration));
          }
          createDraft(base) {
            (isDraftable(base) || die(8), isDraft(base) && (base = current(base)));
            const scope = enterScope(this),
              proxy = createProxy(scope, base, void 0);
            return ((proxy[DRAFT_STATE].isManual_ = !0), leaveScope(scope), proxy);
          }
          finishDraft(draft, patchListener) {
            const state = draft && draft[DRAFT_STATE];
            (state && state.isManual_) || die(9);
            const { scope_: scope } = state;
            return (usePatchesInScope(scope, patchListener), processResult(void 0, scope));
          }
          setAutoFreeze(value) {
            this.autoFreeze_ = value;
          }
          setUseStrictShallowCopy(value) {
            this.useStrictShallowCopy_ = value;
          }
          setUseStrictIteration(value) {
            this.useStrictIteration_ = value;
          }
          shouldUseStrictIteration() {
            return this.useStrictIteration_;
          }
          applyPatches(base, patches) {
            let i;
            for (i = patches.length - 1; i >= 0; i--) {
              const patch = patches[i];
              if (0 === patch.path.length && 'replace' === patch.op) {
                base = patch.value;
                break;
              }
            }
            i > -1 && (patches = patches.slice(i + 1));
            const applyPatchesImpl = getPlugin('Patches').applyPatches_;
            return isDraft(base)
              ? applyPatchesImpl(base, patches)
              : this.produce(base, (draft) => applyPatchesImpl(draft, patches));
          }
        })(),
        produce = immer.produce;
    },
    './node_modules/d3-shape/src/array.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { A: () => __WEBPACK_DEFAULT_EXPORT__ });
      Array.prototype.slice;
      function __WEBPACK_DEFAULT_EXPORT__(x) {
        return 'object' == typeof x && 'length' in x ? x : Array.from(x);
      }
    },
    './node_modules/d3-shape/src/constant.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      function __WEBPACK_DEFAULT_EXPORT__(x) {
        return function constant() {
          return x;
        };
      }
      __webpack_require__.d(__webpack_exports__, { A: () => __WEBPACK_DEFAULT_EXPORT__ });
    },
    './node_modules/d3-shape/src/path.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { i: () => withPath });
      const pi = Math.PI,
        tau = 2 * pi,
        tauEpsilon = tau - 1e-6;
      function append(strings) {
        this._ += strings[0];
        for (let i = 1, n = strings.length; i < n; ++i) this._ += arguments[i] + strings[i];
      }
      class Path {
        constructor(digits) {
          ((this._x0 = this._y0 = this._x1 = this._y1 = null),
            (this._ = ''),
            (this._append =
              null == digits
                ? append
                : (function appendRound(digits) {
                    let d = Math.floor(digits);
                    if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
                    if (d > 15) return append;
                    const k = 10 ** d;
                    return function (strings) {
                      this._ += strings[0];
                      for (let i = 1, n = strings.length; i < n; ++i)
                        this._ += Math.round(arguments[i] * k) / k + strings[i];
                    };
                  })(digits)));
        }
        moveTo(x, y) {
          this._append`M${(this._x0 = this._x1 = +x)},${(this._y0 = this._y1 = +y)}`;
        }
        closePath() {
          null !== this._x1 && ((this._x1 = this._x0), (this._y1 = this._y0), this._append`Z`);
        }
        lineTo(x, y) {
          this._append`L${(this._x1 = +x)},${(this._y1 = +y)}`;
        }
        quadraticCurveTo(x1, y1, x, y) {
          this._append`Q${+x1},${+y1},${(this._x1 = +x)},${(this._y1 = +y)}`;
        }
        bezierCurveTo(x1, y1, x2, y2, x, y) {
          this._append`C${+x1},${+y1},${+x2},${+y2},${(this._x1 = +x)},${(this._y1 = +y)}`;
        }
        arcTo(x1, y1, x2, y2, r) {
          if (((x1 = +x1), (y1 = +y1), (x2 = +x2), (y2 = +y2), (r = +r) < 0))
            throw new Error(`negative radius: ${r}`);
          let x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;
          if (null === this._x1) this._append`M${(this._x1 = x1)},${(this._y1 = y1)}`;
          else if (l01_2 > 1e-6)
            if (Math.abs(y01 * x21 - y21 * x01) > 1e-6 && r) {
              let x20 = x2 - x0,
                y20 = y2 - y0,
                l21_2 = x21 * x21 + y21 * y21,
                l20_2 = x20 * x20 + y20 * y20,
                l21 = Math.sqrt(l21_2),
                l01 = Math.sqrt(l01_2),
                l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
                t01 = l / l01,
                t21 = l / l21;
              (Math.abs(t01 - 1) > 1e-6 && this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`,
                this
                  ._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${(this._x1 = x1 + t21 * x21)},${(this._y1 = y1 + t21 * y21)}`);
            } else this._append`L${(this._x1 = x1)},${(this._y1 = y1)}`;
          else;
        }
        arc(x, y, r, a0, a1, ccw) {
          if (((x = +x), (y = +y), (ccw = !!ccw), (r = +r) < 0))
            throw new Error(`negative radius: ${r}`);
          let dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;
          (null === this._x1
            ? this._append`M${x0},${y0}`
            : (Math.abs(this._x1 - x0) > 1e-6 || Math.abs(this._y1 - y0) > 1e-6) &&
              this._append`L${x0},${y0}`,
            r &&
              (da < 0 && (da = (da % tau) + tau),
              da > tauEpsilon
                ? this
                    ._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${(this._x1 = x0)},${(this._y1 = y0)}`
                : da > 1e-6 &&
                  this
                    ._append`A${r},${r},0,${+(da >= pi)},${cw},${(this._x1 = x + r * Math.cos(a1))},${(this._y1 = y + r * Math.sin(a1))}`));
        }
        rect(x, y, w, h) {
          this
            ._append`M${(this._x0 = this._x1 = +x)},${(this._y0 = this._y1 = +y)}h${(w = +w)}v${+h}h${-w}Z`;
        }
        toString() {
          return this._;
        }
      }
      function withPath(shape) {
        let digits = 3;
        return (
          (shape.digits = function (_) {
            if (!arguments.length) return digits;
            if (null == _) digits = null;
            else {
              const d = Math.floor(_);
              if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
              digits = d;
            }
            return shape;
          }),
          () => new Path(digits)
        );
      }
    },
    './node_modules/decimal.js-light/decimal.js'(module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      !(function () {
        'use strict';
        var ONE,
          Decimal = {
            precision: 20,
            rounding: 4,
            toExpNeg: -7,
            toExpPos: 21,
            LN10: '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286',
          },
          external = !0,
          decimalError = '[DecimalError] ',
          invalidArgument = decimalError + 'Invalid argument: ',
          exponentOutOfRange = decimalError + 'Exponent out of range: ',
          mathfloor = Math.floor,
          mathpow = Math.pow,
          isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
          BASE = 1e7,
          MAX_E = mathfloor(1286742750677284.5),
          P = {};
        function add(x, y) {
          var carry,
            d,
            e,
            i,
            k,
            len,
            xd,
            yd,
            Ctor = x.constructor,
            pr = Ctor.precision;
          if (!x.s || !y.s) return (y.s || (y = new Ctor(x)), external ? round(y, pr) : y);
          if (((xd = x.d), (yd = y.d), (k = x.e), (e = y.e), (xd = xd.slice()), (i = k - e))) {
            for (
              i < 0
                ? ((d = xd), (i = -i), (len = yd.length))
                : ((d = yd), (e = k), (len = xd.length)),
                i > (len = (k = Math.ceil(pr / 7)) > len ? k + 1 : len + 1) &&
                  ((i = len), (d.length = 1)),
                d.reverse();
              i--;
            )
              d.push(0);
            d.reverse();
          }
          for (
            (len = xd.length) - (i = yd.length) < 0 && ((i = len), (d = yd), (yd = xd), (xd = d)),
              carry = 0;
            i;
          )
            ((carry = ((xd[--i] = xd[i] + yd[i] + carry) / BASE) | 0), (xd[i] %= BASE));
          for (carry && (xd.unshift(carry), ++e), len = xd.length; 0 == xd[--len]; ) xd.pop();
          return ((y.d = xd), (y.e = e), external ? round(y, pr) : y);
        }
        function checkInt32(i, min, max) {
          if (i !== ~~i || i < min || i > max) throw Error(invalidArgument + i);
        }
        function digitsToString(d) {
          var i,
            k,
            ws,
            indexOfLastWord = d.length - 1,
            str = '',
            w = d[0];
          if (indexOfLastWord > 0) {
            for (str += w, i = 1; i < indexOfLastWord; i++)
              ((k = 7 - (ws = d[i] + '').length) && (str += getZeroString(k)), (str += ws));
            (k = 7 - (ws = (w = d[i]) + '').length) && (str += getZeroString(k));
          } else if (0 === w) return '0';
          for (; w % 10 == 0; ) w /= 10;
          return str + w;
        }
        ((P.absoluteValue = P.abs =
          function () {
            var x = new this.constructor(this);
            return (x.s && (x.s = 1), x);
          }),
          (P.comparedTo = P.cmp =
            function (y) {
              var i,
                j,
                xdL,
                ydL,
                x = this;
              if (((y = new x.constructor(y)), x.s !== y.s)) return x.s || -y.s;
              if (x.e !== y.e) return (x.e > y.e) ^ (x.s < 0) ? 1 : -1;
              for (i = 0, j = (xdL = x.d.length) < (ydL = y.d.length) ? xdL : ydL; i < j; ++i)
                if (x.d[i] !== y.d[i]) return (x.d[i] > y.d[i]) ^ (x.s < 0) ? 1 : -1;
              return xdL === ydL ? 0 : (xdL > ydL) ^ (x.s < 0) ? 1 : -1;
            }),
          (P.decimalPlaces = P.dp =
            function () {
              var x = this,
                w = x.d.length - 1,
                dp = 7 * (w - x.e);
              if ((w = x.d[w])) for (; w % 10 == 0; w /= 10) dp--;
              return dp < 0 ? 0 : dp;
            }),
          (P.dividedBy = P.div =
            function (y) {
              return divide(this, new this.constructor(y));
            }),
          (P.dividedToIntegerBy = P.idiv =
            function (y) {
              var Ctor = this.constructor;
              return round(divide(this, new Ctor(y), 0, 1), Ctor.precision);
            }),
          (P.equals = P.eq =
            function (y) {
              return !this.cmp(y);
            }),
          (P.exponent = function () {
            return getBase10Exponent(this);
          }),
          (P.greaterThan = P.gt =
            function (y) {
              return this.cmp(y) > 0;
            }),
          (P.greaterThanOrEqualTo = P.gte =
            function (y) {
              return this.cmp(y) >= 0;
            }),
          (P.isInteger = P.isint =
            function () {
              return this.e > this.d.length - 2;
            }),
          (P.isNegative = P.isneg =
            function () {
              return this.s < 0;
            }),
          (P.isPositive = P.ispos =
            function () {
              return this.s > 0;
            }),
          (P.isZero = function () {
            return 0 === this.s;
          }),
          (P.lessThan = P.lt =
            function (y) {
              return this.cmp(y) < 0;
            }),
          (P.lessThanOrEqualTo = P.lte =
            function (y) {
              return this.cmp(y) < 1;
            }),
          (P.logarithm = P.log =
            function (base) {
              var r,
                x = this,
                Ctor = x.constructor,
                pr = Ctor.precision,
                wpr = pr + 5;
              if (void 0 === base) base = new Ctor(10);
              else if ((base = new Ctor(base)).s < 1 || base.eq(ONE))
                throw Error(decimalError + 'NaN');
              if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));
              return x.eq(ONE)
                ? new Ctor(0)
                : ((external = !1),
                  (r = divide(ln(x, wpr), ln(base, wpr), wpr)),
                  (external = !0),
                  round(r, pr));
            }),
          (P.minus = P.sub =
            function (y) {
              var x = this;
              return (
                (y = new x.constructor(y)),
                x.s == y.s ? subtract(x, y) : add(x, ((y.s = -y.s), y))
              );
            }),
          (P.modulo = P.mod =
            function (y) {
              var q,
                x = this,
                Ctor = x.constructor,
                pr = Ctor.precision;
              if (!(y = new Ctor(y)).s) throw Error(decimalError + 'NaN');
              return x.s
                ? ((external = !1), (q = divide(x, y, 0, 1).times(y)), (external = !0), x.minus(q))
                : round(new Ctor(x), pr);
            }),
          (P.naturalExponential = P.exp =
            function () {
              return exp(this);
            }),
          (P.naturalLogarithm = P.ln =
            function () {
              return ln(this);
            }),
          (P.negated = P.neg =
            function () {
              var x = new this.constructor(this);
              return ((x.s = -x.s || 0), x);
            }),
          (P.plus = P.add =
            function (y) {
              var x = this;
              return (
                (y = new x.constructor(y)),
                x.s == y.s ? add(x, y) : subtract(x, ((y.s = -y.s), y))
              );
            }),
          (P.precision = P.sd =
            function (z) {
              var e,
                sd,
                w,
                x = this;
              if (void 0 !== z && z !== !!z && 1 !== z && 0 !== z) throw Error(invalidArgument + z);
              if (
                ((e = getBase10Exponent(x) + 1), (sd = 7 * (w = x.d.length - 1) + 1), (w = x.d[w]))
              ) {
                for (; w % 10 == 0; w /= 10) sd--;
                for (w = x.d[0]; w >= 10; w /= 10) sd++;
              }
              return z && e > sd ? e : sd;
            }),
          (P.squareRoot = P.sqrt =
            function () {
              var e,
                n,
                pr,
                r,
                s,
                t,
                wpr,
                x = this,
                Ctor = x.constructor;
              if (x.s < 1) {
                if (!x.s) return new Ctor(0);
                throw Error(decimalError + 'NaN');
              }
              for (
                e = getBase10Exponent(x),
                  external = !1,
                  0 == (s = Math.sqrt(+x)) || s == 1 / 0
                    ? (((n = digitsToString(x.d)).length + e) % 2 == 0 && (n += '0'),
                      (s = Math.sqrt(n)),
                      (e = mathfloor((e + 1) / 2) - (e < 0 || e % 2)),
                      (r = new Ctor(
                        (n =
                          s == 1 / 0
                            ? '5e' + e
                            : (n = s.toExponential()).slice(0, n.indexOf('e') + 1) + e)
                      )))
                    : (r = new Ctor(s.toString())),
                  s = wpr = (pr = Ctor.precision) + 3;
                ;
              )
                if (
                  ((r = (t = r).plus(divide(x, t, wpr + 2)).times(0.5)),
                  digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr))
                ) {
                  if (((n = n.slice(wpr - 3, wpr + 1)), s == wpr && '4999' == n)) {
                    if ((round(t, pr + 1, 0), t.times(t).eq(x))) {
                      r = t;
                      break;
                    }
                  } else if ('9999' != n) break;
                  wpr += 4;
                }
              return ((external = !0), round(r, pr));
            }),
          (P.times = P.mul =
            function (y) {
              var carry,
                e,
                i,
                k,
                r,
                rL,
                t,
                xdL,
                ydL,
                x = this,
                Ctor = x.constructor,
                xd = x.d,
                yd = (y = new Ctor(y)).d;
              if (!x.s || !y.s) return new Ctor(0);
              for (
                y.s *= x.s,
                  e = x.e + y.e,
                  (xdL = xd.length) < (ydL = yd.length) &&
                    ((r = xd), (xd = yd), (yd = r), (rL = xdL), (xdL = ydL), (ydL = rL)),
                  r = [],
                  i = rL = xdL + ydL;
                i--;
              )
                r.push(0);
              for (i = ydL; --i >= 0; ) {
                for (carry = 0, k = xdL + i; k > i; )
                  ((t = r[k] + yd[i] * xd[k - i - 1] + carry),
                    (r[k--] = (t % BASE) | 0),
                    (carry = (t / BASE) | 0));
                r[k] = ((r[k] + carry) % BASE) | 0;
              }
              for (; !r[--rL]; ) r.pop();
              return (
                carry ? ++e : r.shift(),
                (y.d = r),
                (y.e = e),
                external ? round(y, Ctor.precision) : y
              );
            }),
          (P.toDecimalPlaces = P.todp =
            function (dp, rm) {
              var x = this,
                Ctor = x.constructor;
              return (
                (x = new Ctor(x)),
                void 0 === dp
                  ? x
                  : (checkInt32(dp, 0, 1e9),
                    void 0 === rm ? (rm = Ctor.rounding) : checkInt32(rm, 0, 8),
                    round(x, dp + getBase10Exponent(x) + 1, rm))
              );
            }),
          (P.toExponential = function (dp, rm) {
            var str,
              x = this,
              Ctor = x.constructor;
            return (
              void 0 === dp
                ? (str = toString(x, !0))
                : (checkInt32(dp, 0, 1e9),
                  void 0 === rm ? (rm = Ctor.rounding) : checkInt32(rm, 0, 8),
                  (str = toString((x = round(new Ctor(x), dp + 1, rm)), !0, dp + 1))),
              str
            );
          }),
          (P.toFixed = function (dp, rm) {
            var str,
              y,
              x = this,
              Ctor = x.constructor;
            return void 0 === dp
              ? toString(x)
              : (checkInt32(dp, 0, 1e9),
                void 0 === rm ? (rm = Ctor.rounding) : checkInt32(rm, 0, 8),
                (str = toString(
                  (y = round(new Ctor(x), dp + getBase10Exponent(x) + 1, rm)).abs(),
                  !1,
                  dp + getBase10Exponent(y) + 1
                )),
                x.isneg() && !x.isZero() ? '-' + str : str);
          }),
          (P.toInteger = P.toint =
            function () {
              var x = this,
                Ctor = x.constructor;
              return round(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
            }),
          (P.toNumber = function () {
            return +this;
          }),
          (P.toPower = P.pow =
            function (y) {
              var e,
                k,
                pr,
                r,
                sign,
                yIsInt,
                x = this,
                Ctor = x.constructor,
                yn = +(y = new Ctor(y));
              if (!y.s) return new Ctor(ONE);
              if (!(x = new Ctor(x)).s) {
                if (y.s < 1) throw Error(decimalError + 'Infinity');
                return x;
              }
              if (x.eq(ONE)) return x;
              if (((pr = Ctor.precision), y.eq(ONE))) return round(x, pr);
              if (((yIsInt = (e = y.e) >= (k = y.d.length - 1)), (sign = x.s), yIsInt)) {
                if ((k = yn < 0 ? -yn : yn) <= 9007199254740991) {
                  for (
                    r = new Ctor(ONE), e = Math.ceil(pr / 7 + 4), external = !1;
                    k % 2 && truncate((r = r.times(x)).d, e), 0 !== (k = mathfloor(k / 2));
                  )
                    truncate((x = x.times(x)).d, e);
                  return ((external = !0), y.s < 0 ? new Ctor(ONE).div(r) : round(r, pr));
                }
              } else if (sign < 0) throw Error(decimalError + 'NaN');
              return (
                (sign = sign < 0 && 1 & y.d[Math.max(e, k)] ? -1 : 1),
                (x.s = 1),
                (external = !1),
                (r = y.times(ln(x, pr + 12))),
                (external = !0),
                ((r = exp(r)).s = sign),
                r
              );
            }),
          (P.toPrecision = function (sd, rm) {
            var e,
              str,
              x = this,
              Ctor = x.constructor;
            return (
              void 0 === sd
                ? (str = toString(
                    x,
                    (e = getBase10Exponent(x)) <= Ctor.toExpNeg || e >= Ctor.toExpPos
                  ))
                : (checkInt32(sd, 1, 1e9),
                  void 0 === rm ? (rm = Ctor.rounding) : checkInt32(rm, 0, 8),
                  (str = toString(
                    (x = round(new Ctor(x), sd, rm)),
                    sd <= (e = getBase10Exponent(x)) || e <= Ctor.toExpNeg,
                    sd
                  ))),
              str
            );
          }),
          (P.toSignificantDigits = P.tosd =
            function (sd, rm) {
              var Ctor = this.constructor;
              return (
                void 0 === sd
                  ? ((sd = Ctor.precision), (rm = Ctor.rounding))
                  : (checkInt32(sd, 1, 1e9),
                    void 0 === rm ? (rm = Ctor.rounding) : checkInt32(rm, 0, 8)),
                round(new Ctor(this), sd, rm)
              );
            }),
          (P.toString =
            P.valueOf =
            P.val =
            P.toJSON =
              function () {
                var x = this,
                  e = getBase10Exponent(x),
                  Ctor = x.constructor;
                return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
              }));
        var divide = (function () {
          function multiplyInteger(x, k) {
            var temp,
              carry = 0,
              i = x.length;
            for (x = x.slice(); i--; )
              ((temp = x[i] * k + carry), (x[i] = (temp % BASE) | 0), (carry = (temp / BASE) | 0));
            return (carry && x.unshift(carry), x);
          }
          function compare(a, b, aL, bL) {
            var i, r;
            if (aL != bL) r = aL > bL ? 1 : -1;
            else
              for (i = r = 0; i < aL; i++)
                if (a[i] != b[i]) {
                  r = a[i] > b[i] ? 1 : -1;
                  break;
                }
            return r;
          }
          function subtract(a, b, aL) {
            for (var i = 0; aL--; )
              ((a[aL] -= i), (i = a[aL] < b[aL] ? 1 : 0), (a[aL] = i * BASE + a[aL] - b[aL]));
            for (; !a[0] && a.length > 1; ) a.shift();
          }
          return function (x, y, pr, dp) {
            var cmp,
              e,
              i,
              k,
              prod,
              prodL,
              q,
              qd,
              rem,
              remL,
              rem0,
              sd,
              t,
              xi,
              xL,
              yd0,
              yL,
              yz,
              Ctor = x.constructor,
              sign = x.s == y.s ? 1 : -1,
              xd = x.d,
              yd = y.d;
            if (!x.s) return new Ctor(x);
            if (!y.s) throw Error(decimalError + 'Division by zero');
            for (
              e = x.e - y.e,
                yL = yd.length,
                xL = xd.length,
                qd = (q = new Ctor(sign)).d = [],
                i = 0;
              yd[i] == (xd[i] || 0);
            )
              ++i;
            if (
              (yd[i] > (xd[i] || 0) && --e,
              (sd =
                null == pr
                  ? (pr = Ctor.precision)
                  : dp
                    ? pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1
                    : pr) < 0)
            )
              return new Ctor(0);
            if (((sd = (sd / 7 + 2) | 0), (i = 0), 1 == yL))
              for (k = 0, yd = yd[0], sd++; (i < xL || k) && sd--; i++)
                ((t = k * BASE + (xd[i] || 0)), (qd[i] = (t / yd) | 0), (k = (t % yd) | 0));
            else {
              for (
                (k = (BASE / (yd[0] + 1)) | 0) > 1 &&
                  ((yd = multiplyInteger(yd, k)),
                  (xd = multiplyInteger(xd, k)),
                  (yL = yd.length),
                  (xL = xd.length)),
                  xi = yL,
                  remL = (rem = xd.slice(0, yL)).length;
                remL < yL;
              )
                rem[remL++] = 0;
              ((yz = yd.slice()).unshift(0), (yd0 = yd[0]), yd[1] >= BASE / 2 && ++yd0);
              do {
                ((k = 0),
                  (cmp = compare(yd, rem, yL, remL)) < 0
                    ? ((rem0 = rem[0]),
                      yL != remL && (rem0 = rem0 * BASE + (rem[1] || 0)),
                      (k = (rem0 / yd0) | 0) > 1
                        ? (k >= BASE && (k = BASE - 1),
                          1 ==
                            (cmp = compare(
                              (prod = multiplyInteger(yd, k)),
                              rem,
                              (prodL = prod.length),
                              (remL = rem.length)
                            )) && (k--, subtract(prod, yL < prodL ? yz : yd, prodL)))
                        : (0 == k && (cmp = k = 1), (prod = yd.slice())),
                      (prodL = prod.length) < remL && prod.unshift(0),
                      subtract(rem, prod, remL),
                      -1 == cmp &&
                        (cmp = compare(yd, rem, yL, (remL = rem.length))) < 1 &&
                        (k++, subtract(rem, yL < remL ? yz : yd, remL)),
                      (remL = rem.length))
                    : 0 === cmp && (k++, (rem = [0])),
                  (qd[i++] = k),
                  cmp && rem[0] ? (rem[remL++] = xd[xi] || 0) : ((rem = [xd[xi]]), (remL = 1)));
              } while ((xi++ < xL || void 0 !== rem[0]) && sd--);
            }
            return (
              qd[0] || qd.shift(),
              (q.e = e),
              round(q, dp ? pr + getBase10Exponent(q) + 1 : pr)
            );
          };
        })();
        function exp(x, sd) {
          var denominator,
            pow,
            sum,
            t,
            wpr,
            i = 0,
            k = 0,
            Ctor = x.constructor,
            pr = Ctor.precision;
          if (getBase10Exponent(x) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x));
          if (!x.s) return new Ctor(ONE);
          for (
            null == sd ? ((external = !1), (wpr = pr)) : (wpr = sd), t = new Ctor(0.03125);
            x.abs().gte(0.1);
          )
            ((x = x.times(t)), (k += 5));
          for (
            wpr += ((Math.log(mathpow(2, k)) / Math.LN10) * 2 + 5) | 0,
              denominator = pow = sum = new Ctor(ONE),
              Ctor.precision = wpr;
            ;
          ) {
            if (
              ((pow = round(pow.times(x), wpr)),
              (denominator = denominator.times(++i)),
              digitsToString((t = sum.plus(divide(pow, denominator, wpr))).d).slice(0, wpr) ===
                digitsToString(sum.d).slice(0, wpr))
            ) {
              for (; k--; ) sum = round(sum.times(sum), wpr);
              return ((Ctor.precision = pr), null == sd ? ((external = !0), round(sum, pr)) : sum);
            }
            sum = t;
          }
        }
        function getBase10Exponent(x) {
          for (var e = 7 * x.e, w = x.d[0]; w >= 10; w /= 10) e++;
          return e;
        }
        function getLn10(Ctor, sd, pr) {
          if (sd > Ctor.LN10.sd())
            throw (
              (external = !0),
              pr && (Ctor.precision = pr),
              Error(decimalError + 'LN10 precision limit exceeded')
            );
          return round(new Ctor(Ctor.LN10), sd);
        }
        function getZeroString(k) {
          for (var zs = ''; k--; ) zs += '0';
          return zs;
        }
        function ln(y, sd) {
          var c,
            c0,
            denominator,
            e,
            numerator,
            sum,
            t,
            wpr,
            x2,
            n = 1,
            x = y,
            xd = x.d,
            Ctor = x.constructor,
            pr = Ctor.precision;
          if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));
          if (x.eq(ONE)) return new Ctor(0);
          if ((null == sd ? ((external = !1), (wpr = pr)) : (wpr = sd), x.eq(10)))
            return (null == sd && (external = !0), getLn10(Ctor, wpr));
          if (
            ((wpr += 10),
            (Ctor.precision = wpr),
            (c0 = (c = digitsToString(xd)).charAt(0)),
            (e = getBase10Exponent(x)),
            !(Math.abs(e) < 15e14))
          )
            return (
              (t = getLn10(Ctor, wpr + 2, pr).times(e + '')),
              (x = ln(new Ctor(c0 + '.' + c.slice(1)), wpr - 10).plus(t)),
              (Ctor.precision = pr),
              null == sd ? ((external = !0), round(x, pr)) : x
            );
          for (; (c0 < 7 && 1 != c0) || (1 == c0 && c.charAt(1) > 3); )
            ((c0 = (c = digitsToString((x = x.times(y)).d)).charAt(0)), n++);
          for (
            e = getBase10Exponent(x),
              c0 > 1 ? ((x = new Ctor('0.' + c)), e++) : (x = new Ctor(c0 + '.' + c.slice(1))),
              sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr),
              x2 = round(x.times(x), wpr),
              denominator = 3;
            ;
          ) {
            if (
              ((numerator = round(numerator.times(x2), wpr)),
              digitsToString((t = sum.plus(divide(numerator, new Ctor(denominator), wpr))).d).slice(
                0,
                wpr
              ) === digitsToString(sum.d).slice(0, wpr))
            )
              return (
                (sum = sum.times(2)),
                0 !== e && (sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''))),
                (sum = divide(sum, new Ctor(n), wpr)),
                (Ctor.precision = pr),
                null == sd ? ((external = !0), round(sum, pr)) : sum
              );
            ((sum = t), (denominator += 2));
          }
        }
        function parseDecimal(x, str) {
          var e, i, len;
          for (
            (e = str.indexOf('.')) > -1 && (str = str.replace('.', '')),
              (i = str.search(/e/i)) > 0
                ? (e < 0 && (e = i), (e += +str.slice(i + 1)), (str = str.substring(0, i)))
                : e < 0 && (e = str.length),
              i = 0;
            48 === str.charCodeAt(i);
          )
            ++i;
          for (len = str.length; 48 === str.charCodeAt(len - 1); ) --len;
          if ((str = str.slice(i, len))) {
            if (
              ((len -= i),
              (e = e - i - 1),
              (x.e = mathfloor(e / 7)),
              (x.d = []),
              (i = (e + 1) % 7),
              e < 0 && (i += 7),
              i < len)
            ) {
              for (i && x.d.push(+str.slice(0, i)), len -= 7; i < len; )
                x.d.push(+str.slice(i, (i += 7)));
              i = 7 - (str = str.slice(i)).length;
            } else i -= len;
            for (; i--; ) str += '0';
            if ((x.d.push(+str), external && (x.e > MAX_E || x.e < -MAX_E)))
              throw Error(exponentOutOfRange + e);
          } else ((x.s = 0), (x.e = 0), (x.d = [0]));
          return x;
        }
        function round(x, sd, rm) {
          var i,
            j,
            k,
            n,
            rd,
            doRound,
            w,
            xdi,
            xd = x.d;
          for (n = 1, k = xd[0]; k >= 10; k /= 10) n++;
          if ((i = sd - n) < 0) ((i += 7), (j = sd), (w = xd[(xdi = 0)]));
          else {
            if ((xdi = Math.ceil((i + 1) / 7)) >= (k = xd.length)) return x;
            for (w = k = xd[xdi], n = 1; k >= 10; k /= 10) n++;
            j = (i %= 7) - 7 + n;
          }
          if (
            (void 0 !== rm &&
              ((rd = ((w / (k = mathpow(10, n - j - 1))) % 10) | 0),
              (doRound = sd < 0 || void 0 !== xd[xdi + 1] || w % k),
              (doRound =
                rm < 4
                  ? (rd || doRound) && (0 == rm || rm == (x.s < 0 ? 3 : 2))
                  : rd > 5 ||
                    (5 == rd &&
                      (4 == rm ||
                        doRound ||
                        (6 == rm &&
                          ((i > 0 ? (j > 0 ? w / mathpow(10, n - j) : 0) : xd[xdi - 1]) % 10) &
                            1) ||
                        rm == (x.s < 0 ? 8 : 7))))),
            sd < 1 || !xd[0])
          )
            return (
              doRound
                ? ((k = getBase10Exponent(x)),
                  (xd.length = 1),
                  (sd = sd - k - 1),
                  (xd[0] = mathpow(10, (7 - (sd % 7)) % 7)),
                  (x.e = mathfloor(-sd / 7) || 0))
                : ((xd.length = 1), (xd[0] = x.e = x.s = 0)),
              x
            );
          if (
            (0 == i
              ? ((xd.length = xdi), (k = 1), xdi--)
              : ((xd.length = xdi + 1),
                (k = mathpow(10, 7 - i)),
                (xd[xdi] = j > 0 ? (((w / mathpow(10, n - j)) % mathpow(10, j)) | 0) * k : 0)),
            doRound)
          )
            for (;;) {
              if (0 == xdi) {
                (xd[0] += k) == BASE && ((xd[0] = 1), ++x.e);
                break;
              }
              if (((xd[xdi] += k), xd[xdi] != BASE)) break;
              ((xd[xdi--] = 0), (k = 1));
            }
          for (i = xd.length; 0 === xd[--i]; ) xd.pop();
          if (external && (x.e > MAX_E || x.e < -MAX_E))
            throw Error(exponentOutOfRange + getBase10Exponent(x));
          return x;
        }
        function subtract(x, y) {
          var d,
            e,
            i,
            j,
            k,
            len,
            xd,
            xe,
            xLTy,
            yd,
            Ctor = x.constructor,
            pr = Ctor.precision;
          if (!x.s || !y.s)
            return (y.s ? (y.s = -y.s) : (y = new Ctor(x)), external ? round(y, pr) : y);
          if (((xd = x.d), (yd = y.d), (e = y.e), (xe = x.e), (xd = xd.slice()), (k = xe - e))) {
            for (
              (xLTy = k < 0)
                ? ((d = xd), (k = -k), (len = yd.length))
                : ((d = yd), (e = xe), (len = xd.length)),
                k > (i = Math.max(Math.ceil(pr / 7), len) + 2) && ((k = i), (d.length = 1)),
                d.reverse(),
                i = k;
              i--;
            )
              d.push(0);
            d.reverse();
          } else {
            for ((xLTy = (i = xd.length) < (len = yd.length)) && (len = i), i = 0; i < len; i++)
              if (xd[i] != yd[i]) {
                xLTy = xd[i] < yd[i];
                break;
              }
            k = 0;
          }
          for (
            xLTy && ((d = xd), (xd = yd), (yd = d), (y.s = -y.s)),
              len = xd.length,
              i = yd.length - len;
            i > 0;
            --i
          )
            xd[len++] = 0;
          for (i = yd.length; i > k; ) {
            if (xd[--i] < yd[i]) {
              for (j = i; j && 0 === xd[--j]; ) xd[j] = BASE - 1;
              (--xd[j], (xd[i] += BASE));
            }
            xd[i] -= yd[i];
          }
          for (; 0 === xd[--len]; ) xd.pop();
          for (; 0 === xd[0]; xd.shift()) --e;
          return xd[0] ? ((y.d = xd), (y.e = e), external ? round(y, pr) : y) : new Ctor(0);
        }
        function toString(x, isExp, sd) {
          var k,
            e = getBase10Exponent(x),
            str = digitsToString(x.d),
            len = str.length;
          return (
            isExp
              ? (sd && (k = sd - len) > 0
                  ? (str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k))
                  : len > 1 && (str = str.charAt(0) + '.' + str.slice(1)),
                (str = str + (e < 0 ? 'e' : 'e+') + e))
              : e < 0
                ? ((str = '0.' + getZeroString(-e - 1) + str),
                  sd && (k = sd - len) > 0 && (str += getZeroString(k)))
                : e >= len
                  ? ((str += getZeroString(e + 1 - len)),
                    sd && (k = sd - e - 1) > 0 && (str = str + '.' + getZeroString(k)))
                  : ((k = e + 1) < len && (str = str.slice(0, k) + '.' + str.slice(k)),
                    sd &&
                      (k = sd - len) > 0 &&
                      (e + 1 === len && (str += '.'), (str += getZeroString(k)))),
            x.s < 0 ? '-' + str : str
          );
        }
        function truncate(arr, len) {
          if (arr.length > len) return ((arr.length = len), !0);
        }
        function config(obj) {
          if (!obj || 'object' != typeof obj) throw Error(decimalError + 'Object expected');
          var i,
            p,
            v,
            ps = [
              'precision',
              1,
              1e9,
              'rounding',
              0,
              8,
              'toExpNeg',
              -1 / 0,
              0,
              'toExpPos',
              0,
              1 / 0,
            ];
          for (i = 0; i < ps.length; i += 3)
            if (void 0 !== (v = obj[(p = ps[i])])) {
              if (!(mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]))
                throw Error(invalidArgument + p + ': ' + v);
              this[p] = v;
            }
          if (void 0 !== (v = obj[(p = 'LN10')])) {
            if (v != Math.LN10) throw Error(invalidArgument + p + ': ' + v);
            this[p] = new this(v);
          }
          return this;
        }
        ((Decimal = (function clone(obj) {
          var i, p, ps;
          function Decimal(value) {
            var x = this;
            if (!(x instanceof Decimal)) return new Decimal(value);
            if (((x.constructor = Decimal), value instanceof Decimal))
              return (
                (x.s = value.s),
                (x.e = value.e),
                void (x.d = (value = value.d) ? value.slice() : value)
              );
            if ('number' == typeof value) {
              if (0 * value != 0) throw Error(invalidArgument + value);
              if (value > 0) x.s = 1;
              else {
                if (!(value < 0)) return ((x.s = 0), (x.e = 0), void (x.d = [0]));
                ((value = -value), (x.s = -1));
              }
              return value === ~~value && value < 1e7
                ? ((x.e = 0), void (x.d = [value]))
                : parseDecimal(x, value.toString());
            }
            if ('string' != typeof value) throw Error(invalidArgument + value);
            if (
              (45 === value.charCodeAt(0) ? ((value = value.slice(1)), (x.s = -1)) : (x.s = 1),
              !isDecimal.test(value))
            )
              throw Error(invalidArgument + value);
            parseDecimal(x, value);
          }
          if (
            ((Decimal.prototype = P),
            (Decimal.ROUND_UP = 0),
            (Decimal.ROUND_DOWN = 1),
            (Decimal.ROUND_CEIL = 2),
            (Decimal.ROUND_FLOOR = 3),
            (Decimal.ROUND_HALF_UP = 4),
            (Decimal.ROUND_HALF_DOWN = 5),
            (Decimal.ROUND_HALF_EVEN = 6),
            (Decimal.ROUND_HALF_CEIL = 7),
            (Decimal.ROUND_HALF_FLOOR = 8),
            (Decimal.clone = clone),
            (Decimal.config = Decimal.set = config),
            void 0 === obj && (obj = {}),
            obj)
          )
            for (
              ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'LN10'], i = 0;
              i < ps.length;
            )
              obj.hasOwnProperty((p = ps[i++])) || (obj[p] = this[p]);
          return (Decimal.config(obj), Decimal);
        })(Decimal)),
          (Decimal.default = Decimal.Decimal = Decimal),
          (ONE = new Decimal(1)),
          void 0 ===
            (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
              return Decimal;
            }.call(exports, __webpack_require__, exports, module)) ||
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      })();
    },
    './node_modules/es-toolkit/compat/get.js'(
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      module.exports = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/object/get.js'
      ).get;
    },
    './node_modules/es-toolkit/compat/isPlainObject.js'(
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      module.exports = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/predicate/isPlainObject.js'
      ).isPlainObject;
    },
    './node_modules/es-toolkit/compat/last.js'(
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      module.exports = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/array/last.js'
      ).last;
    },
    './node_modules/es-toolkit/compat/range.js'(
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      module.exports = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/math/range.js'
      ).range;
    },
    './node_modules/es-toolkit/compat/sortBy.js'(
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      module.exports = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/array/sortBy.js'
      ).sortBy;
    },
    './node_modules/es-toolkit/compat/throttle.js'(
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      module.exports = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/function/throttle.js'
      ).throttle;
    },
    './node_modules/es-toolkit/compat/uniqBy.js'(
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      module.exports = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/array/uniqBy.js'
      ).uniqBy;
    },
    './node_modules/es-toolkit/dist/_internal/isUnsafeProperty.js'(
      __unused_webpack_module,
      exports
    ) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.isUnsafeProperty = function isUnsafeProperty(key) {
          return '__proto__' === key;
        }));
    },
    './node_modules/es-toolkit/dist/array/flatten.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.flatten = function flatten(arr, depth = 1) {
          const result = [],
            flooredDepth = Math.floor(depth),
            recursive = (arr, currentDepth) => {
              for (let i = 0; i < arr.length; i++) {
                const item = arr[i];
                Array.isArray(item) && currentDepth < flooredDepth
                  ? recursive(item, currentDepth + 1)
                  : result.push(item);
              }
            };
          return (recursive(arr, 0), result);
        }));
    },
    './node_modules/es-toolkit/dist/array/last.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.last = function last(arr) {
          return arr[arr.length - 1];
        }));
    },
    './node_modules/es-toolkit/dist/array/uniqBy.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.uniqBy = function uniqBy(arr, mapper) {
          const map = new Map();
          for (let i = 0; i < arr.length; i++) {
            const item = arr[i],
              key = mapper(item);
            map.has(key) || map.set(key, item);
          }
          return Array.from(map.values());
        }));
    },
    './node_modules/es-toolkit/dist/compat/_internal/compareValues.js'(
      __unused_webpack_module,
      exports
    ) {
      'use strict';
      function getPriority(a) {
        return 'symbol' == typeof a ? 1 : null === a ? 2 : void 0 === a ? 3 : a != a ? 4 : 0;
      }
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      exports.compareValues = (a, b, order) => {
        if (a !== b) {
          const aPriority = getPriority(a),
            bPriority = getPriority(b);
          if (aPriority === bPriority && 0 === aPriority) {
            if (a < b) return 'desc' === order ? 1 : -1;
            if (a > b) return 'desc' === order ? -1 : 1;
          }
          return 'desc' === order ? bPriority - aPriority : aPriority - bPriority;
        }
        return 0;
      };
    },
    './node_modules/es-toolkit/dist/compat/_internal/getSymbols.js'(
      __unused_webpack_module,
      exports
    ) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.getSymbols = function getSymbols(object) {
          return Object.getOwnPropertySymbols(object).filter((symbol) =>
            Object.prototype.propertyIsEnumerable.call(object, symbol)
          );
        }));
    },
    './node_modules/es-toolkit/dist/compat/_internal/getTag.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.getTag = function getTag(value) {
          return null == value
            ? void 0 === value
              ? '[object Undefined]'
              : '[object Null]'
            : Object.prototype.toString.call(value);
        }));
    },
    './node_modules/es-toolkit/dist/compat/_internal/isDeepKey.js'(
      __unused_webpack_module,
      exports
    ) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.isDeepKey = function isDeepKey(key) {
          switch (typeof key) {
            case 'number':
            case 'symbol':
              return !1;
            case 'string':
              return key.includes('.') || key.includes('[') || key.includes(']');
          }
        }));
    },
    './node_modules/es-toolkit/dist/compat/_internal/isIndex.js'(__unused_webpack_module, exports) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
      exports.isIndex = function isIndex(value, length = Number.MAX_SAFE_INTEGER) {
        switch (typeof value) {
          case 'number':
            return Number.isInteger(value) && value >= 0 && value < length;
          case 'symbol':
            return !1;
          case 'string':
            return IS_UNSIGNED_INTEGER.test(value);
        }
      };
    },
    './node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isIndex = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/_internal/isIndex.js'
        ),
        isArrayLike = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isArrayLike.js'
        ),
        isObject = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isObject.js'
        ),
        eq = __webpack_require__('./node_modules/es-toolkit/dist/compat/util/eq.js');
      exports.isIterateeCall = function isIterateeCall(value, index, object) {
        return (
          !!isObject.isObject(object) &&
          !!(
            ('number' == typeof index &&
              isArrayLike.isArrayLike(object) &&
              isIndex.isIndex(index) &&
              index < object.length) ||
            ('string' == typeof index && index in object)
          ) &&
          eq.eq(object[index], value)
        );
      };
    },
    './node_modules/es-toolkit/dist/compat/_internal/isKey.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isSymbol = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isSymbol.js'
        ),
        regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        regexIsPlainProp = /^\w*$/;
      exports.isKey = function isKey(value, object) {
        return (
          !Array.isArray(value) &&
          (!(
            'number' != typeof value &&
            'boolean' != typeof value &&
            null != value &&
            !isSymbol.isSymbol(value)
          ) ||
            ('string' == typeof value &&
              (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value))) ||
            (null != object && Object.hasOwn(object, value)))
        );
      };
    },
    './node_modules/es-toolkit/dist/compat/_internal/tags.js'(__unused_webpack_module, exports) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      ((exports.argumentsTag = '[object Arguments]'),
        (exports.arrayBufferTag = '[object ArrayBuffer]'),
        (exports.arrayTag = '[object Array]'),
        (exports.bigInt64ArrayTag = '[object BigInt64Array]'),
        (exports.bigUint64ArrayTag = '[object BigUint64Array]'),
        (exports.booleanTag = '[object Boolean]'),
        (exports.dataViewTag = '[object DataView]'),
        (exports.dateTag = '[object Date]'),
        (exports.errorTag = '[object Error]'),
        (exports.float32ArrayTag = '[object Float32Array]'),
        (exports.float64ArrayTag = '[object Float64Array]'),
        (exports.functionTag = '[object Function]'),
        (exports.int16ArrayTag = '[object Int16Array]'),
        (exports.int32ArrayTag = '[object Int32Array]'),
        (exports.int8ArrayTag = '[object Int8Array]'),
        (exports.mapTag = '[object Map]'),
        (exports.numberTag = '[object Number]'),
        (exports.objectTag = '[object Object]'),
        (exports.regexpTag = '[object RegExp]'),
        (exports.setTag = '[object Set]'),
        (exports.stringTag = '[object String]'),
        (exports.symbolTag = '[object Symbol]'),
        (exports.uint16ArrayTag = '[object Uint16Array]'),
        (exports.uint32ArrayTag = '[object Uint32Array]'),
        (exports.uint8ArrayTag = '[object Uint8Array]'),
        (exports.uint8ClampedArrayTag = '[object Uint8ClampedArray]'));
    },
    './node_modules/es-toolkit/dist/compat/_internal/toArray.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.toArray = function toArray(value) {
          return Array.isArray(value) ? value : Array.from(value);
        }));
    },
    './node_modules/es-toolkit/dist/compat/_internal/toKey.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.toKey = function toKey(value) {
          return 'string' == typeof value || 'symbol' == typeof value
            ? value
            : Object.is(value?.valueOf?.(), -0)
              ? '-0'
              : String(value);
        }));
    },
    './node_modules/es-toolkit/dist/compat/array/last.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const last$1 = __webpack_require__('./node_modules/es-toolkit/dist/array/last.js'),
        toArray = __webpack_require__('./node_modules/es-toolkit/dist/compat/_internal/toArray.js'),
        isArrayLike = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isArrayLike.js'
        );
      exports.last = function last(array) {
        if (isArrayLike.isArrayLike(array)) return last$1.last(toArray.toArray(array));
      };
    },
    './node_modules/es-toolkit/dist/compat/array/orderBy.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const compareValues = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/_internal/compareValues.js'
        ),
        isKey = __webpack_require__('./node_modules/es-toolkit/dist/compat/_internal/isKey.js'),
        toPath = __webpack_require__('./node_modules/es-toolkit/dist/compat/util/toPath.js');
      exports.orderBy = function orderBy(collection, criteria, orders, guard) {
        if (null == collection) return [];
        ((orders = guard ? void 0 : orders),
          Array.isArray(collection) || (collection = Object.values(collection)),
          Array.isArray(criteria) || (criteria = null == criteria ? [null] : [criteria]),
          0 === criteria.length && (criteria = [null]),
          Array.isArray(orders) || (orders = null == orders ? [] : [orders]),
          (orders = orders.map((order) => String(order))));
        const getValueByNestedPath = (object, path) => {
            let target = object;
            for (let i = 0; i < path.length && null != target; ++i) target = target[path[i]];
            return target;
          },
          preparedCriteria = criteria.map(
            (criterion) => (
              Array.isArray(criterion) && 1 === criterion.length && (criterion = criterion[0]),
              null == criterion ||
              'function' == typeof criterion ||
              Array.isArray(criterion) ||
              isKey.isKey(criterion)
                ? criterion
                : { key: criterion, path: toPath.toPath(criterion) }
            )
          );
        return collection
          .map((item) => ({
            original: item,
            criteria: preparedCriteria.map((criterion) =>
              ((criterion, object) =>
                null == object || null == criterion
                  ? object
                  : 'object' == typeof criterion && 'key' in criterion
                    ? Object.hasOwn(object, criterion.key)
                      ? object[criterion.key]
                      : getValueByNestedPath(object, criterion.path)
                    : 'function' == typeof criterion
                      ? criterion(object)
                      : Array.isArray(criterion)
                        ? getValueByNestedPath(object, criterion)
                        : 'object' == typeof object
                          ? object[criterion]
                          : object)(criterion, item)
            ),
          }))
          .slice()
          .sort((a, b) => {
            for (let i = 0; i < preparedCriteria.length; i++) {
              const comparedResult = compareValues.compareValues(
                a.criteria[i],
                b.criteria[i],
                orders[i]
              );
              if (0 !== comparedResult) return comparedResult;
            }
            return 0;
          })
          .map((item) => item.original);
      };
    },
    './node_modules/es-toolkit/dist/compat/array/sortBy.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const orderBy = __webpack_require__('./node_modules/es-toolkit/dist/compat/array/orderBy.js'),
        flatten = __webpack_require__('./node_modules/es-toolkit/dist/array/flatten.js'),
        isIterateeCall = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.js'
        );
      exports.sortBy = function sortBy(collection, ...criteria) {
        const length = criteria.length;
        return (
          length > 1 && isIterateeCall.isIterateeCall(collection, criteria[0], criteria[1])
            ? (criteria = [])
            : length > 2 &&
              isIterateeCall.isIterateeCall(criteria[0], criteria[1], criteria[2]) &&
              (criteria = [criteria[0]]),
          orderBy.orderBy(collection, flatten.flatten(criteria), ['asc'])
        );
      };
    },
    './node_modules/es-toolkit/dist/compat/array/uniqBy.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const uniqBy$1 = __webpack_require__('./node_modules/es-toolkit/dist/array/uniqBy.js'),
        identity = __webpack_require__('./node_modules/es-toolkit/dist/function/identity.js'),
        isArrayLikeObject = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isArrayLikeObject.js'
        ),
        iteratee = __webpack_require__('./node_modules/es-toolkit/dist/compat/util/iteratee.js');
      exports.uniqBy = function uniqBy(array, iteratee$1 = identity.identity) {
        return isArrayLikeObject.isArrayLikeObject(array)
          ? uniqBy$1.uniqBy(Array.from(array), iteratee.iteratee(iteratee$1))
          : [];
      };
    },
    './node_modules/es-toolkit/dist/compat/function/debounce.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const debounce$1 = __webpack_require__('./node_modules/es-toolkit/dist/function/debounce.js');
      exports.debounce = function debounce(func, debounceMs = 0, options = {}) {
        'object' != typeof options && (options = {});
        const { leading = !1, trailing = !0, maxWait } = options,
          edges = Array(2);
        let result;
        (leading && (edges[0] = 'leading'), trailing && (edges[1] = 'trailing'));
        let pendingAt = null;
        const _debounced = debounce$1.debounce(
            function (...args) {
              ((result = func.apply(this, args)), (pendingAt = null));
            },
            debounceMs,
            { edges }
          ),
          debounced = function (...args) {
            return null != maxWait &&
              (null === pendingAt && (pendingAt = Date.now()), Date.now() - pendingAt >= maxWait)
              ? ((result = func.apply(this, args)),
                (pendingAt = Date.now()),
                _debounced.cancel(),
                _debounced.schedule(),
                result)
              : (_debounced.apply(this, args), result);
          };
        return (
          (debounced.cancel = _debounced.cancel),
          (debounced.flush = () => (_debounced.flush(), result)),
          debounced
        );
      };
    },
    './node_modules/es-toolkit/dist/compat/function/throttle.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const debounce = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/function/debounce.js'
      );
      exports.throttle = function throttle(func, throttleMs = 0, options = {}) {
        const { leading = !0, trailing = !0 } = options;
        return debounce.debounce(func, throttleMs, { leading, maxWait: throttleMs, trailing });
      };
    },
    './node_modules/es-toolkit/dist/compat/math/range.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isIterateeCall = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.js'
        ),
        toFinite = __webpack_require__('./node_modules/es-toolkit/dist/compat/util/toFinite.js');
      exports.range = function range(start, end, step) {
        (step &&
          'number' != typeof step &&
          isIterateeCall.isIterateeCall(start, end, step) &&
          (end = step = void 0),
          (start = toFinite.toFinite(start)),
          void 0 === end ? ((end = start), (start = 0)) : (end = toFinite.toFinite(end)),
          (step = void 0 === step ? (start < end ? 1 : -1) : toFinite.toFinite(step)));
        const length = Math.max(Math.ceil((end - start) / (step || 1)), 0),
          result = new Array(length);
        for (let index = 0; index < length; index++) ((result[index] = start), (start += step));
        return result;
      };
    },
    './node_modules/es-toolkit/dist/compat/object/cloneDeep.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const cloneDeepWith = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/object/cloneDeepWith.js'
      );
      exports.cloneDeep = function cloneDeep(obj) {
        return cloneDeepWith.cloneDeepWith(obj);
      };
    },
    './node_modules/es-toolkit/dist/compat/object/cloneDeepWith.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const cloneDeepWith$1 = __webpack_require__(
          './node_modules/es-toolkit/dist/object/cloneDeepWith.js'
        ),
        tags = __webpack_require__('./node_modules/es-toolkit/dist/compat/_internal/tags.js');
      exports.cloneDeepWith = function cloneDeepWith(obj, customizer) {
        return cloneDeepWith$1.cloneDeepWith(obj, (value, key, object, stack) => {
          const cloned = customizer?.(value, key, object, stack);
          if (void 0 !== cloned) return cloned;
          if ('object' == typeof obj)
            switch (Object.prototype.toString.call(obj)) {
              case tags.numberTag:
              case tags.stringTag:
              case tags.booleanTag: {
                const result = new obj.constructor(obj?.valueOf());
                return (cloneDeepWith$1.copyProperties(result, obj), result);
              }
              case tags.argumentsTag: {
                const result = {};
                return (
                  cloneDeepWith$1.copyProperties(result, obj),
                  (result.length = obj.length),
                  (result[Symbol.iterator] = obj[Symbol.iterator]),
                  result
                );
              }
              default:
                return;
            }
        });
      };
    },
    './node_modules/es-toolkit/dist/compat/object/get.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isUnsafeProperty = __webpack_require__(
          './node_modules/es-toolkit/dist/_internal/isUnsafeProperty.js'
        ),
        isDeepKey = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/_internal/isDeepKey.js'
        ),
        toKey = __webpack_require__('./node_modules/es-toolkit/dist/compat/_internal/toKey.js'),
        toPath = __webpack_require__('./node_modules/es-toolkit/dist/compat/util/toPath.js');
      exports.get = function get(object, path, defaultValue) {
        if (null == object) return defaultValue;
        switch (typeof path) {
          case 'string': {
            if (isUnsafeProperty.isUnsafeProperty(path)) return defaultValue;
            const result = object[path];
            return void 0 === result
              ? isDeepKey.isDeepKey(path)
                ? get(object, toPath.toPath(path), defaultValue)
                : defaultValue
              : result;
          }
          case 'number':
          case 'symbol': {
            'number' == typeof path && (path = toKey.toKey(path));
            const result = object[path];
            return void 0 === result ? defaultValue : result;
          }
          default: {
            if (Array.isArray(path))
              return (function getWithPath(object, path, defaultValue) {
                if (0 === path.length) return defaultValue;
                let current = object;
                for (let index = 0; index < path.length; index++) {
                  if (null == current) return defaultValue;
                  if (isUnsafeProperty.isUnsafeProperty(path[index])) return defaultValue;
                  current = current[path[index]];
                }
                if (void 0 === current) return defaultValue;
                return current;
              })(object, path, defaultValue);
            if (
              ((path = Object.is(path?.valueOf(), -0) ? '-0' : String(path)),
              isUnsafeProperty.isUnsafeProperty(path))
            )
              return defaultValue;
            const result = object[path];
            return void 0 === result ? defaultValue : result;
          }
        }
      };
    },
    './node_modules/es-toolkit/dist/compat/object/has.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isDeepKey = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/_internal/isDeepKey.js'
        ),
        isIndex = __webpack_require__('./node_modules/es-toolkit/dist/compat/_internal/isIndex.js'),
        isArguments = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isArguments.js'
        ),
        toPath = __webpack_require__('./node_modules/es-toolkit/dist/compat/util/toPath.js');
      exports.has = function has(object, path) {
        let resolvedPath;
        if (
          ((resolvedPath = Array.isArray(path)
            ? path
            : 'string' == typeof path && isDeepKey.isDeepKey(path) && null == object?.[path]
              ? toPath.toPath(path)
              : [path]),
          0 === resolvedPath.length)
        )
          return !1;
        let current = object;
        for (let i = 0; i < resolvedPath.length; i++) {
          const key = resolvedPath[i];
          if (null == current || !Object.hasOwn(current, key)) {
            if (
              !(
                (Array.isArray(current) || isArguments.isArguments(current)) &&
                isIndex.isIndex(key) &&
                key < current.length
              )
            )
              return !1;
          }
          current = current[key];
        }
        return !0;
      };
    },
    './node_modules/es-toolkit/dist/compat/object/property.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const get = __webpack_require__('./node_modules/es-toolkit/dist/compat/object/get.js');
      exports.property = function property(path) {
        return function (object) {
          return get.get(object, path);
        };
      };
    },
    './node_modules/es-toolkit/dist/compat/predicate/isArguments.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const getTag = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/_internal/getTag.js'
      );
      exports.isArguments = function isArguments(value) {
        return (
          null !== value &&
          'object' == typeof value &&
          '[object Arguments]' === getTag.getTag(value)
        );
      };
    },
    './node_modules/es-toolkit/dist/compat/predicate/isArrayLike.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isLength = __webpack_require__('./node_modules/es-toolkit/dist/predicate/isLength.js');
      exports.isArrayLike = function isArrayLike(value) {
        return null != value && 'function' != typeof value && isLength.isLength(value.length);
      };
    },
    './node_modules/es-toolkit/dist/compat/predicate/isArrayLikeObject.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isArrayLike = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isArrayLike.js'
        ),
        isObjectLike = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isObjectLike.js'
        );
      exports.isArrayLikeObject = function isArrayLikeObject(value) {
        return isObjectLike.isObjectLike(value) && isArrayLike.isArrayLike(value);
      };
    },
    './node_modules/es-toolkit/dist/compat/predicate/isMatch.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isMatchWith = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/predicate/isMatchWith.js'
      );
      exports.isMatch = function isMatch(target, source) {
        return isMatchWith.isMatchWith(target, source, () => {});
      };
    },
    './node_modules/es-toolkit/dist/compat/predicate/isMatchWith.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isObject = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isObject.js'
        ),
        isPrimitive = __webpack_require__(
          './node_modules/es-toolkit/dist/predicate/isPrimitive.js'
        ),
        eq = __webpack_require__('./node_modules/es-toolkit/dist/compat/util/eq.js');
      function isMatchWithInternal(target, source, compare, stack) {
        if (source === target) return !0;
        switch (typeof source) {
          case 'object':
            return (function isObjectMatch(target, source, compare, stack) {
              if (null == source) return !0;
              if (Array.isArray(source)) return isArrayMatch(target, source, compare, stack);
              if (source instanceof Map)
                return (function isMapMatch(target, source, compare, stack) {
                  if (0 === source.size) return !0;
                  if (!(target instanceof Map)) return !1;
                  for (const [key, sourceValue] of source.entries()) {
                    if (!1 === compare(target.get(key), sourceValue, key, target, source, stack))
                      return !1;
                  }
                  return !0;
                })(target, source, compare, stack);
              if (source instanceof Set) return isSetMatch(target, source, compare, stack);
              const keys = Object.keys(source);
              if (null == target || isPrimitive.isPrimitive(target)) return 0 === keys.length;
              if (0 === keys.length) return !0;
              if (stack?.has(source)) return stack.get(source) === target;
              stack?.set(source, target);
              try {
                for (let i = 0; i < keys.length; i++) {
                  const key = keys[i];
                  if (!isPrimitive.isPrimitive(target) && !(key in target)) return !1;
                  if (void 0 === source[key] && void 0 !== target[key]) return !1;
                  if (null === source[key] && null !== target[key]) return !1;
                  if (!compare(target[key], source[key], key, target, source, stack)) return !1;
                }
                return !0;
              } finally {
                stack?.delete(source);
              }
            })(target, source, compare, stack);
          case 'function':
            return Object.keys(source).length > 0
              ? isMatchWithInternal(target, { ...source }, compare, stack)
              : eq.eq(target, source);
          default:
            return isObject.isObject(target)
              ? 'string' != typeof source || '' === source
              : eq.eq(target, source);
        }
      }
      function isArrayMatch(target, source, compare, stack) {
        if (0 === source.length) return !0;
        if (!Array.isArray(target)) return !1;
        const countedIndex = new Set();
        for (let i = 0; i < source.length; i++) {
          const sourceItem = source[i];
          let found = !1;
          for (let j = 0; j < target.length; j++) {
            if (countedIndex.has(j)) continue;
            let matches = !1;
            if (
              (compare(target[j], sourceItem, i, target, source, stack) && (matches = !0), matches)
            ) {
              (countedIndex.add(j), (found = !0));
              break;
            }
          }
          if (!found) return !1;
        }
        return !0;
      }
      function isSetMatch(target, source, compare, stack) {
        return (
          0 === source.size ||
          (target instanceof Set && isArrayMatch([...target], [...source], compare, stack))
        );
      }
      ((exports.isMatchWith = function isMatchWith(target, source, compare) {
        return 'function' != typeof compare
          ? isMatchWith(target, source, () => {})
          : isMatchWithInternal(
              target,
              source,
              function doesMatch(objValue, srcValue, key, object, source, stack) {
                const isEqual = compare(objValue, srcValue, key, object, source, stack);
                return void 0 !== isEqual
                  ? Boolean(isEqual)
                  : isMatchWithInternal(objValue, srcValue, doesMatch, stack);
              },
              new Map()
            );
      }),
        (exports.isSetMatch = isSetMatch));
    },
    './node_modules/es-toolkit/dist/compat/predicate/isObject.js'(
      __unused_webpack_module,
      exports
    ) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.isObject = function isObject(value) {
          return null !== value && ('object' == typeof value || 'function' == typeof value);
        }));
    },
    './node_modules/es-toolkit/dist/compat/predicate/isObjectLike.js'(
      __unused_webpack_module,
      exports
    ) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.isObjectLike = function isObjectLike(value) {
          return 'object' == typeof value && null !== value;
        }));
    },
    './node_modules/es-toolkit/dist/compat/predicate/isPlainObject.js'(
      __unused_webpack_module,
      exports
    ) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.isPlainObject = function isPlainObject(object) {
          if ('object' != typeof object) return !1;
          if (null == object) return !1;
          if (null === Object.getPrototypeOf(object)) return !0;
          if ('[object Object]' !== Object.prototype.toString.call(object)) {
            const tag = object[Symbol.toStringTag];
            if (null == tag) return !1;
            return (
              !!Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable &&
              object.toString() === `[object ${tag}]`
            );
          }
          let proto = object;
          for (; null !== Object.getPrototypeOf(proto); ) proto = Object.getPrototypeOf(proto);
          return Object.getPrototypeOf(object) === proto;
        }));
    },
    './node_modules/es-toolkit/dist/compat/predicate/isSymbol.js'(
      __unused_webpack_module,
      exports
    ) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.isSymbol = function isSymbol(value) {
          return 'symbol' == typeof value || value instanceof Symbol;
        }));
    },
    './node_modules/es-toolkit/dist/compat/predicate/matches.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isMatch = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isMatch.js'
        ),
        cloneDeep = __webpack_require__('./node_modules/es-toolkit/dist/object/cloneDeep.js');
      exports.matches = function matches(source) {
        return (
          (source = cloneDeep.cloneDeep(source)),
          (target) => isMatch.isMatch(target, source)
        );
      };
    },
    './node_modules/es-toolkit/dist/compat/predicate/matchesProperty.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isMatch = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/isMatch.js'
        ),
        toKey = __webpack_require__('./node_modules/es-toolkit/dist/compat/_internal/toKey.js'),
        cloneDeep = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/object/cloneDeep.js'
        ),
        get = __webpack_require__('./node_modules/es-toolkit/dist/compat/object/get.js'),
        has = __webpack_require__('./node_modules/es-toolkit/dist/compat/object/has.js');
      exports.matchesProperty = function matchesProperty(property, source) {
        switch (typeof property) {
          case 'object':
            Object.is(property?.valueOf(), -0) && (property = '-0');
            break;
          case 'number':
            property = toKey.toKey(property);
        }
        return (
          (source = cloneDeep.cloneDeep(source)),
          function (target) {
            const result = get.get(target, property);
            return void 0 === result
              ? has.has(target, property)
              : void 0 === source
                ? void 0 === result
                : isMatch.isMatch(result, source);
          }
        );
      };
    },
    './node_modules/es-toolkit/dist/compat/util/eq.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.eq = function eq(value, other) {
          return value === other || (Number.isNaN(value) && Number.isNaN(other));
        }));
    },
    './node_modules/es-toolkit/dist/compat/util/iteratee.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const identity = __webpack_require__('./node_modules/es-toolkit/dist/function/identity.js'),
        property = __webpack_require__('./node_modules/es-toolkit/dist/compat/object/property.js'),
        matches = __webpack_require__('./node_modules/es-toolkit/dist/compat/predicate/matches.js'),
        matchesProperty = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/predicate/matchesProperty.js'
        );
      exports.iteratee = function iteratee(value) {
        if (null == value) return identity.identity;
        switch (typeof value) {
          case 'function':
            return value;
          case 'object':
            return Array.isArray(value) && 2 === value.length
              ? matchesProperty.matchesProperty(value[0], value[1])
              : matches.matches(value);
          case 'string':
          case 'symbol':
          case 'number':
            return property.property(value);
        }
      };
    },
    './node_modules/es-toolkit/dist/compat/util/toFinite.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const toNumber = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/util/toNumber.js'
      );
      exports.toFinite = function toFinite(value) {
        if (!value) return 0 === value ? value : 0;
        if ((value = toNumber.toNumber(value)) === 1 / 0 || value === -1 / 0) {
          return (value < 0 ? -1 : 1) * Number.MAX_VALUE;
        }
        return value == value ? value : 0;
      };
    },
    './node_modules/es-toolkit/dist/compat/util/toNumber.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const isSymbol = __webpack_require__(
        './node_modules/es-toolkit/dist/compat/predicate/isSymbol.js'
      );
      exports.toNumber = function toNumber(value) {
        return isSymbol.isSymbol(value) ? NaN : Number(value);
      };
    },
    './node_modules/es-toolkit/dist/compat/util/toPath.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const toString = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/util/toString.js'
        ),
        toKey = __webpack_require__('./node_modules/es-toolkit/dist/compat/_internal/toKey.js');
      exports.toPath = function toPath(deepKey) {
        if (Array.isArray(deepKey)) return deepKey.map(toKey.toKey);
        if ('symbol' == typeof deepKey) return [deepKey];
        const result = [],
          length = (deepKey = toString.toString(deepKey)).length;
        if (0 === length) return result;
        let index = 0,
          key = '',
          quoteChar = '',
          bracket = !1;
        for (46 === deepKey.charCodeAt(0) && (result.push(''), index++); index < length; ) {
          const char = deepKey[index];
          (quoteChar
            ? '\\' === char && index + 1 < length
              ? (index++, (key += deepKey[index]))
              : char === quoteChar
                ? (quoteChar = '')
                : (key += char)
            : bracket
              ? '"' === char || "'" === char
                ? (quoteChar = char)
                : ']' === char
                  ? ((bracket = !1), result.push(key), (key = ''))
                  : (key += char)
              : '[' === char
                ? ((bracket = !0), key && (result.push(key), (key = '')))
                : '.' === char
                  ? key && (result.push(key), (key = ''))
                  : (key += char),
            index++);
        }
        return (key && result.push(key), result);
      };
    },
    './node_modules/es-toolkit/dist/compat/util/toString.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.toString = function toString(value) {
          if (null == value) return '';
          if ('string' == typeof value) return value;
          if (Array.isArray(value)) return value.map(toString).join(',');
          const result = String(value);
          return '0' === result && Object.is(Number(value), -0) ? '-0' : result;
        }));
    },
    './node_modules/es-toolkit/dist/function/debounce.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.debounce = function debounce(func, debounceMs, { signal, edges } = {}) {
          let pendingThis,
            pendingArgs = null;
          const leading = null != edges && edges.includes('leading'),
            trailing = null == edges || edges.includes('trailing'),
            invoke = () => {
              null !== pendingArgs &&
                (func.apply(pendingThis, pendingArgs),
                (pendingThis = void 0),
                (pendingArgs = null));
            };
          let timeoutId = null;
          const schedule = () => {
              (null != timeoutId && clearTimeout(timeoutId),
                (timeoutId = setTimeout(() => {
                  ((timeoutId = null), trailing && invoke(), cancel());
                }, debounceMs)));
            },
            cancel = () => {
              (null !== timeoutId && (clearTimeout(timeoutId), (timeoutId = null)),
                (pendingThis = void 0),
                (pendingArgs = null));
            },
            debounced = function (...args) {
              if (signal?.aborted) return;
              ((pendingThis = this), (pendingArgs = args));
              const isFirstCall = null == timeoutId;
              (schedule(), leading && isFirstCall && invoke());
            };
          return (
            (debounced.schedule = schedule),
            (debounced.cancel = cancel),
            (debounced.flush = () => {
              invoke();
            }),
            signal?.addEventListener('abort', cancel, { once: !0 }),
            debounced
          );
        }));
    },
    './node_modules/es-toolkit/dist/function/identity.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.identity = function identity(x) {
          return x;
        }));
    },
    './node_modules/es-toolkit/dist/object/cloneDeep.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const cloneDeepWith = __webpack_require__(
        './node_modules/es-toolkit/dist/object/cloneDeepWith.js'
      );
      exports.cloneDeep = function cloneDeep(obj) {
        return cloneDeepWith.cloneDeepWithImpl(obj, void 0, obj, new Map(), void 0);
      };
    },
    './node_modules/es-toolkit/dist/object/cloneDeepWith.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      var Buffer = __webpack_require__('./node_modules/buffer/index.js').Buffer;
      Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      const getSymbols = __webpack_require__(
          './node_modules/es-toolkit/dist/compat/_internal/getSymbols.js'
        ),
        getTag = __webpack_require__('./node_modules/es-toolkit/dist/compat/_internal/getTag.js'),
        tags = __webpack_require__('./node_modules/es-toolkit/dist/compat/_internal/tags.js'),
        isPrimitive = __webpack_require__(
          './node_modules/es-toolkit/dist/predicate/isPrimitive.js'
        ),
        isTypedArray = __webpack_require__(
          './node_modules/es-toolkit/dist/predicate/isTypedArray.js'
        );
      function cloneDeepWithImpl(
        valueToClone,
        keyToClone,
        objectToClone,
        stack = new Map(),
        cloneValue = void 0
      ) {
        const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
        if (void 0 !== cloned) return cloned;
        if (isPrimitive.isPrimitive(valueToClone)) return valueToClone;
        if (stack.has(valueToClone)) return stack.get(valueToClone);
        if (Array.isArray(valueToClone)) {
          const result = new Array(valueToClone.length);
          stack.set(valueToClone, result);
          for (let i = 0; i < valueToClone.length; i++)
            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
          return (
            Object.hasOwn(valueToClone, 'index') && (result.index = valueToClone.index),
            Object.hasOwn(valueToClone, 'input') && (result.input = valueToClone.input),
            result
          );
        }
        if (valueToClone instanceof Date) return new Date(valueToClone.getTime());
        if (valueToClone instanceof RegExp) {
          const result = new RegExp(valueToClone.source, valueToClone.flags);
          return ((result.lastIndex = valueToClone.lastIndex), result);
        }
        if (valueToClone instanceof Map) {
          const result = new Map();
          stack.set(valueToClone, result);
          for (const [key, value] of valueToClone)
            result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
          return result;
        }
        if (valueToClone instanceof Set) {
          const result = new Set();
          stack.set(valueToClone, result);
          for (const value of valueToClone)
            result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
          return result;
        }
        if (void 0 !== Buffer && Buffer.isBuffer(valueToClone)) return valueToClone.subarray();
        if (isTypedArray.isTypedArray(valueToClone)) {
          const result = new (Object.getPrototypeOf(valueToClone).constructor)(valueToClone.length);
          stack.set(valueToClone, result);
          for (let i = 0; i < valueToClone.length; i++)
            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
          return result;
        }
        if (
          valueToClone instanceof ArrayBuffer ||
          ('undefined' != typeof SharedArrayBuffer && valueToClone instanceof SharedArrayBuffer)
        )
          return valueToClone.slice(0);
        if (valueToClone instanceof DataView) {
          const result = new DataView(
            valueToClone.buffer.slice(0),
            valueToClone.byteOffset,
            valueToClone.byteLength
          );
          return (
            stack.set(valueToClone, result),
            copyProperties(result, valueToClone, objectToClone, stack, cloneValue),
            result
          );
        }
        if ('undefined' != typeof File && valueToClone instanceof File) {
          const result = new File([valueToClone], valueToClone.name, { type: valueToClone.type });
          return (
            stack.set(valueToClone, result),
            copyProperties(result, valueToClone, objectToClone, stack, cloneValue),
            result
          );
        }
        if ('undefined' != typeof Blob && valueToClone instanceof Blob) {
          const result = new Blob([valueToClone], { type: valueToClone.type });
          return (
            stack.set(valueToClone, result),
            copyProperties(result, valueToClone, objectToClone, stack, cloneValue),
            result
          );
        }
        if (valueToClone instanceof Error) {
          const result = new valueToClone.constructor();
          return (
            stack.set(valueToClone, result),
            (result.message = valueToClone.message),
            (result.name = valueToClone.name),
            (result.stack = valueToClone.stack),
            (result.cause = valueToClone.cause),
            copyProperties(result, valueToClone, objectToClone, stack, cloneValue),
            result
          );
        }
        if (valueToClone instanceof Boolean) {
          const result = new Boolean(valueToClone.valueOf());
          return (
            stack.set(valueToClone, result),
            copyProperties(result, valueToClone, objectToClone, stack, cloneValue),
            result
          );
        }
        if (valueToClone instanceof Number) {
          const result = new Number(valueToClone.valueOf());
          return (
            stack.set(valueToClone, result),
            copyProperties(result, valueToClone, objectToClone, stack, cloneValue),
            result
          );
        }
        if (valueToClone instanceof String) {
          const result = new String(valueToClone.valueOf());
          return (
            stack.set(valueToClone, result),
            copyProperties(result, valueToClone, objectToClone, stack, cloneValue),
            result
          );
        }
        if (
          'object' == typeof valueToClone &&
          (function isCloneableObject(object) {
            switch (getTag.getTag(object)) {
              case tags.argumentsTag:
              case tags.arrayTag:
              case tags.arrayBufferTag:
              case tags.dataViewTag:
              case tags.booleanTag:
              case tags.dateTag:
              case tags.float32ArrayTag:
              case tags.float64ArrayTag:
              case tags.int8ArrayTag:
              case tags.int16ArrayTag:
              case tags.int32ArrayTag:
              case tags.mapTag:
              case tags.numberTag:
              case tags.objectTag:
              case tags.regexpTag:
              case tags.setTag:
              case tags.stringTag:
              case tags.symbolTag:
              case tags.uint8ArrayTag:
              case tags.uint8ClampedArrayTag:
              case tags.uint16ArrayTag:
              case tags.uint32ArrayTag:
                return !0;
              default:
                return !1;
            }
          })(valueToClone)
        ) {
          const result = Object.create(Object.getPrototypeOf(valueToClone));
          return (
            stack.set(valueToClone, result),
            copyProperties(result, valueToClone, objectToClone, stack, cloneValue),
            result
          );
        }
        return valueToClone;
      }
      function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
        const keys = [...Object.keys(source), ...getSymbols.getSymbols(source)];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i],
            descriptor = Object.getOwnPropertyDescriptor(target, key);
          (null == descriptor || descriptor.writable) &&
            (target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue));
        }
      }
      ((exports.cloneDeepWith = function cloneDeepWith(obj, cloneValue) {
        return cloneDeepWithImpl(obj, void 0, obj, new Map(), cloneValue);
      }),
        (exports.cloneDeepWithImpl = cloneDeepWithImpl),
        (exports.copyProperties = copyProperties));
    },
    './node_modules/es-toolkit/dist/predicate/isLength.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.isLength = function isLength(value) {
          return Number.isSafeInteger(value) && value >= 0;
        }));
    },
    './node_modules/es-toolkit/dist/predicate/isPrimitive.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.isPrimitive = function isPrimitive(value) {
          return null == value || ('object' != typeof value && 'function' != typeof value);
        }));
    },
    './node_modules/es-toolkit/dist/predicate/isTypedArray.js'(__unused_webpack_module, exports) {
      'use strict';
      (Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),
        (exports.isTypedArray = function isTypedArray(x) {
          return ArrayBuffer.isView(x) && !(x instanceof DataView);
        }));
    },
    './node_modules/eventemitter3/index.js'(module) {
      'use strict';
      var has = Object.prototype.hasOwnProperty,
        prefix = '~';
      function Events() {}
      function EE(fn, context, once) {
        ((this.fn = fn), (this.context = context), (this.once = once || !1));
      }
      function addListener(emitter, event, fn, context, once) {
        if ('function' != typeof fn) throw new TypeError('The listener must be a function');
        var listener = new EE(fn, context || emitter, once),
          evt = prefix ? prefix + event : event;
        return (
          emitter._events[evt]
            ? emitter._events[evt].fn
              ? (emitter._events[evt] = [emitter._events[evt], listener])
              : emitter._events[evt].push(listener)
            : ((emitter._events[evt] = listener), emitter._eventsCount++),
          emitter
        );
      }
      function clearEvent(emitter, evt) {
        0 === --emitter._eventsCount
          ? (emitter._events = new Events())
          : delete emitter._events[evt];
      }
      function EventEmitter() {
        ((this._events = new Events()), (this._eventsCount = 0));
      }
      (Object.create &&
        ((Events.prototype = Object.create(null)), new Events().__proto__ || (prefix = !1)),
        (EventEmitter.prototype.eventNames = function eventNames() {
          var events,
            name,
            names = [];
          if (0 === this._eventsCount) return names;
          for (name in (events = this._events))
            has.call(events, name) && names.push(prefix ? name.slice(1) : name);
          return Object.getOwnPropertySymbols
            ? names.concat(Object.getOwnPropertySymbols(events))
            : names;
        }),
        (EventEmitter.prototype.listeners = function listeners(event) {
          var evt = prefix ? prefix + event : event,
            handlers = this._events[evt];
          if (!handlers) return [];
          if (handlers.fn) return [handlers.fn];
          for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)
            ee[i] = handlers[i].fn;
          return ee;
        }),
        (EventEmitter.prototype.listenerCount = function listenerCount(event) {
          var evt = prefix ? prefix + event : event,
            listeners = this._events[evt];
          return listeners ? (listeners.fn ? 1 : listeners.length) : 0;
        }),
        (EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt]) return !1;
          var args,
            i,
            listeners = this._events[evt],
            len = arguments.length;
          if (listeners.fn) {
            switch ((listeners.once && this.removeListener(event, listeners.fn, void 0, !0), len)) {
              case 1:
                return (listeners.fn.call(listeners.context), !0);
              case 2:
                return (listeners.fn.call(listeners.context, a1), !0);
              case 3:
                return (listeners.fn.call(listeners.context, a1, a2), !0);
              case 4:
                return (listeners.fn.call(listeners.context, a1, a2, a3), !0);
              case 5:
                return (listeners.fn.call(listeners.context, a1, a2, a3, a4), !0);
              case 6:
                return (listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), !0);
            }
            for (i = 1, args = new Array(len - 1); i < len; i++) args[i - 1] = arguments[i];
            listeners.fn.apply(listeners.context, args);
          } else {
            var j,
              length = listeners.length;
            for (i = 0; i < length; i++)
              switch (
                (listeners[i].once && this.removeListener(event, listeners[i].fn, void 0, !0), len)
              ) {
                case 1:
                  listeners[i].fn.call(listeners[i].context);
                  break;
                case 2:
                  listeners[i].fn.call(listeners[i].context, a1);
                  break;
                case 3:
                  listeners[i].fn.call(listeners[i].context, a1, a2);
                  break;
                case 4:
                  listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                  break;
                default:
                  if (!args)
                    for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j];
                  listeners[i].fn.apply(listeners[i].context, args);
              }
          }
          return !0;
        }),
        (EventEmitter.prototype.on = function on(event, fn, context) {
          return addListener(this, event, fn, context, !1);
        }),
        (EventEmitter.prototype.once = function once(event, fn, context) {
          return addListener(this, event, fn, context, !0);
        }),
        (EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt]) return this;
          if (!fn) return (clearEvent(this, evt), this);
          var listeners = this._events[evt];
          if (listeners.fn)
            listeners.fn !== fn ||
              (once && !listeners.once) ||
              (context && listeners.context !== context) ||
              clearEvent(this, evt);
          else {
            for (var i = 0, events = [], length = listeners.length; i < length; i++)
              (listeners[i].fn !== fn ||
                (once && !listeners[i].once) ||
                (context && listeners[i].context !== context)) &&
                events.push(listeners[i]);
            events.length
              ? (this._events[evt] = 1 === events.length ? events[0] : events)
              : clearEvent(this, evt);
          }
          return this;
        }),
        (EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
          var evt;
          return (
            event
              ? ((evt = prefix ? prefix + event : event),
                this._events[evt] && clearEvent(this, evt))
              : ((this._events = new Events()), (this._eventsCount = 0)),
            this
          );
        }),
        (EventEmitter.prototype.off = EventEmitter.prototype.removeListener),
        (EventEmitter.prototype.addListener = EventEmitter.prototype.on),
        (EventEmitter.prefixed = prefix),
        (EventEmitter.EventEmitter = EventEmitter),
        (module.exports = EventEmitter));
    },
    './node_modules/immer/dist/immer.mjs'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { h4: () => castDraft });
      var NOTHING = Symbol.for('immer-nothing'),
        DRAFTABLE = Symbol.for('immer-draftable'),
        DRAFT_STATE = Symbol.for('immer-state');
      function die(error, ...args) {
        throw new Error(
          `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
        );
      }
      var getPrototypeOf = Object.getPrototypeOf;
      function isDraft(value) {
        return !!value && !!value[DRAFT_STATE];
      }
      function isDraftable(value) {
        return (
          !!value &&
          (isPlainObject(value) ||
            Array.isArray(value) ||
            !!value[DRAFTABLE] ||
            !!value.constructor?.[DRAFTABLE] ||
            isMap(value) ||
            isSet(value))
        );
      }
      var objectCtorString = Object.prototype.constructor.toString(),
        cachedCtorStrings = new WeakMap();
      function isPlainObject(value) {
        if (!value || 'object' != typeof value) return !1;
        const proto = Object.getPrototypeOf(value);
        if (null === proto || proto === Object.prototype) return !0;
        const Ctor = Object.hasOwnProperty.call(proto, 'constructor') && proto.constructor;
        if (Ctor === Object) return !0;
        if ('function' != typeof Ctor) return !1;
        let ctorString = cachedCtorStrings.get(Ctor);
        return (
          void 0 === ctorString &&
            ((ctorString = Function.toString.call(Ctor)), cachedCtorStrings.set(Ctor, ctorString)),
          ctorString === objectCtorString
        );
      }
      function each(obj, iter, strict = !0) {
        if (0 === getArchtype(obj)) {
          (strict ? Reflect.ownKeys(obj) : Object.keys(obj)).forEach((key) => {
            iter(key, obj[key], obj);
          });
        } else obj.forEach((entry, index) => iter(index, entry, obj));
      }
      function getArchtype(thing) {
        const state = thing[DRAFT_STATE];
        return state
          ? state.type_
          : Array.isArray(thing)
            ? 1
            : isMap(thing)
              ? 2
              : isSet(thing)
                ? 3
                : 0;
      }
      function has(thing, prop) {
        return 2 === getArchtype(thing)
          ? thing.has(prop)
          : Object.prototype.hasOwnProperty.call(thing, prop);
      }
      function set(thing, propOrOldValue, value) {
        const t = getArchtype(thing);
        2 === t
          ? thing.set(propOrOldValue, value)
          : 3 === t
            ? thing.add(value)
            : (thing[propOrOldValue] = value);
      }
      function isMap(target) {
        return target instanceof Map;
      }
      function isSet(target) {
        return target instanceof Set;
      }
      function latest(state) {
        return state.copy_ || state.base_;
      }
      function shallowCopy(base, strict) {
        if (isMap(base)) return new Map(base);
        if (isSet(base)) return new Set(base);
        if (Array.isArray(base)) return Array.prototype.slice.call(base);
        const isPlain = isPlainObject(base);
        if (!0 === strict || ('class_only' === strict && !isPlain)) {
          const descriptors = Object.getOwnPropertyDescriptors(base);
          delete descriptors[DRAFT_STATE];
          let keys = Reflect.ownKeys(descriptors);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i],
              desc = descriptors[key];
            (!1 === desc.writable && ((desc.writable = !0), (desc.configurable = !0)),
              (desc.get || desc.set) &&
                (descriptors[key] = {
                  configurable: !0,
                  writable: !0,
                  enumerable: desc.enumerable,
                  value: base[key],
                }));
          }
          return Object.create(getPrototypeOf(base), descriptors);
        }
        {
          const proto = getPrototypeOf(base);
          if (null !== proto && isPlain) return { ...base };
          const obj = Object.create(proto);
          return Object.assign(obj, base);
        }
      }
      function freeze(obj, deep = !1) {
        return (
          isFrozen(obj) ||
            isDraft(obj) ||
            !isDraftable(obj) ||
            (getArchtype(obj) > 1 &&
              Object.defineProperties(obj, {
                set: dontMutateMethodOverride,
                add: dontMutateMethodOverride,
                clear: dontMutateMethodOverride,
                delete: dontMutateMethodOverride,
              }),
            Object.freeze(obj),
            deep && Object.values(obj).forEach((value) => freeze(value, !0))),
          obj
        );
      }
      var dontMutateMethodOverride = {
        value: function dontMutateFrozenCollections() {
          die(2);
        },
      };
      function isFrozen(obj) {
        return null === obj || 'object' != typeof obj || Object.isFrozen(obj);
      }
      var currentScope,
        plugins = {};
      function getPlugin(pluginKey) {
        const plugin = plugins[pluginKey];
        return (plugin || die(0), plugin);
      }
      function getCurrentScope() {
        return currentScope;
      }
      function usePatchesInScope(scope, patchListener) {
        patchListener &&
          (getPlugin('Patches'),
          (scope.patches_ = []),
          (scope.inversePatches_ = []),
          (scope.patchListener_ = patchListener));
      }
      function revokeScope(scope) {
        (leaveScope(scope), scope.drafts_.forEach(revokeDraft), (scope.drafts_ = null));
      }
      function leaveScope(scope) {
        scope === currentScope && (currentScope = scope.parent_);
      }
      function enterScope(immer2) {
        return (currentScope = (function createScope(parent_, immer_) {
          return { drafts_: [], parent_, immer_, canAutoFreeze_: !0, unfinalizedDrafts_: 0 };
        })(currentScope, immer2));
      }
      function revokeDraft(draft) {
        const state = draft[DRAFT_STATE];
        0 === state.type_ || 1 === state.type_ ? state.revoke_() : (state.revoked_ = !0);
      }
      function processResult(result, scope) {
        scope.unfinalizedDrafts_ = scope.drafts_.length;
        const baseDraft = scope.drafts_[0];
        return (
          void 0 !== result && result !== baseDraft
            ? (baseDraft[DRAFT_STATE].modified_ && (revokeScope(scope), die(4)),
              isDraftable(result) &&
                ((result = finalize(scope, result)), scope.parent_ || maybeFreeze(scope, result)),
              scope.patches_ &&
                getPlugin('Patches').generateReplacementPatches_(
                  baseDraft[DRAFT_STATE].base_,
                  result,
                  scope.patches_,
                  scope.inversePatches_
                ))
            : (result = finalize(scope, baseDraft, [])),
          revokeScope(scope),
          scope.patches_ && scope.patchListener_(scope.patches_, scope.inversePatches_),
          result !== NOTHING ? result : void 0
        );
      }
      function finalize(rootScope, value, path) {
        if (isFrozen(value)) return value;
        const useStrictIteration = rootScope.immer_.shouldUseStrictIteration(),
          state = value[DRAFT_STATE];
        if (!state)
          return (
            each(
              value,
              (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path),
              useStrictIteration
            ),
            value
          );
        if (state.scope_ !== rootScope) return value;
        if (!state.modified_) return (maybeFreeze(rootScope, state.base_, !0), state.base_);
        if (!state.finalized_) {
          ((state.finalized_ = !0), state.scope_.unfinalizedDrafts_--);
          const result = state.copy_;
          let resultEach = result,
            isSet2 = !1;
          (3 === state.type_ && ((resultEach = new Set(result)), result.clear(), (isSet2 = !0)),
            each(
              resultEach,
              (key, childValue) =>
                finalizeProperty(rootScope, state, result, key, childValue, path, isSet2),
              useStrictIteration
            ),
            maybeFreeze(rootScope, result, !1),
            path &&
              rootScope.patches_ &&
              getPlugin('Patches').generatePatches_(
                state,
                path,
                rootScope.patches_,
                rootScope.inversePatches_
              ));
        }
        return state.copy_;
      }
      function finalizeProperty(
        rootScope,
        parentState,
        targetObject,
        prop,
        childValue,
        rootPath,
        targetIsSet
      ) {
        if (null == childValue) return;
        if ('object' != typeof childValue && !targetIsSet) return;
        const childIsFrozen = isFrozen(childValue);
        if (!childIsFrozen || targetIsSet) {
          if (isDraft(childValue)) {
            const res = finalize(
              rootScope,
              childValue,
              rootPath &&
                parentState &&
                3 !== parentState.type_ &&
                !has(parentState.assigned_, prop)
                ? rootPath.concat(prop)
                : void 0
            );
            if ((set(targetObject, prop, res), !isDraft(res))) return;
            rootScope.canAutoFreeze_ = !1;
          } else targetIsSet && targetObject.add(childValue);
          if (isDraftable(childValue) && !childIsFrozen) {
            if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) return;
            if (
              parentState &&
              parentState.base_ &&
              parentState.base_[prop] === childValue &&
              childIsFrozen
            )
              return;
            (finalize(rootScope, childValue),
              (parentState && parentState.scope_.parent_) ||
                'symbol' == typeof prop ||
                !(isMap(targetObject)
                  ? targetObject.has(prop)
                  : Object.prototype.propertyIsEnumerable.call(targetObject, prop)) ||
                maybeFreeze(rootScope, childValue));
          }
        }
      }
      function maybeFreeze(scope, value, deep = !1) {
        !scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_ && freeze(value, deep);
      }
      var objectTraps = {
          get(state, prop) {
            if (prop === DRAFT_STATE) return state;
            const source = latest(state);
            if (!has(source, prop))
              return (function readPropFromProto(state, source, prop) {
                const desc = getDescriptorFromProto(source, prop);
                return desc
                  ? 'value' in desc
                    ? desc.value
                    : desc.get?.call(state.draft_)
                  : void 0;
              })(state, source, prop);
            const value = source[prop];
            return state.finalized_ || !isDraftable(value)
              ? value
              : value === peek(state.base_, prop)
                ? (prepareCopy(state), (state.copy_[prop] = createProxy(value, state)))
                : value;
          },
          has: (state, prop) => prop in latest(state),
          ownKeys: (state) => Reflect.ownKeys(latest(state)),
          set(state, prop, value) {
            const desc = getDescriptorFromProto(latest(state), prop);
            if (desc?.set) return (desc.set.call(state.draft_, value), !0);
            if (!state.modified_) {
              const current2 = peek(latest(state), prop),
                currentState = current2?.[DRAFT_STATE];
              if (currentState && currentState.base_ === value)
                return ((state.copy_[prop] = value), (state.assigned_[prop] = !1), !0);
              if (
                (function is(x, y) {
                  return x === y ? 0 !== x || 1 / x == 1 / y : x != x && y != y;
                })(value, current2) &&
                (void 0 !== value || has(state.base_, prop))
              )
                return !0;
              (prepareCopy(state), markChanged(state));
            }
            return (
              (state.copy_[prop] === value && (void 0 !== value || prop in state.copy_)) ||
                (Number.isNaN(value) && Number.isNaN(state.copy_[prop])) ||
                ((state.copy_[prop] = value), (state.assigned_[prop] = !0)),
              !0
            );
          },
          deleteProperty: (state, prop) => (
            void 0 !== peek(state.base_, prop) || prop in state.base_
              ? ((state.assigned_[prop] = !1), prepareCopy(state), markChanged(state))
              : delete state.assigned_[prop],
            state.copy_ && delete state.copy_[prop],
            !0
          ),
          getOwnPropertyDescriptor(state, prop) {
            const owner = latest(state),
              desc = Reflect.getOwnPropertyDescriptor(owner, prop);
            return desc
              ? {
                  writable: !0,
                  configurable: 1 !== state.type_ || 'length' !== prop,
                  enumerable: desc.enumerable,
                  value: owner[prop],
                }
              : desc;
          },
          defineProperty() {
            die(11);
          },
          getPrototypeOf: (state) => getPrototypeOf(state.base_),
          setPrototypeOf() {
            die(12);
          },
        },
        arrayTraps = {};
      function peek(draft, prop) {
        const state = draft[DRAFT_STATE];
        return (state ? latest(state) : draft)[prop];
      }
      function getDescriptorFromProto(source, prop) {
        if (!(prop in source)) return;
        let proto = getPrototypeOf(source);
        for (; proto; ) {
          const desc = Object.getOwnPropertyDescriptor(proto, prop);
          if (desc) return desc;
          proto = getPrototypeOf(proto);
        }
      }
      function markChanged(state) {
        state.modified_ || ((state.modified_ = !0), state.parent_ && markChanged(state.parent_));
      }
      function prepareCopy(state) {
        state.copy_ ||
          (state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_));
      }
      (each(objectTraps, (key, fn) => {
        arrayTraps[key] = function () {
          return ((arguments[0] = arguments[0][0]), fn.apply(this, arguments));
        };
      }),
        (arrayTraps.deleteProperty = function (state, prop) {
          return arrayTraps.set.call(this, state, prop, void 0);
        }),
        (arrayTraps.set = function (state, prop, value) {
          return objectTraps.set.call(this, state[0], prop, value, state[0]);
        }));
      function createProxy(value, parent) {
        const draft = isMap(value)
          ? getPlugin('MapSet').proxyMap_(value, parent)
          : isSet(value)
            ? getPlugin('MapSet').proxySet_(value, parent)
            : (function createProxyProxy(base, parent) {
                const isArray = Array.isArray(base),
                  state = {
                    type_: isArray ? 1 : 0,
                    scope_: parent ? parent.scope_ : getCurrentScope(),
                    modified_: !1,
                    finalized_: !1,
                    assigned_: {},
                    parent_: parent,
                    base_: base,
                    draft_: null,
                    copy_: null,
                    revoke_: null,
                    isManual_: !1,
                  };
                let target = state,
                  traps = objectTraps;
                isArray && ((target = [state]), (traps = arrayTraps));
                const { revoke, proxy } = Proxy.revocable(target, traps);
                return ((state.draft_ = proxy), (state.revoke_ = revoke), proxy);
              })(value, parent);
        return ((parent ? parent.scope_ : getCurrentScope()).drafts_.push(draft), draft);
      }
      function currentImpl(value) {
        if (!isDraftable(value) || isFrozen(value)) return value;
        const state = value[DRAFT_STATE];
        let copy,
          strict = !0;
        if (state) {
          if (!state.modified_) return state.base_;
          ((state.finalized_ = !0),
            (copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)),
            (strict = state.scope_.immer_.shouldUseStrictIteration()));
        } else copy = shallowCopy(value, !0);
        return (
          each(
            copy,
            (key, childValue) => {
              set(copy, key, currentImpl(childValue));
            },
            strict
          ),
          state && (state.finalized_ = !1),
          copy
        );
      }
      var immer = new (class {
        constructor(config) {
          ((this.autoFreeze_ = !0),
            (this.useStrictShallowCopy_ = !1),
            (this.useStrictIteration_ = !0),
            (this.produce = (base, recipe, patchListener) => {
              if ('function' == typeof base && 'function' != typeof recipe) {
                const defaultBase = recipe;
                recipe = base;
                const self = this;
                return function curriedProduce(base2 = defaultBase, ...args) {
                  return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
                };
              }
              let result;
              if (
                ('function' != typeof recipe && die(6),
                void 0 !== patchListener && 'function' != typeof patchListener && die(7),
                isDraftable(base))
              ) {
                const scope = enterScope(this),
                  proxy = createProxy(base, void 0);
                let hasError = !0;
                try {
                  ((result = recipe(proxy)), (hasError = !1));
                } finally {
                  hasError ? revokeScope(scope) : leaveScope(scope);
                }
                return (usePatchesInScope(scope, patchListener), processResult(result, scope));
              }
              if (!base || 'object' != typeof base) {
                if (
                  ((result = recipe(base)),
                  void 0 === result && (result = base),
                  result === NOTHING && (result = void 0),
                  this.autoFreeze_ && freeze(result, !0),
                  patchListener)
                ) {
                  const p = [],
                    ip = [];
                  (getPlugin('Patches').generateReplacementPatches_(base, result, p, ip),
                    patchListener(p, ip));
                }
                return result;
              }
              die(1);
            }),
            (this.produceWithPatches = (base, recipe) => {
              if ('function' == typeof base)
                return (state, ...args) =>
                  this.produceWithPatches(state, (draft) => base(draft, ...args));
              let patches, inversePatches;
              return [
                this.produce(base, recipe, (p, ip) => {
                  ((patches = p), (inversePatches = ip));
                }),
                patches,
                inversePatches,
              ];
            }),
            'boolean' == typeof config?.autoFreeze && this.setAutoFreeze(config.autoFreeze),
            'boolean' == typeof config?.useStrictShallowCopy &&
              this.setUseStrictShallowCopy(config.useStrictShallowCopy),
            'boolean' == typeof config?.useStrictIteration &&
              this.setUseStrictIteration(config.useStrictIteration));
        }
        createDraft(base) {
          (isDraftable(base) || die(8),
            isDraft(base) &&
              (base = (function current(value) {
                isDraft(value) || die(10);
                return currentImpl(value);
              })(base)));
          const scope = enterScope(this),
            proxy = createProxy(base, void 0);
          return ((proxy[DRAFT_STATE].isManual_ = !0), leaveScope(scope), proxy);
        }
        finishDraft(draft, patchListener) {
          const state = draft && draft[DRAFT_STATE];
          (state && state.isManual_) || die(9);
          const { scope_: scope } = state;
          return (usePatchesInScope(scope, patchListener), processResult(void 0, scope));
        }
        setAutoFreeze(value) {
          this.autoFreeze_ = value;
        }
        setUseStrictShallowCopy(value) {
          this.useStrictShallowCopy_ = value;
        }
        setUseStrictIteration(value) {
          this.useStrictIteration_ = value;
        }
        shouldUseStrictIteration() {
          return this.useStrictIteration_;
        }
        applyPatches(base, patches) {
          let i;
          for (i = patches.length - 1; i >= 0; i--) {
            const patch = patches[i];
            if (0 === patch.path.length && 'replace' === patch.op) {
              base = patch.value;
              break;
            }
          }
          i > -1 && (patches = patches.slice(i + 1));
          const applyPatchesImpl = getPlugin('Patches').applyPatches_;
          return isDraft(base)
            ? applyPatchesImpl(base, patches)
            : this.produce(base, (draft) => applyPatchesImpl(draft, patches));
        }
      })();
      immer.produce;
      function castDraft(value) {
        return value;
      }
    },
    './node_modules/next/dist/shared/lib/dynamic.js'(module, exports, __webpack_require__) {
      'use strict';
      (Object.defineProperty(exports, '__esModule', { value: !0 }),
        (function _export(target, all) {
          for (var name in all)
            Object.defineProperty(target, name, { enumerable: !0, get: all[name] });
        })(exports, {
          default: function () {
            return dynamic;
          },
          noSSR: function () {
            return noSSR;
          },
        }));
      const _interop_require_default = __webpack_require__(
          './node_modules/@swc/helpers/cjs/_interop_require_default.cjs'
        ),
        _jsxruntime = __webpack_require__('./node_modules/next/dist/compiled/react/jsx-runtime.js'),
        _loadablesharedruntime =
          (__webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
          _interop_require_default._(
            __webpack_require__('./node_modules/next/dist/shared/lib/loadable.shared-runtime.js')
          )),
        isServerSide = 'undefined' == typeof window;
      function convertModule(mod) {
        return { default: mod?.default || mod };
      }
      function noSSR(LoadableInitializer, loadableOptions) {
        if ((delete loadableOptions.webpack, delete loadableOptions.modules, !isServerSide))
          return LoadableInitializer(loadableOptions);
        const Loading = loadableOptions.loading;
        return () =>
          (0, _jsxruntime.jsx)(Loading, {
            error: null,
            isLoading: !0,
            pastDelay: !1,
            timedOut: !1,
          });
      }
      function dynamic(dynamicOptions, options) {
        let loadableFn = _loadablesharedruntime.default,
          loadableOptions = { loading: ({ error, isLoading, pastDelay }) => null };
        (dynamicOptions instanceof Promise
          ? (loadableOptions.loader = () => dynamicOptions)
          : 'function' == typeof dynamicOptions
            ? (loadableOptions.loader = dynamicOptions)
            : 'object' == typeof dynamicOptions &&
              (loadableOptions = { ...loadableOptions, ...dynamicOptions }),
          (loadableOptions = { ...loadableOptions, ...options }));
        const loaderFn = loadableOptions.loader;
        return (
          loadableOptions.loadableGenerated &&
            ((loadableOptions = { ...loadableOptions, ...loadableOptions.loadableGenerated }),
            delete loadableOptions.loadableGenerated),
          'boolean' != typeof loadableOptions.ssr || loadableOptions.ssr
            ? loadableFn({
                ...loadableOptions,
                loader: () =>
                  null != loaderFn
                    ? loaderFn().then(convertModule)
                    : Promise.resolve(convertModule(() => null)),
              })
            : (delete loadableOptions.webpack,
              delete loadableOptions.modules,
              noSSR(loadableFn, loadableOptions))
        );
      }
      ('function' == typeof exports.default ||
        ('object' == typeof exports.default && null !== exports.default)) &&
        void 0 === exports.default.__esModule &&
        (Object.defineProperty(exports.default, '__esModule', { value: !0 }),
        Object.assign(exports.default, exports),
        (module.exports = exports.default));
    },
    './node_modules/next/dist/shared/lib/loadable-context.shared-runtime.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      (Object.defineProperty(exports, '__esModule', { value: !0 }),
        Object.defineProperty(exports, 'LoadableContext', {
          enumerable: !0,
          get: function () {
            return LoadableContext;
          },
        }));
      const LoadableContext = __webpack_require__(
        './node_modules/@swc/helpers/cjs/_interop_require_default.cjs'
      )
        ._(__webpack_require__('./node_modules/next/dist/compiled/react/index.js'))
        .default.createContext(null);
    },
    './node_modules/next/dist/shared/lib/loadable.shared-runtime.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      (Object.defineProperty(exports, '__esModule', { value: !0 }),
        Object.defineProperty(exports, 'default', {
          enumerable: !0,
          get: function () {
            return _default;
          },
        }));
      const _react = __webpack_require__(
          './node_modules/@swc/helpers/cjs/_interop_require_default.cjs'
        )._(__webpack_require__('./node_modules/next/dist/compiled/react/index.js')),
        _loadablecontextsharedruntime = __webpack_require__(
          './node_modules/next/dist/shared/lib/loadable-context.shared-runtime.js'
        );
      const ALL_INITIALIZERS = [],
        READY_INITIALIZERS = [];
      let initialized = !1;
      function load(loader) {
        let promise = loader(),
          state = { loading: !0, loaded: null, error: null };
        return (
          (state.promise = promise
            .then((loaded) => ((state.loading = !1), (state.loaded = loaded), loaded))
            .catch((err) => {
              throw ((state.loading = !1), (state.error = err), err);
            })),
          state
        );
      }
      function createLoadableComponent(loadFn, options) {
        let opts = Object.assign(
            {
              loader: null,
              loading: null,
              delay: 200,
              timeout: null,
              webpack: null,
              modules: null,
            },
            options
          ),
          subscription = null;
        function init() {
          if (!subscription) {
            const sub = new LoadableSubscription(loadFn, opts);
            subscription = {
              getCurrentValue: sub.getCurrentValue.bind(sub),
              subscribe: sub.subscribe.bind(sub),
              retry: sub.retry.bind(sub),
              promise: sub.promise.bind(sub),
            };
          }
          return subscription.promise();
        }
        if (
          ('undefined' == typeof window && ALL_INITIALIZERS.push(init),
          !initialized && 'undefined' != typeof window)
        ) {
          const moduleIds = opts.webpack ? opts.webpack() : opts.modules;
          moduleIds &&
            READY_INITIALIZERS.push((ids) => {
              for (const moduleId of moduleIds) if (ids.includes(moduleId)) return init();
            });
        }
        function LoadableComponent(props, ref) {
          !(function useLoadableModule() {
            init();
            const context = _react.default.useContext(
              _loadablecontextsharedruntime.LoadableContext
            );
            context &&
              Array.isArray(opts.modules) &&
              opts.modules.forEach((moduleName) => {
                context(moduleName);
              });
          })();
          const state = _react.default.useSyncExternalStore(
            subscription.subscribe,
            subscription.getCurrentValue,
            subscription.getCurrentValue
          );
          return (
            _react.default.useImperativeHandle(ref, () => ({ retry: subscription.retry }), []),
            _react.default.useMemo(
              () =>
                state.loading || state.error
                  ? _react.default.createElement(opts.loading, {
                      isLoading: state.loading,
                      pastDelay: state.pastDelay,
                      timedOut: state.timedOut,
                      error: state.error,
                      retry: subscription.retry,
                    })
                  : state.loaded
                    ? _react.default.createElement(
                        (function resolve(obj) {
                          return obj && obj.default ? obj.default : obj;
                        })(state.loaded),
                        props
                      )
                    : null,
              [props, state]
            )
          );
        }
        return (
          (LoadableComponent.preload = () => init()),
          (LoadableComponent.displayName = 'LoadableComponent'),
          _react.default.forwardRef(LoadableComponent)
        );
      }
      class LoadableSubscription {
        constructor(loadFn, opts) {
          ((this._loadFn = loadFn),
            (this._opts = opts),
            (this._callbacks = new Set()),
            (this._delay = null),
            (this._timeout = null),
            this.retry());
        }
        promise() {
          return this._res.promise;
        }
        retry() {
          (this._clearTimeouts(),
            (this._res = this._loadFn(this._opts.loader)),
            (this._state = { pastDelay: !1, timedOut: !1 }));
          const { _res: res, _opts: opts } = this;
          (res.loading &&
            ('number' == typeof opts.delay &&
              (0 === opts.delay
                ? (this._state.pastDelay = !0)
                : (this._delay = setTimeout(() => {
                    this._update({ pastDelay: !0 });
                  }, opts.delay))),
            'number' == typeof opts.timeout &&
              (this._timeout = setTimeout(() => {
                this._update({ timedOut: !0 });
              }, opts.timeout))),
            this._res.promise
              .then(() => {
                (this._update({}), this._clearTimeouts());
              })
              .catch((_err) => {
                (this._update({}), this._clearTimeouts());
              }),
            this._update({}));
        }
        _update(partial) {
          ((this._state = {
            ...this._state,
            error: this._res.error,
            loaded: this._res.loaded,
            loading: this._res.loading,
            ...partial,
          }),
            this._callbacks.forEach((callback) => callback()));
        }
        _clearTimeouts() {
          (clearTimeout(this._delay), clearTimeout(this._timeout));
        }
        getCurrentValue() {
          return this._state;
        }
        subscribe(callback) {
          return (
            this._callbacks.add(callback),
            () => {
              this._callbacks.delete(callback);
            }
          );
        }
      }
      function Loadable(opts) {
        return createLoadableComponent(load, opts);
      }
      function flushInitializers(initializers, ids) {
        let promises = [];
        for (; initializers.length; ) {
          let init = initializers.pop();
          promises.push(init(ids));
        }
        return Promise.all(promises).then(() => {
          if (initializers.length) return flushInitializers(initializers, ids);
        });
      }
      ((Loadable.preloadAll = () =>
        new Promise((resolveInitializers, reject) => {
          flushInitializers(ALL_INITIALIZERS).then(resolveInitializers, reject);
        })),
        (Loadable.preloadReady = (ids = []) =>
          new Promise((resolvePreload) => {
            const res = () => ((initialized = !0), resolvePreload());
            flushInitializers(READY_INITIALIZERS, ids).then(res, res);
          })),
        'undefined' != typeof window && (window.__NEXT_PRELOADREADY = Loadable.preloadReady));
      const _default = Loadable;
    },
    './node_modules/next/dynamic.js'(module, __unused_webpack_exports, __webpack_require__) {
      module.exports = __webpack_require__('./node_modules/next/dist/shared/lib/dynamic.js');
    },
    './node_modules/react-is/cjs/react-is.production.min.js'(__unused_webpack_module, exports) {
      'use strict';
      var b = 'function' == typeof Symbol && Symbol.for,
        c = b ? Symbol.for('react.element') : 60103,
        d = b ? Symbol.for('react.portal') : 60106,
        e = b ? Symbol.for('react.fragment') : 60107,
        f = b ? Symbol.for('react.strict_mode') : 60108,
        g = b ? Symbol.for('react.profiler') : 60114,
        h = b ? Symbol.for('react.provider') : 60109,
        k = b ? Symbol.for('react.context') : 60110,
        l = b ? Symbol.for('react.async_mode') : 60111,
        m = b ? Symbol.for('react.concurrent_mode') : 60111,
        n = b ? Symbol.for('react.forward_ref') : 60112,
        p = b ? Symbol.for('react.suspense') : 60113,
        q = b ? Symbol.for('react.suspense_list') : 60120,
        r = b ? Symbol.for('react.memo') : 60115,
        t = b ? Symbol.for('react.lazy') : 60116,
        v = b ? Symbol.for('react.block') : 60121,
        w = b ? Symbol.for('react.fundamental') : 60117,
        x = b ? Symbol.for('react.responder') : 60118,
        y = b ? Symbol.for('react.scope') : 60119;
      function z(a) {
        if ('object' == typeof a && null !== a) {
          var u = a.$$typeof;
          switch (u) {
            case c:
              switch ((a = a.type)) {
                case l:
                case m:
                case e:
                case g:
                case f:
                case p:
                  return a;
                default:
                  switch ((a = a && a.$$typeof)) {
                    case k:
                    case n:
                    case t:
                    case r:
                    case h:
                      return a;
                    default:
                      return u;
                  }
              }
            case d:
              return u;
          }
        }
      }
      function A(a) {
        return z(a) === m;
      }
      exports.isFragment = function (a) {
        return z(a) === e;
      };
    },
    './node_modules/react-is/index.js'(module, __unused_webpack_exports, __webpack_require__) {
      'use strict';
      module.exports = __webpack_require__(
        './node_modules/react-is/cjs/react-is.production.min.js'
      );
    },
    './node_modules/react-redux/dist/react-redux.mjs'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        Kq: () => Provider_default,
        bN: () => shallowEqual,
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        './node_modules/next/dist/compiled/react/index.js'
      );
      (__webpack_require__('./node_modules/use-sync-external-store/with-selector.js'),
        __webpack_require__('./node_modules/console-browserify/index.js'));
      function defaultNoopBatch(callback) {
        callback();
      }
      var nullListeners = { notify() {}, get: () => [] };
      function createSubscription(store, parentSub) {
        let unsubscribe,
          listeners = nullListeners,
          subscriptionsAmount = 0,
          selfSubscribed = !1;
        function handleChangeWrapper() {
          subscription.onStateChange && subscription.onStateChange();
        }
        function trySubscribe() {
          (subscriptionsAmount++,
            unsubscribe ||
              ((unsubscribe = parentSub
                ? parentSub.addNestedSub(handleChangeWrapper)
                : store.subscribe(handleChangeWrapper)),
              (listeners = (function createListenerCollection() {
                let first = null,
                  last = null;
                return {
                  clear() {
                    ((first = null), (last = null));
                  },
                  notify() {
                    defaultNoopBatch(() => {
                      let listener = first;
                      for (; listener; ) (listener.callback(), (listener = listener.next));
                    });
                  },
                  get() {
                    const listeners = [];
                    let listener = first;
                    for (; listener; ) (listeners.push(listener), (listener = listener.next));
                    return listeners;
                  },
                  subscribe(callback) {
                    let isSubscribed = !0;
                    const listener = (last = { callback, next: null, prev: last });
                    return (
                      listener.prev ? (listener.prev.next = listener) : (first = listener),
                      function unsubscribe() {
                        isSubscribed &&
                          null !== first &&
                          ((isSubscribed = !1),
                          listener.next
                            ? (listener.next.prev = listener.prev)
                            : (last = listener.prev),
                          listener.prev
                            ? (listener.prev.next = listener.next)
                            : (first = listener.next));
                      }
                    );
                  },
                };
              })())));
        }
        function tryUnsubscribe() {
          (subscriptionsAmount--,
            unsubscribe &&
              0 === subscriptionsAmount &&
              (unsubscribe(),
              (unsubscribe = void 0),
              listeners.clear(),
              (listeners = nullListeners)));
        }
        const subscription = {
          addNestedSub: function addNestedSub(listener) {
            trySubscribe();
            const cleanupListener = listeners.subscribe(listener);
            let removed = !1;
            return () => {
              removed || ((removed = !0), cleanupListener(), tryUnsubscribe());
            };
          },
          notifyNestedSubs: function notifyNestedSubs() {
            listeners.notify();
          },
          handleChangeWrapper,
          isSubscribed: function isSubscribed() {
            return selfSubscribed;
          },
          trySubscribe: function trySubscribeSelf() {
            selfSubscribed || ((selfSubscribed = !0), trySubscribe());
          },
          tryUnsubscribe: function tryUnsubscribeSelf() {
            selfSubscribed && ((selfSubscribed = !1), tryUnsubscribe());
          },
          getListeners: () => listeners,
        };
        return subscription;
      }
      var isDOM = (() =>
          !(
            'undefined' == typeof window ||
            void 0 === window.document ||
            void 0 === window.document.createElement
          ))(),
        isReactNative = (() =>
          'undefined' != typeof navigator && 'ReactNative' === navigator.product)(),
        useIsomorphicLayoutEffect = (() =>
          isDOM || isReactNative
            ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect
            : react__WEBPACK_IMPORTED_MODULE_0__.useEffect)();
      function is(x, y) {
        return x === y ? 0 !== x || 0 !== y || 1 / x == 1 / y : x != x && y != y;
      }
      function shallowEqual(objA, objB) {
        if (is(objA, objB)) return !0;
        if ('object' != typeof objA || null === objA || 'object' != typeof objB || null === objB)
          return !1;
        const keysA = Object.keys(objA),
          keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return !1;
        for (let i = 0; i < keysA.length; i++)
          if (
            !Object.prototype.hasOwnProperty.call(objB, keysA[i]) ||
            !is(objA[keysA[i]], objB[keysA[i]])
          )
            return !1;
        return !0;
      }
      (Object.defineProperty,
        Object.getOwnPropertyNames,
        Object.getOwnPropertySymbols,
        Object.getOwnPropertyDescriptor,
        Object.getPrototypeOf,
        Object.prototype);
      var ContextKey = Symbol.for('react-redux-context'),
        gT = 'undefined' != typeof globalThis ? globalThis : {};
      function getContext() {
        if (!react__WEBPACK_IMPORTED_MODULE_0__.createContext) return {};
        const contextMap = (gT[ContextKey] ??= new Map());
        let realContext = contextMap.get(react__WEBPACK_IMPORTED_MODULE_0__.createContext);
        return (
          realContext ||
            ((realContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null)),
            contextMap.set(react__WEBPACK_IMPORTED_MODULE_0__.createContext, realContext)),
          realContext
        );
      }
      var ReactReduxContext = getContext();
      var Provider_default = function Provider(providerProps) {
        const { children, context, serverState, store } = providerProps,
          contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
            const subscription = createSubscription(store);
            return {
              store,
              subscription,
              getServerState: serverState ? () => serverState : void 0,
            };
          }, [store, serverState]),
          previousState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(
            () => store.getState(),
            [store]
          );
        useIsomorphicLayoutEffect(() => {
          const { subscription } = contextValue;
          return (
            (subscription.onStateChange = subscription.notifyNestedSubs),
            subscription.trySubscribe(),
            previousState !== store.getState() && subscription.notifyNestedSubs(),
            () => {
              (subscription.tryUnsubscribe(), (subscription.onStateChange = void 0));
            }
          );
        }, [contextValue, previousState]);
        const Context = context || ReactReduxContext;
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
          Context.Provider,
          { value: contextValue },
          children
        );
      };
    },
    './node_modules/recharts/es6/animation/JavascriptAnimate.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { J: () => JavascriptAnimate });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        resolveDefaultProps = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        util = __webpack_require__('./node_modules/recharts/es6/animation/util.js');
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var alpha = (begin, end, k) => begin + (end - begin) * k,
        needContinue = (_ref) => {
          var { from, to } = _ref;
          return from !== to;
        },
        calStepperVals = (easing, preVals, steps) => {
          var nextStepVals = (0, util.s8)((key, val) => {
            if (needContinue(val)) {
              var [newX, newV] = easing(val.from, val.to, val.velocity);
              return _objectSpread(_objectSpread({}, val), {}, { from: newX, velocity: newV });
            }
            return val;
          }, preVals);
          return steps < 1
            ? (0, util.s8)(
                (key, val) =>
                  needContinue(val) && null != nextStepVals[key]
                    ? _objectSpread(
                        _objectSpread({}, val),
                        {},
                        {
                          velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
                          from: alpha(val.from, nextStepVals[key].from, steps),
                        }
                      )
                    : val,
                preVals
              )
            : calStepperVals(easing, nextStepVals, steps - 1);
        };
      function createStepperUpdate(from, to, easing, interKeys, render, timeoutController) {
        var preTime,
          stepperStyle = interKeys.reduce(
            (res, key) =>
              _objectSpread(
                _objectSpread({}, res),
                {},
                { [key]: { from: from[key], velocity: 0, to: to[key] } }
              ),
            {}
          ),
          stopAnimation = null,
          stepperUpdate = (now) => {
            preTime || (preTime = now);
            var steps = (now - preTime) / easing.dt;
            ((stepperStyle = calStepperVals(easing, stepperStyle, steps)),
              render(
                _objectSpread(
                  _objectSpread(_objectSpread({}, from), to),
                  (0, util.s8)((key, val) => val.from, stepperStyle)
                )
              ),
              (preTime = now),
              Object.values(stepperStyle).filter(needContinue).length &&
                (stopAnimation = timeoutController.setTimeout(stepperUpdate)));
          };
        return () => (
          (stopAnimation = timeoutController.setTimeout(stepperUpdate)),
          () => {
            var _stopAnimation;
            null === (_stopAnimation = stopAnimation) ||
              void 0 === _stopAnimation ||
              _stopAnimation();
          }
        );
      }
      const configUpdate = (from, to, easing, duration, render, timeoutController) => {
        var interKeys = (0, util.mP)(from, to);
        return null == easing
          ? () => (render(_objectSpread(_objectSpread({}, from), to)), () => {})
          : !0 === easing.isStepper
            ? createStepperUpdate(from, to, easing, interKeys, render, timeoutController)
            : (function createTimingUpdate(
                from,
                to,
                easing,
                duration,
                interKeys,
                render,
                timeoutController
              ) {
                var beginTime,
                  stopAnimation = null,
                  timingStyle = interKeys.reduce((res, key) => {
                    var fromElement = from[key],
                      toElement = to[key];
                    return null == fromElement || null == toElement
                      ? res
                      : _objectSpread(
                          _objectSpread({}, res),
                          {},
                          { [key]: [fromElement, toElement] }
                        );
                  }, {}),
                  timingUpdate = (now) => {
                    beginTime || (beginTime = now);
                    var t = (now - beginTime) / duration,
                      currStyle = (0, util.s8)((key, val) => alpha(...val, easing(t)), timingStyle);
                    if (
                      (render(_objectSpread(_objectSpread(_objectSpread({}, from), to), currStyle)),
                      t < 1)
                    )
                      stopAnimation = timeoutController.setTimeout(timingUpdate);
                    else {
                      var finalStyle = (0, util.s8)(
                        (key, val) => alpha(...val, easing(1)),
                        timingStyle
                      );
                      render(_objectSpread(_objectSpread(_objectSpread({}, from), to), finalStyle));
                    }
                  };
                return () => (
                  (stopAnimation = timeoutController.setTimeout(timingUpdate)),
                  () => {
                    var _stopAnimation2;
                    null === (_stopAnimation2 = stopAnimation) ||
                      void 0 === _stopAnimation2 ||
                      _stopAnimation2();
                  }
                );
              })(from, to, easing, duration, interKeys, render, timeoutController);
      };
      var cubicBezierFactor = (c1, c2) => [0, 3 * c1, 3 * c2 - 6 * c1, 3 * c1 - 3 * c2 + 1],
        evaluatePolynomial = (params, t) =>
          params.map((param, i) => param * t ** i).reduce((pre, curr) => pre + curr),
        cubicBezier = (c1, c2) => (t) => {
          var params = cubicBezierFactor(c1, c2);
          return evaluatePolynomial(params, t);
        },
        getBezierCoordinates = function getBezierCoordinates() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          if (1 === args.length)
            switch (args[0]) {
              case 'linear':
                return [0, 0, 1, 1];
              case 'ease':
                return [0.25, 0.1, 0.25, 1];
              case 'ease-in':
                return [0.42, 0, 1, 1];
              case 'ease-out':
                return [0.42, 0, 0.58, 1];
              case 'ease-in-out':
                return [0, 0, 0.58, 1];
              default:
                var easing = ((easing) => {
                  var _easingParts$,
                    easingParts = easing.split('(');
                  if (2 !== easingParts.length || 'cubic-bezier' !== easingParts[0]) return null;
                  var numbers =
                    null === (_easingParts$ = easingParts[1]) ||
                    void 0 === _easingParts$ ||
                    null === (_easingParts$ = _easingParts$.split(')')[0]) ||
                    void 0 === _easingParts$
                      ? void 0
                      : _easingParts$.split(',');
                  if (null == numbers || 4 !== numbers.length) return null;
                  var coords = numbers.map((x) => parseFloat(x));
                  return [coords[0], coords[1], coords[2], coords[3]];
                })(args[0]);
                if (easing) return easing;
            }
          return 4 === args.length ? args : [0, 0, 1, 1];
        },
        createBezierEasing = (x1, y1, x2, y2) => {
          var c1,
            c2,
            curveX = cubicBezier(x1, x2),
            curveY = cubicBezier(y1, y2),
            derCurveX =
              ((c1 = x1),
              (c2 = x2),
              (t) => {
                var newParams = [
                  ...cubicBezierFactor(c1, c2)
                    .map((param, i) => param * i)
                    .slice(1),
                  0,
                ];
                return evaluatePolynomial(newParams, t);
              }),
            rangeValue = (value) => (value > 1 ? 1 : value < 0 ? 0 : value),
            bezier = (_t) => {
              for (var t = _t > 1 ? 1 : _t, x = t, i = 0; i < 8; ++i) {
                var evalT = curveX(x) - t,
                  derVal = derCurveX(x);
                if (Math.abs(evalT - t) < 1e-4 || derVal < 1e-4) return curveY(x);
                x = rangeValue(x - evalT / derVal);
              }
              return curveY(x);
            };
          return ((bezier.isStepper = !1), bezier);
        },
        configBezier = function configBezier() {
          return createBezierEasing(...getBezierCoordinates(...arguments));
        },
        configEasing = (easing) => {
          if ('string' == typeof easing)
            switch (easing) {
              case 'ease':
              case 'ease-in-out':
              case 'ease-out':
              case 'ease-in':
              case 'linear':
                return configBezier(easing);
              case 'spring':
                return (function configSpring() {
                  var config = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    { stiff = 100, damping = 8, dt = 17 } = config,
                    stepper = (currX, destX, currV) => {
                      var newV = currV + ((-(currX - destX) * stiff - currV * damping) * dt) / 1e3,
                        newX = (currV * dt) / 1e3 + currX;
                      return Math.abs(newX - destX) < 1e-4 && Math.abs(newV) < 1e-4
                        ? [destX, 0]
                        : [newX, newV];
                    };
                  return ((stepper.isStepper = !0), (stepper.dt = dt), stepper);
                })();
              default:
                if ('cubic-bezier' === easing.split('(')[0]) return configBezier(easing);
            }
          return 'function' == typeof easing ? easing : null;
        };
      class RequestAnimationFrameTimeoutController {
        setTimeout(callback) {
          var delay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
            startTime = performance.now(),
            requestId = null,
            executeCallback = (now) => {
              now - startTime >= delay
                ? callback(now)
                : 'function' == typeof requestAnimationFrame &&
                  (requestId = requestAnimationFrame(executeCallback));
            };
          return (
            (requestId = requestAnimationFrame(executeCallback)),
            () => {
              null != requestId && cancelAnimationFrame(requestId);
            }
          );
        }
      }
      function createDefaultAnimationManager() {
        return (function createAnimateManager(timeoutController) {
          var handleChange = () => null,
            shouldStop = !1,
            cancelTimeout = null,
            setStyle = (_style) => {
              if (!shouldStop) {
                if (Array.isArray(_style)) {
                  if (!_style.length) return;
                  var styles = _style,
                    [curr, ...restStyles] = styles;
                  return 'number' == typeof curr
                    ? void (cancelTimeout = timeoutController.setTimeout(
                        setStyle.bind(null, restStyles),
                        curr
                      ))
                    : (setStyle(curr),
                      void (cancelTimeout = timeoutController.setTimeout(
                        setStyle.bind(null, restStyles)
                      )));
                }
                ('string' == typeof _style && handleChange(_style),
                  'object' == typeof _style && handleChange(_style),
                  'function' == typeof _style && _style());
              }
            };
          return {
            stop: () => {
              shouldStop = !0;
            },
            start: (style) => {
              ((shouldStop = !1),
                cancelTimeout && (cancelTimeout(), (cancelTimeout = null)),
                setStyle(style));
            },
            subscribe: (_handleChange) => (
              (handleChange = _handleChange),
              () => {
                handleChange = () => null;
              }
            ),
            getTimeoutController: () => timeoutController,
          };
        })(new RequestAnimationFrameTimeoutController());
      }
      var AnimationManagerContext = (0, react.createContext)(createDefaultAnimationManager);
      var Global = __webpack_require__('./node_modules/recharts/es6/util/Global.js'),
        defaultJavascriptAnimateProps = {
          begin: 0,
          duration: 1e3,
          easing: 'ease',
          isActive: !0,
          canBegin: !0,
          onAnimationEnd: () => {},
          onAnimationStart: () => {},
        },
        from = { t: 0 },
        to = { t: 1 };
      function JavascriptAnimate(outsideProps) {
        var props = (0, resolveDefaultProps.e)(outsideProps, defaultJavascriptAnimateProps),
          {
            isActive: isActiveProp,
            canBegin,
            duration,
            easing,
            begin,
            onAnimationEnd,
            onAnimationStart,
            children,
          } = props,
          isActive = 'auto' === isActiveProp ? !Global.m.isSsr : isActiveProp,
          animationManager = (function useAnimationManager(animationId, animationManagerFromProps) {
            var contextAnimationManager = (0, react.useContext)(AnimationManagerContext);
            return (0, react.useMemo)(
              () =>
                null != animationManagerFromProps
                  ? animationManagerFromProps
                  : contextAnimationManager(animationId),
              [animationId, animationManagerFromProps, contextAnimationManager]
            );
          })(props.animationId, props.animationManager),
          [style, setStyle] = (0, react.useState)(isActive ? from : to),
          stopJSAnimation = (0, react.useRef)(null);
        return (
          (0, react.useEffect)(() => {
            isActive || setStyle(to);
          }, [isActive]),
          (0, react.useEffect)(() => {
            if (!isActive || !canBegin) return DataUtils.lQ;
            var startAnimation = configUpdate(
              from,
              to,
              configEasing(easing),
              duration,
              setStyle,
              animationManager.getTimeoutController()
            );
            return (
              animationManager.start([
                onAnimationStart,
                begin,
                () => {
                  stopJSAnimation.current = startAnimation();
                },
                duration,
                onAnimationEnd,
              ]),
              () => {
                (animationManager.stop(),
                  stopJSAnimation.current && stopJSAnimation.current(),
                  onAnimationEnd());
              }
            );
          }, [
            isActive,
            canBegin,
            duration,
            easing,
            begin,
            onAnimationStart,
            onAnimationEnd,
            animationManager,
          ]),
          children(style.t)
        );
      }
    },
    './node_modules/recharts/es6/animation/util.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      __webpack_require__.d(__webpack_exports__, {
        dl: () => getTransitionVal,
        mP: () => getIntersectionKeys,
        s8: () => mapObject,
      });
      var getTransitionVal = (props, duration, easing) =>
          props
            .map((prop) => {
              return ''
                .concat(
                  ((name = prop), name.replace(/([A-Z])/g, (v) => '-'.concat(v.toLowerCase()))),
                  ' '
                )
                .concat(duration, 'ms ')
                .concat(easing);
              var name;
            })
            .join(','),
        getIntersectionKeys = (preObj, nextObj) =>
          [Object.keys(preObj), Object.keys(nextObj)].reduce((a, b) =>
            a.filter((c) => b.includes(c))
          ),
        mapObject = (fn, obj) =>
          Object.keys(obj).reduce(
            (res, key) => _objectSpread(_objectSpread({}, res), {}, { [key]: fn(key, obj[key]) }),
            {}
          );
    },
    './node_modules/recharts/es6/cartesian/Bar.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { yP: () => Bar, LP: () => computeBarRectangles });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
        Layer = __webpack_require__('./node_modules/recharts/es6/container/Layer.js'),
        Cell = __webpack_require__('./node_modules/recharts/es6/component/Cell.js'),
        LabelList = __webpack_require__('./node_modules/recharts/es6/component/LabelList.js'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        ReactUtils = __webpack_require__('./node_modules/recharts/es6/util/ReactUtils.js'),
        ChartUtils = __webpack_require__('./node_modules/recharts/es6/util/ChartUtils.js'),
        types = __webpack_require__('./node_modules/recharts/es6/util/types.js'),
        prefix = 'Invariant failed';
      var ActiveShapeUtils = __webpack_require__(
        './node_modules/recharts/es6/util/ActiveShapeUtils.js'
      );
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function BarRectangle(props) {
        return react.createElement(
          ActiveShapeUtils.y,
          _extends({ shapeType: 'rectangle', activeClassName: 'recharts-active-bar' }, props)
        );
      }
      var minPointSizeCallback = function minPointSizeCallback(minPointSize) {
          var defaultValue = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          return (value, index) => {
            if ((0, DataUtils.Et)(minPointSize)) return minPointSize;
            var isValueNumberOrNil = (0, DataUtils.Et)(value) || (0, DataUtils.uy)(value);
            return isValueNumberOrNil
              ? minPointSize(value, index)
              : (isValueNumberOrNil ||
                  (function invariant(condition, message) {
                    if (!condition) throw new Error(prefix);
                  })(
                    !1,
                    'minPointSize callback function received a value with type of '.concat(
                      typeof value,
                      '. Currently only numbers or null/undefined are supported.'
                    )
                  ),
                defaultValue);
          };
        },
        tooltipContext = __webpack_require__(
          './node_modules/recharts/es6/context/tooltipContext.js'
        ),
        SetTooltipEntrySettings = __webpack_require__(
          './node_modules/recharts/es6/state/SetTooltipEntrySettings.js'
        ),
        _excluded = ['children'];
      var initialContextState = {
          data: [],
          xAxisId: 'xAxis-0',
          yAxisId: 'yAxis-0',
          dataPointFormatter: () => ({ x: 0, y: 0, value: 0 }),
          errorBarOffset: 0,
        },
        ErrorBarContext = (0, react.createContext)(initialContextState);
      function SetErrorBarContext(props) {
        var { children } = props,
          rest = (function _objectWithoutProperties(e, t) {
            if (null == e) return {};
            var o,
              r,
              i = (function _objectWithoutPropertiesLoose(r, e) {
                if (null == r) return {};
                var t = {};
                for (var n in r)
                  if ({}.hasOwnProperty.call(r, n)) {
                    if (-1 !== e.indexOf(n)) continue;
                    t[n] = r[n];
                  }
                return t;
              })(e, t);
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              for (r = 0; r < n.length; r++)
                ((o = n[r]),
                  -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
            }
            return i;
          })(props, _excluded);
        return react.createElement(ErrorBarContext.Provider, { value: rest }, children);
      }
      var hooks = __webpack_require__('./node_modules/recharts/es6/state/hooks.js'),
        axisSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/axisSelectors.js'
        ),
        es6_hooks = __webpack_require__('./node_modules/recharts/es6/hooks.js');
      function useNeedsClip(xAxisId, yAxisId) {
        var _xAxis$allowDataOverf,
          _yAxis$allowDataOverf,
          xAxis = (0, hooks.G)((state) => (0, axisSelectors.Rl)(state, xAxisId)),
          yAxis = (0, hooks.G)((state) => (0, axisSelectors.sf)(state, yAxisId)),
          needClipX =
            null !== (_xAxis$allowDataOverf = null == xAxis ? void 0 : xAxis.allowDataOverflow) &&
            void 0 !== _xAxis$allowDataOverf
              ? _xAxis$allowDataOverf
              : axisSelectors.PU.allowDataOverflow,
          needClipY =
            null !== (_yAxis$allowDataOverf = null == yAxis ? void 0 : yAxis.allowDataOverflow) &&
            void 0 !== _yAxis$allowDataOverf
              ? _yAxis$allowDataOverf
              : axisSelectors.cd.allowDataOverflow;
        return { needClip: needClipX || needClipY, needClipX, needClipY };
      }
      function GraphicalItemClipPath(_ref) {
        var { xAxisId, yAxisId, clipPathId } = _ref,
          plotArea = (0, es6_hooks.oM)(),
          { needClipX, needClipY, needClip } = useNeedsClip(xAxisId, yAxisId);
        if (!needClip || !plotArea) return null;
        var { x, y, width, height } = plotArea;
        return react.createElement(
          'clipPath',
          { id: 'clipPath-'.concat(clipPathId) },
          react.createElement('rect', {
            x: needClipX ? x : x - width / 2,
            y: needClipY ? y : y - height / 2,
            width: needClipX ? width : 2 * width,
            height: needClipY ? height : 2 * height,
          })
        );
      }
      var chartLayoutContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        reselect = __webpack_require__('./node_modules/reselect/dist/reselect.mjs'),
        dataSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/dataSelectors.js'
        ),
        selectChartOffsetInternal = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
        ),
        rootPropsSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/rootPropsSelectors.js'
        ),
        StackedGraphicalItem = __webpack_require__(
          './node_modules/recharts/es6/state/types/StackedGraphicalItem.js'
        ),
        getBarSize = (globalSize, totalSize, selfSize) => {
          var barSize = null != selfSize ? selfSize : globalSize;
          if (!(0, DataUtils.uy)(barSize)) return (0, DataUtils.F4)(barSize, totalSize, 0);
        },
        isWellBehavedNumber = __webpack_require__(
          './node_modules/recharts/es6/util/isWellBehavedNumber.js'
        );
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var getStackSeriesIdentifier = __webpack_require__(
          './node_modules/recharts/es6/util/stacks/getStackSeriesIdentifier.js'
        ),
        cartesianAxisSlice = __webpack_require__(
          './node_modules/recharts/es6/state/cartesianAxisSlice.js'
        );
      function selectXAxisIdFromGraphicalItemId(state, id) {
        var _state$graphicalItems, _state$graphicalItems2;
        return null !==
          (_state$graphicalItems =
            null ===
              (_state$graphicalItems2 = state.graphicalItems.cartesianItems.find(
                (item) => item.id === id
              )) || void 0 === _state$graphicalItems2
              ? void 0
              : _state$graphicalItems2.xAxisId) && void 0 !== _state$graphicalItems
          ? _state$graphicalItems
          : cartesianAxisSlice.W3;
      }
      function selectYAxisIdFromGraphicalItemId(state, id) {
        var _state$graphicalItems3, _state$graphicalItems4;
        return null !==
          (_state$graphicalItems3 =
            null ===
              (_state$graphicalItems4 = state.graphicalItems.cartesianItems.find(
                (item) => item.id === id
              )) || void 0 === _state$graphicalItems4
              ? void 0
              : _state$graphicalItems4.yAxisId) && void 0 !== _state$graphicalItems3
          ? _state$graphicalItems3
          : cartesianAxisSlice.W3;
      }
      var selectSynchronisedBarSettings = (0, reselect.Mz)(
          [axisSelectors.ld, (_state, id) => id],
          (graphicalItems, id) =>
            graphicalItems.filter((item) => 'bar' === item.type).find((item) => item.id === id)
        ),
        selectMaxBarSize = (0, reselect.Mz)([selectSynchronisedBarSettings], (barSettings) =>
          null == barSettings ? void 0 : barSettings.maxBarSize
        ),
        selectAllVisibleBars = (0, reselect.Mz)(
          [
            chartLayoutContext.fz,
            axisSelectors.ld,
            selectXAxisIdFromGraphicalItemId,
            selectYAxisIdFromGraphicalItemId,
            (_state, _id, isPanorama) => isPanorama,
          ],
          (layout, allItems, xAxisId, yAxisId, isPanorama) =>
            allItems
              .filter((i) =>
                'horizontal' === layout ? i.xAxisId === xAxisId : i.yAxisId === yAxisId
              )
              .filter((i) => i.isPanorama === isPanorama)
              .filter((i) => !1 === i.hide)
              .filter((i) => 'bar' === i.type)
        ),
        selectBarSizeList = (0, reselect.Mz)(
          [
            selectAllVisibleBars,
            rootPropsSelectors.x3,
            (state, id) => {
              var layout = (0, chartLayoutContext.fz)(state),
                xAxisId = selectXAxisIdFromGraphicalItemId(state, id),
                yAxisId = selectYAxisIdFromGraphicalItemId(state, id);
              if (null != xAxisId && null != yAxisId)
                return 'horizontal' === layout
                  ? (0, axisSelectors.BQ)(state, 'xAxis', xAxisId)
                  : (0, axisSelectors.BQ)(state, 'yAxis', yAxisId);
            },
          ],
          (allBars, globalSize, totalSize) => {
            var stackedBars = allBars.filter(StackedGraphicalItem.g),
              unstackedBars = allBars.filter((b) => null == b.stackId),
              groupByStack = stackedBars.reduce(
                (acc, bar) => (
                  acc[bar.stackId] || (acc[bar.stackId] = []),
                  acc[bar.stackId].push(bar),
                  acc
                ),
                {}
              );
            return [
              ...Object.entries(groupByStack).map((_ref) => {
                var [stackId, bars] = _ref;
                return {
                  stackId,
                  dataKeys: bars.map((b) => b.dataKey),
                  barSize: getBarSize(globalSize, totalSize, bars[0].barSize),
                };
              }),
              ...unstackedBars.map((b) => ({
                stackId: void 0,
                dataKeys: [b.dataKey].filter((dk) => null != dk),
                barSize: getBarSize(globalSize, totalSize, b.barSize),
              })),
            ];
          }
        ),
        selectAxisBandSize = (state, id, isPanorama) => {
          var axis,
            ticks,
            layout = (0, chartLayoutContext.fz)(state),
            xAxisId = selectXAxisIdFromGraphicalItemId(state, id),
            yAxisId = selectYAxisIdFromGraphicalItemId(state, id);
          if (null != xAxisId && null != yAxisId)
            return (
              'horizontal' === layout
                ? ((axis = (0, axisSelectors.Gx)(state, 'xAxis', xAxisId, isPanorama)),
                  (ticks = (0, axisSelectors.CR)(state, 'xAxis', xAxisId, isPanorama)))
                : ((axis = (0, axisSelectors.Gx)(state, 'yAxis', yAxisId, isPanorama)),
                  (ticks = (0, axisSelectors.CR)(state, 'yAxis', yAxisId, isPanorama))),
              (0, ChartUtils.Hj)(axis, ticks)
            );
        },
        selectAllBarPositions = (0, reselect.Mz)(
          [
            selectBarSizeList,
            rootPropsSelectors.JN,
            rootPropsSelectors._5,
            rootPropsSelectors.gY,
            (state, id, isPanorama) => {
              var _ref,
                _getBandSizeOfAxis,
                barSettings = selectSynchronisedBarSettings(state, id);
              if (null != barSettings) {
                var xAxisId = selectXAxisIdFromGraphicalItemId(state, id),
                  yAxisId = selectYAxisIdFromGraphicalItemId(state, id);
                if (null != xAxisId && null != yAxisId) {
                  var axis,
                    ticks,
                    layout = (0, chartLayoutContext.fz)(state),
                    globalMaxBarSize = (0, rootPropsSelectors.JN)(state),
                    { maxBarSize: childMaxBarSize } = barSettings,
                    maxBarSize = (0, DataUtils.uy)(childMaxBarSize)
                      ? globalMaxBarSize
                      : childMaxBarSize;
                  return (
                    'horizontal' === layout
                      ? ((axis = (0, axisSelectors.Gx)(state, 'xAxis', xAxisId, isPanorama)),
                        (ticks = (0, axisSelectors.CR)(state, 'xAxis', xAxisId, isPanorama)))
                      : ((axis = (0, axisSelectors.Gx)(state, 'yAxis', yAxisId, isPanorama)),
                        (ticks = (0, axisSelectors.CR)(state, 'yAxis', yAxisId, isPanorama))),
                    null !==
                      (_ref =
                        null !== (_getBandSizeOfAxis = (0, ChartUtils.Hj)(axis, ticks, !0)) &&
                        void 0 !== _getBandSizeOfAxis
                          ? _getBandSizeOfAxis
                          : maxBarSize) && void 0 !== _ref
                      ? _ref
                      : 0
                  );
                }
              }
            },
            selectAxisBandSize,
            selectMaxBarSize,
          ],
          (
            sizeList,
            globalMaxBarSize,
            barGap,
            barCategoryGap,
            barBandSize,
            bandSize,
            childMaxBarSize
          ) => {
            var maxBarSize = (0, DataUtils.uy)(childMaxBarSize)
                ? globalMaxBarSize
                : childMaxBarSize,
              allBarPositions = (function getBarPositions(
                barGap,
                barCategoryGap,
                bandSize,
                sizeList,
                maxBarSize
              ) {
                var len = sizeList.length;
                if (!(len < 1)) {
                  var result,
                    realBarGap = (0, DataUtils.F4)(barGap, bandSize, 0, !0),
                    initialValue = [];
                  if ((0, isWellBehavedNumber.H)(sizeList[0].barSize)) {
                    var useFull = !1,
                      fullBarSize = bandSize / len,
                      sum = sizeList.reduce((res, entry) => res + (entry.barSize || 0), 0);
                    ((sum += (len - 1) * realBarGap) >= bandSize &&
                      ((sum -= (len - 1) * realBarGap), (realBarGap = 0)),
                      sum >= bandSize &&
                        fullBarSize > 0 &&
                        ((useFull = !0), (sum = len * (fullBarSize *= 0.9))));
                    var prev = { offset: (((bandSize - sum) / 2) | 0) - realBarGap, size: 0 };
                    result = sizeList.reduce((res, entry) => {
                      var _entry$barSize,
                        newRes = [
                          ...res,
                          {
                            stackId: entry.stackId,
                            dataKeys: entry.dataKeys,
                            position: {
                              offset: prev.offset + prev.size + realBarGap,
                              size: useFull
                                ? fullBarSize
                                : null !== (_entry$barSize = entry.barSize) &&
                                    void 0 !== _entry$barSize
                                  ? _entry$barSize
                                  : 0,
                            },
                          },
                        ];
                      return ((prev = newRes[newRes.length - 1].position), newRes);
                    }, initialValue);
                  } else {
                    var _offset = (0, DataUtils.F4)(barCategoryGap, bandSize, 0, !0);
                    bandSize - 2 * _offset - (len - 1) * realBarGap <= 0 && (realBarGap = 0);
                    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
                    originalSize > 1 && (originalSize >>= 0);
                    var size = (0, isWellBehavedNumber.H)(maxBarSize)
                      ? Math.min(originalSize, maxBarSize)
                      : originalSize;
                    result = sizeList.reduce(
                      (res, entry, i) => [
                        ...res,
                        {
                          stackId: entry.stackId,
                          dataKeys: entry.dataKeys,
                          position: {
                            offset:
                              _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
                            size,
                          },
                        },
                      ],
                      initialValue
                    );
                  }
                  return result;
                }
              })(
                barGap,
                barCategoryGap,
                barBandSize !== bandSize ? barBandSize : bandSize,
                sizeList,
                maxBarSize
              );
            return (
              barBandSize !== bandSize &&
                null != allBarPositions &&
                (allBarPositions = allBarPositions.map((pos) =>
                  _objectSpread(
                    _objectSpread({}, pos),
                    {},
                    {
                      position: _objectSpread(
                        _objectSpread({}, pos.position),
                        {},
                        { offset: pos.position.offset - barBandSize / 2 }
                      ),
                    }
                  )
                )),
              allBarPositions
            );
          }
        ),
        selectBarPosition = (0, reselect.Mz)(
          [selectAllBarPositions, selectSynchronisedBarSettings],
          (allBarPositions, barSettings) => {
            if (null != allBarPositions && null != barSettings) {
              var position = allBarPositions.find(
                (p) =>
                  p.stackId === barSettings.stackId &&
                  null != barSettings.dataKey &&
                  p.dataKeys.includes(barSettings.dataKey)
              );
              if (null != position) return position.position;
            }
          }
        ),
        selectStackedDataOfItem = (0, reselect.Mz)(
          [
            (state, id, isPanorama) => {
              var layout = (0, chartLayoutContext.fz)(state),
                xAxisId = selectXAxisIdFromGraphicalItemId(state, id),
                yAxisId = selectYAxisIdFromGraphicalItemId(state, id);
              if (null != xAxisId && null != yAxisId)
                return 'horizontal' === layout
                  ? (0, axisSelectors.TC)(state, 'yAxis', yAxisId, isPanorama)
                  : (0, axisSelectors.TC)(state, 'xAxis', xAxisId, isPanorama);
            },
            selectSynchronisedBarSettings,
          ],
          (stackGroups, barSettings) => {
            var stackSeriesIdentifier = (0, getStackSeriesIdentifier.x)(barSettings);
            if (stackGroups && null != stackSeriesIdentifier && null != barSettings) {
              var { stackId } = barSettings;
              if (null != stackId) {
                var stackGroup = stackGroups[stackId];
                if (stackGroup) {
                  var { stackedData } = stackGroup;
                  if (stackedData)
                    return stackedData.find((sd) => sd.key === stackSeriesIdentifier);
                }
              }
            }
          }
        ),
        selectBarRectangles = (0, reselect.Mz)(
          [
            selectChartOffsetInternal.HZ,
            selectChartOffsetInternal.c2,
            (state, id, isPanorama) => {
              var xAxisId = selectXAxisIdFromGraphicalItemId(state, id);
              if (null != xAxisId)
                return (0, axisSelectors.Gx)(state, 'xAxis', xAxisId, isPanorama);
            },
            (state, id, isPanorama) => {
              var yAxisId = selectYAxisIdFromGraphicalItemId(state, id);
              if (null != yAxisId)
                return (0, axisSelectors.Gx)(state, 'yAxis', yAxisId, isPanorama);
            },
            (state, id, isPanorama) => {
              var xAxisId = selectXAxisIdFromGraphicalItemId(state, id);
              if (null != xAxisId)
                return (0, axisSelectors.CR)(state, 'xAxis', xAxisId, isPanorama);
            },
            (state, id, isPanorama) => {
              var yAxisId = selectYAxisIdFromGraphicalItemId(state, id);
              if (null != yAxisId)
                return (0, axisSelectors.CR)(state, 'yAxis', yAxisId, isPanorama);
            },
            selectBarPosition,
            chartLayoutContext.fz,
            dataSelectors.rN,
            selectAxisBandSize,
            selectStackedDataOfItem,
            selectSynchronisedBarSettings,
            (_state, _id, _isPanorama, cells) => cells,
          ],
          (
            offset,
            axisViewBox,
            xAxis,
            yAxis,
            xAxisTicks,
            yAxisTicks,
            pos,
            layout,
            _ref2,
            bandSize,
            stackedData,
            barSettings,
            cells
          ) => {
            var { chartData, dataStartIndex, dataEndIndex } = _ref2;
            if (
              null != barSettings &&
              null != pos &&
              null != axisViewBox &&
              ('horizontal' === layout || 'vertical' === layout) &&
              null != xAxis &&
              null != yAxis &&
              null != xAxisTicks &&
              null != yAxisTicks &&
              null != bandSize
            ) {
              var displayedData,
                { data } = barSettings;
              if (
                null !=
                (displayedData =
                  null != data && data.length > 0
                    ? data
                    : null == chartData
                      ? void 0
                      : chartData.slice(dataStartIndex, dataEndIndex + 1))
              )
                return computeBarRectangles({
                  layout,
                  barSettings,
                  pos,
                  parentViewBox: axisViewBox,
                  bandSize,
                  xAxis,
                  yAxis,
                  xAxisTicks,
                  yAxisTicks,
                  stackedData,
                  displayedData,
                  offset,
                  cells,
                  dataStartIndex,
                });
            }
          }
        ),
        PanoramaContext = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        ),
        tooltipSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/tooltipSelectors.js'
        ),
        SetLegendPayload = __webpack_require__(
          './node_modules/recharts/es6/state/SetLegendPayload.js'
        ),
        useAnimationId = __webpack_require__('./node_modules/recharts/es6/util/useAnimationId.js'),
        util_resolveDefaultProps = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        RegisterGraphicalItemId = __webpack_require__(
          './node_modules/recharts/es6/context/RegisterGraphicalItemId.js'
        ),
        SetGraphicalItem = __webpack_require__(
          './node_modules/recharts/es6/state/SetGraphicalItem.js'
        ),
        svgPropertiesNoEvents = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesNoEvents.js'
        ),
        JavascriptAnimate = __webpack_require__(
          './node_modules/recharts/es6/animation/JavascriptAnimate.js'
        ),
        ZIndexLayer = __webpack_require__('./node_modules/recharts/es6/zIndex/ZIndexLayer.js'),
        DefaultZIndexes = __webpack_require__(
          './node_modules/recharts/es6/zIndex/DefaultZIndexes.js'
        );
      var util_propsAreEqual = __webpack_require__(
          './node_modules/recharts/es6/util/propsAreEqual.js'
        ),
        BarStack_excluded = ['index'];
      function BarStack_extends() {
        return (
          (BarStack_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          BarStack_extends.apply(null, arguments)
        );
      }
      var BarStackContext = (0, react.createContext)(void 0),
        getClipPathId = (stackId, index) =>
          'recharts-bar-stack-clip-path-'.concat(stackId, '-').concat(index),
        BarStackClipLayer = (_ref) => {
          var { index } = _ref,
            rest = (function BarStack_objectWithoutProperties(e, t) {
              if (null == e) return {};
              var o,
                r,
                i = (function BarStack_objectWithoutPropertiesLoose(r, e) {
                  if (null == r) return {};
                  var t = {};
                  for (var n in r)
                    if ({}.hasOwnProperty.call(r, n)) {
                      if (-1 !== e.indexOf(n)) continue;
                      t[n] = r[n];
                    }
                  return t;
                })(e, t);
              if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(e);
                for (r = 0; r < n.length; r++)
                  ((o = n[r]),
                    -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
              }
              return i;
            })(_ref, BarStack_excluded),
            clipPathUrl = ((index) => {
              var barStackContext = (0, react.useContext)(BarStackContext);
              if (null != barStackContext) {
                var { stackId } = barStackContext;
                return 'url(#'.concat(getClipPathId(stackId, index), ')');
              }
            })(index);
          return react.createElement(
            Layer.W,
            BarStack_extends({ className: 'recharts-bar-stack-layer', clipPath: clipPathUrl }, rest)
          );
        },
        Bar_excluded = ['onMouseEnter', 'onMouseLeave', 'onClick'],
        _excluded2 = ['value', 'background', 'tooltipPosition'],
        _excluded3 = ['id'],
        _excluded4 = ['onMouseEnter', 'onClick', 'onMouseLeave'];
      function Bar_extends() {
        return (
          (Bar_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          Bar_extends.apply(null, arguments)
        );
      }
      function Bar_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function Bar_objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? Bar_ownKeys(Object(t), !0).forEach(function (r) {
                Bar_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : Bar_ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function Bar_defineProperty(e, r, t) {
        return (
          (r = (function Bar_toPropertyKey(t) {
            var i = (function Bar_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function Bar_objectWithoutProperties(e, t) {
        if (null == e) return {};
        var o,
          r,
          i = (function Bar_objectWithoutPropertiesLoose(r, e) {
            if (null == r) return {};
            var t = {};
            for (var n in r)
              if ({}.hasOwnProperty.call(r, n)) {
                if (-1 !== e.indexOf(n)) continue;
                t[n] = r[n];
              }
            return t;
          })(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++)
            ((o = n[r]),
              -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
        }
        return i;
      }
      var computeLegendPayloadFromBarData = (props) => {
          var { dataKey, name, fill, legendType, hide } = props;
          return [
            {
              inactive: hide,
              dataKey,
              type: legendType,
              color: fill,
              value: (0, ChartUtils.uM)(name, dataKey),
              payload: props,
            },
          ];
        },
        SetBarTooltipEntrySettings = react.memo((_ref) => {
          var { dataKey, stroke, strokeWidth, fill, name, hide, unit, tooltipType, id } = _ref,
            tooltipEntrySettings = {
              dataDefinedOnItem: void 0,
              positions: void 0,
              settings: {
                stroke,
                strokeWidth,
                fill,
                dataKey,
                nameKey: void 0,
                name: (0, ChartUtils.uM)(name, dataKey),
                hide,
                type: tooltipType,
                color: fill,
                unit,
                graphicalItemId: id,
              },
            };
          return react.createElement(SetTooltipEntrySettings.r, { tooltipEntrySettings });
        });
      function BarBackground(props) {
        var activeIndex = (0, hooks.G)(tooltipSelectors.A2),
          { data, dataKey, background: backgroundFromProps, allOtherBarProps } = props,
          {
            onMouseEnter: onMouseEnterFromProps,
            onMouseLeave: onMouseLeaveFromProps,
            onClick: onItemClickFromProps,
          } = allOtherBarProps,
          restOfAllOtherProps = Bar_objectWithoutProperties(allOtherBarProps, Bar_excluded),
          onMouseEnterFromContext = (0, tooltipContext.Cj)(
            onMouseEnterFromProps,
            dataKey,
            allOtherBarProps.id
          ),
          onMouseLeaveFromContext = (0, tooltipContext.Pg)(onMouseLeaveFromProps),
          onClickFromContext = (0, tooltipContext.Ub)(
            onItemClickFromProps,
            dataKey,
            allOtherBarProps.id
          );
        if (!backgroundFromProps || null == data) return null;
        var input,
          defaultZIndex,
          backgroundProps = (0, svgPropertiesNoEvents.ic)(backgroundFromProps);
        return react.createElement(
          ZIndexLayer.g,
          {
            zIndex:
              ((input = backgroundFromProps),
              (defaultZIndex = DefaultZIndexes.I.barBackground),
              input &&
              'object' == typeof input &&
              'zIndex' in input &&
              'number' == typeof input.zIndex &&
              (0, isWellBehavedNumber.H)(input.zIndex)
                ? input.zIndex
                : defaultZIndex),
          },
          data.map((entry, i) => {
            var { value, background: backgroundFromDataEntry, tooltipPosition } = entry,
              rest = Bar_objectWithoutProperties(entry, _excluded2);
            if (!backgroundFromDataEntry) return null;
            var onMouseEnter = onMouseEnterFromContext(entry, i),
              onMouseLeave = onMouseLeaveFromContext(entry, i),
              onClick = onClickFromContext(entry, i),
              barRectangleProps = Bar_objectSpread(
                Bar_objectSpread(
                  Bar_objectSpread(
                    Bar_objectSpread(
                      Bar_objectSpread(
                        { option: backgroundFromProps, isActive: String(i) === activeIndex },
                        rest
                      ),
                      {},
                      { fill: '#eee' },
                      backgroundFromDataEntry
                    ),
                    backgroundProps
                  ),
                  (0, types.XC)(restOfAllOtherProps, entry, i)
                ),
                {},
                {
                  onMouseEnter,
                  onMouseLeave,
                  onClick,
                  dataKey,
                  index: i,
                  className: 'recharts-bar-background-rectangle',
                }
              );
            return react.createElement(
              BarRectangle,
              Bar_extends({ key: 'background-bar-'.concat(i) }, barRectangleProps)
            );
          })
        );
      }
      function BarLabelListProvider(_ref2) {
        var { showLabels, children, rects } = _ref2,
          labelListEntries =
            null == rects
              ? void 0
              : rects.map((entry) => {
                  var viewBox = {
                    x: entry.x,
                    y: entry.y,
                    width: entry.width,
                    lowerWidth: entry.width,
                    upperWidth: entry.width,
                    height: entry.height,
                  };
                  return Bar_objectSpread(
                    Bar_objectSpread({}, viewBox),
                    {},
                    {
                      value: entry.value,
                      payload: entry.payload,
                      parentViewBox: entry.parentViewBox,
                      viewBox,
                      fill: entry.fill,
                    }
                  );
                });
        return react.createElement(
          LabelList.h8,
          { value: showLabels ? labelListEntries : void 0 },
          children
        );
      }
      function BarRectangleWithActiveState(props) {
        var { shape, activeBar, baseProps, entry, index, dataKey } = props,
          activeIndex = (0, hooks.G)(tooltipSelectors.A2),
          activeDataKey = (0, hooks.G)(tooltipSelectors.Xb),
          isActive =
            activeBar &&
            String(index) === activeIndex &&
            (null == activeDataKey || dataKey === activeDataKey),
          option = isActive ? activeBar : shape;
        return isActive
          ? react.createElement(
              ZIndexLayer.g,
              { zIndex: DefaultZIndexes.I.activeBar },
              react.createElement(
                BarRectangle,
                Bar_extends({}, baseProps, { name: String(baseProps.name) }, entry, {
                  isActive,
                  option,
                  index,
                  dataKey,
                })
              )
            )
          : react.createElement(
              BarRectangle,
              Bar_extends({}, baseProps, { name: String(baseProps.name) }, entry, {
                isActive,
                option,
                index,
                dataKey,
              })
            );
      }
      function BarRectangleNeverActive(props) {
        var { shape, baseProps, entry, index, dataKey } = props;
        return react.createElement(
          BarRectangle,
          Bar_extends({}, baseProps, { name: String(baseProps.name) }, entry, {
            isActive: !1,
            option: shape,
            index,
            dataKey,
          })
        );
      }
      function BarRectangles(_ref3) {
        var _svgPropertiesNoEvent,
          { data, props } = _ref3,
          _ref4 =
            null !== (_svgPropertiesNoEvent = (0, svgPropertiesNoEvents.uZ)(props)) &&
            void 0 !== _svgPropertiesNoEvent
              ? _svgPropertiesNoEvent
              : {},
          { id } = _ref4,
          baseProps = Bar_objectWithoutProperties(_ref4, _excluded3),
          { shape, dataKey, activeBar } = props,
          {
            onMouseEnter: onMouseEnterFromProps,
            onClick: onItemClickFromProps,
            onMouseLeave: onMouseLeaveFromProps,
          } = props,
          restOfAllOtherProps = Bar_objectWithoutProperties(props, _excluded4),
          onMouseEnterFromContext = (0, tooltipContext.Cj)(onMouseEnterFromProps, dataKey, id),
          onMouseLeaveFromContext = (0, tooltipContext.Pg)(onMouseLeaveFromProps),
          onClickFromContext = (0, tooltipContext.Ub)(onItemClickFromProps, dataKey, id);
        return data
          ? react.createElement(
              react.Fragment,
              null,
              data.map((entry, i) =>
                react.createElement(
                  BarStackClipLayer,
                  Bar_extends(
                    {
                      index: i,
                      key: 'rectangle-'
                        .concat(null == entry ? void 0 : entry.x, '-')
                        .concat(null == entry ? void 0 : entry.y, '-')
                        .concat(null == entry ? void 0 : entry.value, '-')
                        .concat(i),
                      className: 'recharts-bar-rectangle',
                    },
                    (0, types.XC)(restOfAllOtherProps, entry, i),
                    {
                      onMouseEnter: onMouseEnterFromContext(entry, i),
                      onMouseLeave: onMouseLeaveFromContext(entry, i),
                      onClick: onClickFromContext(entry, i),
                    }
                  ),
                  activeBar
                    ? react.createElement(BarRectangleWithActiveState, {
                        shape,
                        activeBar,
                        baseProps,
                        entry,
                        index: i,
                        dataKey,
                      })
                    : react.createElement(BarRectangleNeverActive, {
                        shape,
                        baseProps,
                        entry,
                        index: i,
                        dataKey,
                      })
                )
              )
            )
          : null;
      }
      function RectanglesWithAnimation(_ref5) {
        var { props, previousRectanglesRef } = _ref5,
          {
            data,
            layout,
            isAnimationActive,
            animationBegin,
            animationDuration,
            animationEasing,
            onAnimationEnd,
            onAnimationStart,
          } = props,
          prevData = previousRectanglesRef.current,
          animationId = (0, useAnimationId.n)(props, 'recharts-bar-'),
          [isAnimating, setIsAnimating] = (0, react.useState)(!1),
          showLabels = !isAnimating,
          handleAnimationEnd = (0, react.useCallback)(() => {
            ('function' == typeof onAnimationEnd && onAnimationEnd(), setIsAnimating(!1));
          }, [onAnimationEnd]),
          handleAnimationStart = (0, react.useCallback)(() => {
            ('function' == typeof onAnimationStart && onAnimationStart(), setIsAnimating(!0));
          }, [onAnimationStart]);
        return react.createElement(
          BarLabelListProvider,
          { showLabels, rects: data },
          react.createElement(
            JavascriptAnimate.J,
            {
              animationId,
              begin: animationBegin,
              duration: animationDuration,
              isActive: isAnimationActive,
              easing: animationEasing,
              onAnimationEnd: handleAnimationEnd,
              onAnimationStart: handleAnimationStart,
              key: animationId,
            },
            (t) => {
              var stepData =
                1 === t
                  ? data
                  : null == data
                    ? void 0
                    : data.map((entry, index) => {
                        var prev = prevData && prevData[index];
                        if (prev)
                          return Bar_objectSpread(
                            Bar_objectSpread({}, entry),
                            {},
                            {
                              x: (0, DataUtils.GW)(prev.x, entry.x, t),
                              y: (0, DataUtils.GW)(prev.y, entry.y, t),
                              width: (0, DataUtils.GW)(prev.width, entry.width, t),
                              height: (0, DataUtils.GW)(prev.height, entry.height, t),
                            }
                          );
                        if ('horizontal' === layout) {
                          var height = (0, DataUtils.GW)(0, entry.height, t),
                            y = (0, DataUtils.GW)(entry.stackedBarStart, entry.y, t);
                          return Bar_objectSpread(Bar_objectSpread({}, entry), {}, { y, height });
                        }
                        var w = (0, DataUtils.GW)(0, entry.width, t),
                          x = (0, DataUtils.GW)(entry.stackedBarStart, entry.x, t);
                        return Bar_objectSpread(Bar_objectSpread({}, entry), {}, { width: w, x });
                      });
              return (
                t > 0 && (previousRectanglesRef.current = null != stepData ? stepData : null),
                null == stepData
                  ? null
                  : react.createElement(
                      Layer.W,
                      null,
                      react.createElement(BarRectangles, { props, data: stepData })
                    )
              );
            }
          ),
          react.createElement(LabelList.qY, { label: props.label }),
          props.children
        );
      }
      function RenderRectangles(props) {
        var previousRectanglesRef = (0, react.useRef)(null);
        return react.createElement(RectanglesWithAnimation, { previousRectanglesRef, props });
      }
      var errorBarDataPointFormatter = (dataPoint, dataKey) => {
        var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;
        return {
          x: dataPoint.x,
          y: dataPoint.y,
          value,
          errorVal: (0, ChartUtils.kr)(dataPoint, dataKey),
        };
      };
      class BarWithState extends react.PureComponent {
        render() {
          var { hide, data, dataKey, className, xAxisId, yAxisId, needClip, background, id } =
            this.props;
          if (hide || null == data) return null;
          var layerClass = (0, clsx.$)('recharts-bar', className),
            clipPathId = id;
          return react.createElement(
            Layer.W,
            { className: layerClass, id },
            needClip &&
              react.createElement(
                'defs',
                null,
                react.createElement(GraphicalItemClipPath, { clipPathId, xAxisId, yAxisId })
              ),
            react.createElement(
              Layer.W,
              {
                className: 'recharts-bar-rectangles',
                clipPath: needClip ? 'url(#clipPath-'.concat(clipPathId, ')') : void 0,
              },
              react.createElement(BarBackground, {
                data,
                dataKey,
                background,
                allOtherBarProps: this.props,
              }),
              react.createElement(RenderRectangles, this.props)
            )
          );
        }
      }
      var defaultBarProps = {
        activeBar: !1,
        animationBegin: 0,
        animationDuration: 400,
        animationEasing: 'ease',
        background: !1,
        hide: !1,
        isAnimationActive: 'auto',
        label: !1,
        legendType: 'rect',
        minPointSize: 0,
        xAxisId: 0,
        yAxisId: 0,
        zIndex: DefaultZIndexes.I.bar,
      };
      function BarImpl(props) {
        var errorBarOffset,
          {
            xAxisId,
            yAxisId,
            hide,
            legendType,
            minPointSize,
            activeBar,
            animationBegin,
            animationDuration,
            animationEasing,
            isAnimationActive,
          } = props,
          { needClip } = useNeedsClip(xAxisId, yAxisId),
          layout = (0, chartLayoutContext.WX)(),
          isPanorama = (0, PanoramaContext.r)(),
          cells = (0, ReactUtils.aS)(props.children, Cell.f),
          rects = (0, hooks.G)((state) => selectBarRectangles(state, props.id, isPanorama, cells));
        if ('vertical' !== layout && 'horizontal' !== layout) return null;
        var firstDataPoint = null == rects ? void 0 : rects[0];
        return (
          (errorBarOffset =
            null == firstDataPoint || null == firstDataPoint.height || null == firstDataPoint.width
              ? 0
              : 'vertical' === layout
                ? firstDataPoint.height / 2
                : firstDataPoint.width / 2),
          react.createElement(
            SetErrorBarContext,
            {
              xAxisId,
              yAxisId,
              data: rects,
              dataPointFormatter: errorBarDataPointFormatter,
              errorBarOffset,
            },
            react.createElement(
              BarWithState,
              Bar_extends({}, props, {
                layout,
                needClip,
                data: rects,
                xAxisId,
                yAxisId,
                hide,
                legendType,
                minPointSize,
                activeBar,
                animationBegin,
                animationDuration,
                animationEasing,
                isAnimationActive,
              })
            )
          )
        );
      }
      function computeBarRectangles(_ref6) {
        var {
            layout,
            barSettings: { dataKey, minPointSize: minPointSizeProp },
            pos,
            bandSize,
            xAxis,
            yAxis,
            xAxisTicks,
            yAxisTicks,
            stackedData,
            displayedData,
            offset,
            cells,
            parentViewBox,
            dataStartIndex,
          } = _ref6,
          numericAxis = 'horizontal' === layout ? yAxis : xAxis,
          stackedDomain = stackedData ? numericAxis.scale.domain() : null,
          baseValue = (0, ChartUtils.DW)({ numericAxis }),
          stackedBarStart = numericAxis.scale(baseValue);
        return displayedData
          .map((entry, index) => {
            var value, x, y, width, height, background;
            if (stackedData) {
              var untruncatedValue = stackedData[index + dataStartIndex];
              if (null == untruncatedValue) return null;
              value = (0, ChartUtils._f)(untruncatedValue, stackedDomain);
            } else
              ((value = (0, ChartUtils.kr)(entry, dataKey)),
                Array.isArray(value) || (value = [baseValue, value]));
            var minPointSize = minPointSizeCallback(minPointSizeProp, 0)(value[1], index);
            if ('horizontal' === layout) {
              var _ref7,
                [baseValueScale, currentValueScale] = [
                  yAxis.scale(value[0]),
                  yAxis.scale(value[1]),
                ];
              ((x = (0, ChartUtils.y2)({
                axis: xAxis,
                ticks: xAxisTicks,
                bandSize,
                offset: pos.offset,
                entry,
                index,
              })),
                (y =
                  null !==
                    (_ref7 = null != currentValueScale ? currentValueScale : baseValueScale) &&
                  void 0 !== _ref7
                    ? _ref7
                    : void 0),
                (width = pos.size));
              var computedHeight = baseValueScale - currentValueScale;
              if (
                ((height = (0, DataUtils.M8)(computedHeight) ? 0 : computedHeight),
                (background = { x, y: offset.top, width, height: offset.height }),
                Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize))
              ) {
                var delta =
                  (0, DataUtils.sA)(height || minPointSize) *
                  (Math.abs(minPointSize) - Math.abs(height));
                ((y -= delta), (height += delta));
              }
            } else {
              var [_baseValueScale, _currentValueScale] = [
                xAxis.scale(value[0]),
                xAxis.scale(value[1]),
              ];
              if (
                ((x = _baseValueScale),
                (y = (0, ChartUtils.y2)({
                  axis: yAxis,
                  ticks: yAxisTicks,
                  bandSize,
                  offset: pos.offset,
                  entry,
                  index,
                })),
                (width = _currentValueScale - _baseValueScale),
                (height = pos.size),
                (background = { x: offset.left, y, width: offset.width, height }),
                Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize))
              )
                width +=
                  (0, DataUtils.sA)(width || minPointSize) *
                  (Math.abs(minPointSize) - Math.abs(width));
            }
            return null == x || null == y || null == width || null == height
              ? null
              : Bar_objectSpread(
                  Bar_objectSpread({}, entry),
                  {},
                  {
                    stackedBarStart,
                    x,
                    y,
                    width,
                    height,
                    value: stackedData ? value : value[1],
                    payload: entry,
                    background,
                    tooltipPosition: { x: x + width / 2, y: y + height / 2 },
                    parentViewBox,
                  },
                  cells && cells[index] && cells[index].props
                );
          })
          .filter(Boolean);
      }
      function BarFn(outsideProps) {
        var childStackId,
          stackSettings,
          props = (0, util_resolveDefaultProps.e)(outsideProps, defaultBarProps),
          stackId =
            ((childStackId = props.stackId),
            null != (stackSettings = (0, react.useContext)(BarStackContext))
              ? stackSettings.stackId
              : null != childStackId
                ? (0, ChartUtils.$8)(childStackId)
                : void 0),
          isPanorama = (0, PanoramaContext.r)();
        return react.createElement(RegisterGraphicalItemId.x, { id: props.id, type: 'bar' }, (id) =>
          react.createElement(
            react.Fragment,
            null,
            react.createElement(SetLegendPayload.A, {
              legendPayload: computeLegendPayloadFromBarData(props),
            }),
            react.createElement(SetBarTooltipEntrySettings, {
              dataKey: props.dataKey,
              stroke: props.stroke,
              strokeWidth: props.strokeWidth,
              fill: props.fill,
              name: props.name,
              hide: props.hide,
              unit: props.unit,
              tooltipType: props.tooltipType,
              id,
            }),
            react.createElement(SetGraphicalItem.p, {
              type: 'bar',
              id,
              data: void 0,
              xAxisId: props.xAxisId,
              yAxisId: props.yAxisId,
              zAxisId: 0,
              dataKey: props.dataKey,
              stackId,
              hide: props.hide,
              barSize: props.barSize,
              minPointSize: props.minPointSize,
              maxBarSize: props.maxBarSize,
              isPanorama,
            }),
            react.createElement(
              ZIndexLayer.g,
              { zIndex: props.zIndex },
              react.createElement(BarImpl, Bar_extends({}, props, { id }))
            )
          )
        );
      }
      var Bar = react.memo(BarFn, util_propsAreEqual.P);
      Bar.displayName = 'Bar';
    },
    './node_modules/recharts/es6/cartesian/CartesianAxis.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        u: () => CartesianAxis,
        F: () => defaultCartesianAxisProps,
      });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        get = __webpack_require__('./node_modules/es-toolkit/compat/get.js'),
        get_default = __webpack_require__.n(get),
        clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
        Layer = __webpack_require__('./node_modules/recharts/es6/container/Layer.js'),
        Text = __webpack_require__('./node_modules/recharts/es6/component/Text.js'),
        Label = __webpack_require__('./node_modules/recharts/es6/component/Label.js'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        types = __webpack_require__('./node_modules/recharts/es6/util/types.js'),
        DOMUtils = __webpack_require__('./node_modules/recharts/es6/util/DOMUtils.js'),
        Global = __webpack_require__('./node_modules/recharts/es6/util/Global.js');
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      class ScaleHelper {
        static create(obj) {
          return new ScaleHelper(obj);
        }
        constructor(scale) {
          this.scale = scale;
        }
        get domain() {
          return this.scale.domain;
        }
        get range() {
          return this.scale.range;
        }
        get rangeMin() {
          return this.range()[0];
        }
        get rangeMax() {
          return this.range()[1];
        }
        get bandwidth() {
          return this.scale.bandwidth;
        }
        apply(value) {
          var { bandAware, position } =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (void 0 !== value) {
            if (position)
              switch (position) {
                case 'start':
                default:
                  return this.scale(value);
                case 'middle':
                  var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
                  return this.scale(value) + offset;
                case 'end':
                  var _offset = this.bandwidth ? this.bandwidth() : 0;
                  return this.scale(value) + _offset;
              }
            if (bandAware) {
              var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
              return this.scale(value) + _offset2;
            }
            return this.scale(value);
          }
        }
        isInRange(value) {
          var range = this.range(),
            first = range[0],
            last = range[range.length - 1];
          return first <= last ? value >= first && value <= last : value >= last && value <= first;
        }
      }
      _defineProperty(ScaleHelper, 'EPS', 1e-4);
      function getEveryNth(array, n) {
        if (n < 1) return [];
        if (1 === n) return array;
        for (var result = [], i = 0; i < array.length; i += n) {
          var item = array[i];
          void 0 !== item && result.push(item);
        }
        return result;
      }
      function getAngledTickWidth(contentSize, unitSize, angle) {
        return (function getAngledRectangleWidth(_ref5) {
          var { width, height } = _ref5,
            normalizedAngle = (function normalizeAngle(angle) {
              return ((angle % 180) + 180) % 180;
            })(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0),
            angleRadians = (normalizedAngle * Math.PI) / 180,
            angleThreshold = Math.atan(height / width),
            angledWidth =
              angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold
                ? height / Math.sin(angleRadians)
                : width / Math.cos(angleRadians);
          return Math.abs(angledWidth);
        })(
          {
            width: contentSize.width + unitSize.width,
            height: contentSize.height + unitSize.height,
          },
          angle
        );
      }
      function isVisible(sign, tickPosition, getSize, start, end) {
        if (sign * tickPosition < sign * start || sign * tickPosition > sign * end) return !1;
        var size = getSize();
        return (
          sign * (tickPosition - (sign * size) / 2 - start) >= 0 &&
          sign * (tickPosition + (sign * size) / 2 - end) <= 0
        );
      }
      function getTicks_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function getTicks_objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? getTicks_ownKeys(Object(t), !0).forEach(function (r) {
                getTicks_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : getTicks_ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function getTicks_defineProperty(e, r, t) {
        return (
          (r = (function getTicks_toPropertyKey(t) {
            var i = (function getTicks_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function getTicks(props, fontSize, letterSpacing) {
        var _getNumberIntervalTic,
          { tick, ticks, viewBox, minTickGap, orientation, interval, tickFormatter, unit, angle } =
            props;
        if (!ticks || !ticks.length || !tick) return [];
        if ((0, DataUtils.Et)(interval) || Global.m.isSsr)
          return null !==
            (_getNumberIntervalTic = (function getNumberIntervalTicks(ticks, interval) {
              return getEveryNth(ticks, interval + 1);
            })(ticks, (0, DataUtils.Et)(interval) ? interval : 0)) &&
            void 0 !== _getNumberIntervalTic
            ? _getNumberIntervalTic
            : [];
        var candidates = [],
          sizeKey = 'top' === orientation || 'bottom' === orientation ? 'width' : 'height',
          unitSize =
            unit && 'width' === sizeKey
              ? (0, DOMUtils.Pu)(unit, { fontSize, letterSpacing })
              : { width: 0, height: 0 },
          getTickSize = (content, index) => {
            var value =
              'function' == typeof tickFormatter
                ? tickFormatter(content.value, index)
                : content.value;
            return 'width' === sizeKey
              ? getAngledTickWidth(
                  (0, DOMUtils.Pu)(value, { fontSize, letterSpacing }),
                  unitSize,
                  angle
                )
              : (0, DOMUtils.Pu)(value, { fontSize, letterSpacing })[sizeKey];
          },
          sign =
            ticks.length >= 2 ? (0, DataUtils.sA)(ticks[1].coordinate - ticks[0].coordinate) : 1,
          boundaries = (function getTickBoundaries(viewBox, sign, sizeKey) {
            var isWidth = 'width' === sizeKey,
              { x, y, width, height } = viewBox;
            return 1 === sign
              ? { start: isWidth ? x : y, end: isWidth ? x + width : y + height }
              : { start: isWidth ? x + width : y + height, end: isWidth ? x : y };
          })(viewBox, sign, sizeKey);
        return 'equidistantPreserveStart' === interval
          ? (function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {
              for (
                var _ret,
                  result = (ticks || []).slice(),
                  { start: initialStart, end } = boundaries,
                  index = 0,
                  stepsize = 1,
                  start = initialStart,
                  _loop = function _loop() {
                    var entry = null == ticks ? void 0 : ticks[index];
                    if (void 0 === entry) return { v: getEveryNth(ticks, stepsize) };
                    var size,
                      i = index,
                      getSize = () => (void 0 === size && (size = getTickSize(entry, i)), size),
                      tickCoord = entry.coordinate,
                      isShow = 0 === index || isVisible(sign, tickCoord, getSize, start, end);
                    (isShow || ((index = 0), (start = initialStart), (stepsize += 1)),
                      isShow &&
                        ((start = tickCoord + sign * (getSize() / 2 + minTickGap)),
                        (index += stepsize)));
                  };
                stepsize <= result.length;
              )
                if ((_ret = _loop())) return _ret.v;
              return [];
            })(sign, boundaries, getTickSize, ticks, minTickGap)
          : 'equidistantPreserveEnd' === interval
            ? (function getEquidistantPreserveEndTicks(
                sign,
                boundaries,
                getTickSize,
                ticks,
                minTickGap
              ) {
                var len = (ticks || []).slice().length;
                if (0 === len) return [];
                for (
                  var { start: initialStart, end } = boundaries, stepsize = 1;
                  stepsize <= len;
                  stepsize++
                ) {
                  for (
                    var offset = (len - 1) % stepsize,
                      start = initialStart,
                      ok = !0,
                      _loop2 = function _loop2() {
                        var size,
                          entry = ticks[index],
                          i = index,
                          getSize = () => (void 0 === size && (size = getTickSize(entry, i)), size),
                          tickCoord = entry.coordinate,
                          isShow =
                            index === offset || isVisible(sign, tickCoord, getSize, start, end);
                        if (!isShow) return ((ok = !1), 1);
                        isShow && (start = tickCoord + sign * (getSize() / 2 + minTickGap));
                      },
                      index = offset;
                    index < len && !_loop2();
                    index += stepsize
                  );
                  if (ok) {
                    for (var finalTicks = [], _index = offset; _index < len; _index += stepsize)
                      finalTicks.push(ticks[_index]);
                    return finalTicks;
                  }
                }
                return [];
              })(sign, boundaries, getTickSize, ticks, minTickGap)
            : ((candidates =
                'preserveStart' === interval || 'preserveStartEnd' === interval
                  ? (function getTicksStart(
                      sign,
                      boundaries,
                      getTickSize,
                      ticks,
                      minTickGap,
                      preserveEnd
                    ) {
                      var result = (ticks || []).slice(),
                        len = result.length,
                        { start, end } = boundaries;
                      if (preserveEnd) {
                        var tail = ticks[len - 1],
                          tailSize = getTickSize(tail, len - 1),
                          tailGap = sign * (tail.coordinate + (sign * tailSize) / 2 - end);
                        ((result[len - 1] = tail =
                          getTicks_objectSpread(
                            getTicks_objectSpread({}, tail),
                            {},
                            {
                              tickCoord:
                                tailGap > 0 ? tail.coordinate - tailGap * sign : tail.coordinate,
                            }
                          )),
                          null != tail.tickCoord &&
                            isVisible(sign, tail.tickCoord, () => tailSize, start, end) &&
                            ((end = tail.tickCoord - sign * (tailSize / 2 + minTickGap)),
                            (result[len - 1] = getTicks_objectSpread(
                              getTicks_objectSpread({}, tail),
                              {},
                              { isShow: !0 }
                            ))));
                      }
                      for (
                        var count = preserveEnd ? len - 1 : len,
                          _loop2 = function _loop2(i) {
                            var size,
                              entry = result[i],
                              getSize = () => (
                                void 0 === size && (size = getTickSize(entry, i)),
                                size
                              );
                            if (0 === i) {
                              var gap = sign * (entry.coordinate - (sign * getSize()) / 2 - start);
                              result[i] = entry = getTicks_objectSpread(
                                getTicks_objectSpread({}, entry),
                                {},
                                {
                                  tickCoord:
                                    gap < 0 ? entry.coordinate - gap * sign : entry.coordinate,
                                }
                              );
                            } else
                              result[i] = entry = getTicks_objectSpread(
                                getTicks_objectSpread({}, entry),
                                {},
                                { tickCoord: entry.coordinate }
                              );
                            null != entry.tickCoord &&
                              isVisible(sign, entry.tickCoord, getSize, start, end) &&
                              ((start = entry.tickCoord + sign * (getSize() / 2 + minTickGap)),
                              (result[i] = getTicks_objectSpread(
                                getTicks_objectSpread({}, entry),
                                {},
                                { isShow: !0 }
                              )));
                          },
                          i = 0;
                        i < count;
                        i++
                      )
                        _loop2(i);
                      return result;
                    })(
                      sign,
                      boundaries,
                      getTickSize,
                      ticks,
                      minTickGap,
                      'preserveStartEnd' === interval
                    )
                  : (function getTicksEnd(sign, boundaries, getTickSize, ticks, minTickGap) {
                      for (
                        var result = (ticks || []).slice(),
                          len = result.length,
                          { start } = boundaries,
                          { end } = boundaries,
                          _loop = function _loop(i) {
                            var size,
                              entry = result[i],
                              getSize = () => (
                                void 0 === size && (size = getTickSize(entry, i)),
                                size
                              );
                            if (i === len - 1) {
                              var gap = sign * (entry.coordinate + (sign * getSize()) / 2 - end);
                              result[i] = entry = getTicks_objectSpread(
                                getTicks_objectSpread({}, entry),
                                {},
                                {
                                  tickCoord:
                                    gap > 0 ? entry.coordinate - gap * sign : entry.coordinate,
                                }
                              );
                            } else
                              result[i] = entry = getTicks_objectSpread(
                                getTicks_objectSpread({}, entry),
                                {},
                                { tickCoord: entry.coordinate }
                              );
                            null != entry.tickCoord &&
                              isVisible(sign, entry.tickCoord, getSize, start, end) &&
                              ((end = entry.tickCoord - sign * (getSize() / 2 + minTickGap)),
                              (result[i] = getTicks_objectSpread(
                                getTicks_objectSpread({}, entry),
                                {},
                                { isShow: !0 }
                              )));
                          },
                          i = len - 1;
                        i >= 0;
                        i--
                      )
                        _loop(i);
                      return result;
                    })(sign, boundaries, getTickSize, ticks, minTickGap)),
              candidates.filter((entry) => entry.isShow));
      }
      var svgPropertiesNoEvents = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesNoEvents.js'
        ),
        resolveDefaultProps = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        ZIndexLayer = __webpack_require__('./node_modules/recharts/es6/zIndex/ZIndexLayer.js'),
        DefaultZIndexes = __webpack_require__(
          './node_modules/recharts/es6/zIndex/DefaultZIndexes.js'
        ),
        _excluded = ['axisLine', 'width', 'height', 'className', 'hide', 'ticks', 'axisType'];
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function CartesianAxis_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function CartesianAxis_objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? CartesianAxis_ownKeys(Object(t), !0).forEach(function (r) {
                CartesianAxis_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : CartesianAxis_ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function CartesianAxis_defineProperty(e, r, t) {
        return (
          (r = (function CartesianAxis_toPropertyKey(t) {
            var i = (function CartesianAxis_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var defaultCartesianAxisProps = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        viewBox: { x: 0, y: 0, width: 0, height: 0 },
        orientation: 'bottom',
        ticks: [],
        stroke: '#666',
        tickLine: !0,
        axisLine: !0,
        tick: !0,
        mirror: !1,
        minTickGap: 5,
        tickSize: 6,
        tickMargin: 2,
        interval: 'preserveEnd',
        zIndex: DefaultZIndexes.I.axis,
      };
      function AxisLine(axisLineProps) {
        var { x, y, width, height, orientation, mirror, axisLine, otherSvgProps } = axisLineProps;
        if (!axisLine) return null;
        var props = CartesianAxis_objectSpread(
          CartesianAxis_objectSpread(
            CartesianAxis_objectSpread({}, otherSvgProps),
            (0, svgPropertiesNoEvents.uZ)(axisLine)
          ),
          {},
          { fill: 'none' }
        );
        if ('top' === orientation || 'bottom' === orientation) {
          var needHeight = +(
            ('top' === orientation && !mirror) ||
            ('bottom' === orientation && mirror)
          );
          props = CartesianAxis_objectSpread(
            CartesianAxis_objectSpread({}, props),
            {},
            { x1: x, y1: y + needHeight * height, x2: x + width, y2: y + needHeight * height }
          );
        } else {
          var needWidth = +(
            ('left' === orientation && !mirror) ||
            ('right' === orientation && mirror)
          );
          props = CartesianAxis_objectSpread(
            CartesianAxis_objectSpread({}, props),
            {},
            { x1: x + needWidth * width, y1: y, x2: x + needWidth * width, y2: y + height }
          );
        }
        return react.createElement(
          'line',
          _extends({}, props, {
            className: (0, clsx.$)(
              'recharts-cartesian-axis-line',
              get_default()(axisLine, 'className')
            ),
          })
        );
      }
      function TickItem(props) {
        var tickItem,
          { option, tickProps, value } = props,
          combinedClassName = (0, clsx.$)(
            tickProps.className,
            'recharts-cartesian-axis-tick-value'
          );
        if (react.isValidElement(option))
          tickItem = react.cloneElement(
            option,
            CartesianAxis_objectSpread(
              CartesianAxis_objectSpread({}, tickProps),
              {},
              { className: combinedClassName }
            )
          );
        else if ('function' == typeof option)
          tickItem = option(
            CartesianAxis_objectSpread(
              CartesianAxis_objectSpread({}, tickProps),
              {},
              { className: combinedClassName }
            )
          );
        else {
          var className = 'recharts-cartesian-axis-tick-value';
          ('boolean' != typeof option &&
            (className = (0, clsx.$)(className, null == option ? void 0 : option.className)),
            (tickItem = react.createElement(
              Text.EY,
              _extends({}, tickProps, { className }),
              value
            )));
        }
        return tickItem;
      }
      var Ticks = (0, react.forwardRef)((props, ref) => {
          var {
              ticks = [],
              tick,
              tickLine,
              stroke,
              tickFormatter,
              unit,
              padding,
              tickTextProps,
              orientation,
              mirror,
              x,
              y,
              width,
              height,
              tickSize,
              tickMargin,
              fontSize,
              letterSpacing,
              getTicksConfig,
              events,
              axisType,
            } = props,
            finalTicks = getTicks(
              CartesianAxis_objectSpread(
                CartesianAxis_objectSpread({}, getTicksConfig),
                {},
                { ticks }
              ),
              fontSize,
              letterSpacing
            ),
            textAnchor = (function getTickTextAnchor(orientation, mirror) {
              switch (orientation) {
                case 'left':
                  return mirror ? 'start' : 'end';
                case 'right':
                  return mirror ? 'end' : 'start';
                default:
                  return 'middle';
              }
            })(orientation, mirror),
            verticalAnchor = (function getTickVerticalAnchor(orientation, mirror) {
              switch (orientation) {
                case 'left':
                case 'right':
                  return 'middle';
                case 'top':
                  return mirror ? 'start' : 'end';
                default:
                  return mirror ? 'end' : 'start';
              }
            })(orientation, mirror),
            axisProps = (0, svgPropertiesNoEvents.uZ)(getTicksConfig),
            customTickProps = (0, svgPropertiesNoEvents.ic)(tick),
            tickLinePropsObject = {};
          'object' == typeof tickLine && (tickLinePropsObject = tickLine);
          var tickLineProps = CartesianAxis_objectSpread(
              CartesianAxis_objectSpread({}, axisProps),
              {},
              { fill: 'none' },
              tickLinePropsObject
            ),
            tickLineCoords = finalTicks.map((entry) =>
              CartesianAxis_objectSpread(
                { entry },
                (function getTickLineCoord(
                  data,
                  x,
                  y,
                  width,
                  height,
                  orientation,
                  tickSize,
                  mirror,
                  tickMargin
                ) {
                  var x1,
                    x2,
                    y1,
                    y2,
                    tx,
                    ty,
                    sign = mirror ? -1 : 1,
                    finalTickSize = data.tickSize || tickSize,
                    tickCoord = (0, DataUtils.Et)(data.tickCoord)
                      ? data.tickCoord
                      : data.coordinate;
                  switch (orientation) {
                    case 'top':
                      ((x1 = x2 = data.coordinate),
                        (ty =
                          (y1 = (y2 = y + +!mirror * height) - sign * finalTickSize) -
                          sign * tickMargin),
                        (tx = tickCoord));
                      break;
                    case 'left':
                      ((y1 = y2 = data.coordinate),
                        (tx =
                          (x1 = (x2 = x + +!mirror * width) - sign * finalTickSize) -
                          sign * tickMargin),
                        (ty = tickCoord));
                      break;
                    case 'right':
                      ((y1 = y2 = data.coordinate),
                        (tx =
                          (x1 = (x2 = x + +mirror * width) + sign * finalTickSize) +
                          sign * tickMargin),
                        (ty = tickCoord));
                      break;
                    default:
                      ((x1 = x2 = data.coordinate),
                        (ty =
                          (y1 = (y2 = y + +mirror * height) + sign * finalTickSize) +
                          sign * tickMargin),
                        (tx = tickCoord));
                  }
                  return { line: { x1, y1, x2, y2 }, tick: { x: tx, y: ty } };
                })(entry, x, y, width, height, orientation, tickSize, mirror, tickMargin)
              )
            ),
            tickLines = tickLineCoords.map((_ref) => {
              var { entry, line: lineCoord } = _ref;
              return react.createElement(
                Layer.W,
                {
                  className: 'recharts-cartesian-axis-tick',
                  key: 'tick-'
                    .concat(entry.value, '-')
                    .concat(entry.coordinate, '-')
                    .concat(entry.tickCoord),
                },
                tickLine &&
                  react.createElement(
                    'line',
                    _extends({}, tickLineProps, lineCoord, {
                      className: (0, clsx.$)(
                        'recharts-cartesian-axis-tick-line',
                        get_default()(tickLine, 'className')
                      ),
                    })
                  )
              );
            }),
            tickLabels = tickLineCoords.map((_ref2, i) => {
              var { entry, tick: tickCoord } = _ref2,
                tickProps = CartesianAxis_objectSpread(
                  CartesianAxis_objectSpread(
                    CartesianAxis_objectSpread(
                      CartesianAxis_objectSpread({ textAnchor, verticalAnchor }, axisProps),
                      {},
                      { stroke: 'none', fill: stroke },
                      customTickProps
                    ),
                    tickCoord
                  ),
                  {},
                  {
                    index: i,
                    payload: entry,
                    visibleTicksCount: finalTicks.length,
                    tickFormatter,
                    padding,
                  },
                  tickTextProps
                );
              return react.createElement(
                Layer.W,
                _extends(
                  {
                    className: 'recharts-cartesian-axis-tick-label',
                    key: 'tick-label-'
                      .concat(entry.value, '-')
                      .concat(entry.coordinate, '-')
                      .concat(entry.tickCoord),
                  },
                  (0, types.XC)(events, entry, i)
                ),
                tick &&
                  react.createElement(TickItem, {
                    option: tick,
                    tickProps,
                    value: ''
                      .concat(
                        'function' == typeof tickFormatter
                          ? tickFormatter(entry.value, i)
                          : entry.value
                      )
                      .concat(unit || ''),
                  })
              );
            });
          return react.createElement(
            'g',
            { className: 'recharts-cartesian-axis-ticks recharts-'.concat(axisType, '-ticks') },
            tickLabels.length > 0 &&
              react.createElement(
                ZIndexLayer.g,
                { zIndex: DefaultZIndexes.I.label },
                react.createElement(
                  'g',
                  {
                    className: 'recharts-cartesian-axis-tick-labels recharts-'.concat(
                      axisType,
                      '-tick-labels'
                    ),
                    ref,
                  },
                  tickLabels
                )
              ),
            tickLines.length > 0 &&
              react.createElement(
                'g',
                {
                  className: 'recharts-cartesian-axis-tick-lines recharts-'.concat(
                    axisType,
                    '-tick-lines'
                  ),
                },
                tickLines
              )
          );
        }),
        CartesianAxisComponent = (0, react.forwardRef)((props, ref) => {
          var { axisLine, width, height, className, hide, ticks, axisType } = props,
            rest = (function _objectWithoutProperties(e, t) {
              if (null == e) return {};
              var o,
                r,
                i = (function _objectWithoutPropertiesLoose(r, e) {
                  if (null == r) return {};
                  var t = {};
                  for (var n in r)
                    if ({}.hasOwnProperty.call(r, n)) {
                      if (-1 !== e.indexOf(n)) continue;
                      t[n] = r[n];
                    }
                  return t;
                })(e, t);
              if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(e);
                for (r = 0; r < n.length; r++)
                  ((o = n[r]),
                    -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
              }
              return i;
            })(props, _excluded),
            [fontSize, setFontSize] = (0, react.useState)(''),
            [letterSpacing, setLetterSpacing] = (0, react.useState)(''),
            tickRefs = (0, react.useRef)(null);
          (0, react.useImperativeHandle)(ref, () => ({
            getCalculatedWidth: () => {
              var _props$labelRef;
              return ((_ref) => {
                var { ticks, label, labelGapWithTick = 5, tickSize = 0, tickMargin = 0 } = _ref,
                  maxTickWidth = 0;
                if (ticks) {
                  Array.from(ticks).forEach((tickNode) => {
                    if (tickNode) {
                      var bbox = tickNode.getBoundingClientRect();
                      bbox.width > maxTickWidth && (maxTickWidth = bbox.width);
                    }
                  });
                  var labelWidth = label ? label.getBoundingClientRect().width : 0,
                    updatedYAxisWidth =
                      maxTickWidth +
                      (tickSize + tickMargin) +
                      labelWidth +
                      (label ? labelGapWithTick : 0);
                  return Math.round(updatedYAxisWidth);
                }
                return 0;
              })({
                ticks: tickRefs.current,
                label:
                  null === (_props$labelRef = props.labelRef) || void 0 === _props$labelRef
                    ? void 0
                    : _props$labelRef.current,
                labelGapWithTick: 5,
                tickSize: props.tickSize,
                tickMargin: props.tickMargin,
              });
            },
          }));
          var layerRef = (0, react.useCallback)(
            (el) => {
              if (el) {
                var tickNodes = el.getElementsByClassName('recharts-cartesian-axis-tick-value');
                tickRefs.current = tickNodes;
                var tick = tickNodes[0];
                if (tick) {
                  var computedStyle = window.getComputedStyle(tick),
                    calculatedFontSize = computedStyle.fontSize,
                    calculatedLetterSpacing = computedStyle.letterSpacing;
                  (calculatedFontSize === fontSize && calculatedLetterSpacing === letterSpacing) ||
                    (setFontSize(calculatedFontSize), setLetterSpacing(calculatedLetterSpacing));
                }
              }
            },
            [fontSize, letterSpacing]
          );
          return hide || (null != width && width <= 0) || (null != height && height <= 0)
            ? null
            : react.createElement(
                ZIndexLayer.g,
                { zIndex: props.zIndex },
                react.createElement(
                  Layer.W,
                  { className: (0, clsx.$)('recharts-cartesian-axis', className) },
                  react.createElement(AxisLine, {
                    x: props.x,
                    y: props.y,
                    width,
                    height,
                    orientation: props.orientation,
                    mirror: props.mirror,
                    axisLine,
                    otherSvgProps: (0, svgPropertiesNoEvents.uZ)(props),
                  }),
                  react.createElement(Ticks, {
                    ref: layerRef,
                    axisType,
                    events: rest,
                    fontSize,
                    getTicksConfig: props,
                    height: props.height,
                    letterSpacing,
                    mirror: props.mirror,
                    orientation: props.orientation,
                    padding: props.padding,
                    stroke: props.stroke,
                    tick: props.tick,
                    tickFormatter: props.tickFormatter,
                    tickLine: props.tickLine,
                    tickMargin: props.tickMargin,
                    tickSize: props.tickSize,
                    tickTextProps: props.tickTextProps,
                    ticks,
                    unit: props.unit,
                    width: props.width,
                    x: props.x,
                    y: props.y,
                  }),
                  react.createElement(
                    Label.zJ,
                    {
                      x: props.x,
                      y: props.y,
                      width: props.width,
                      height: props.height,
                      lowerWidth: props.width,
                      upperWidth: props.width,
                    },
                    react.createElement(Label._I, { label: props.label, labelRef: props.labelRef }),
                    props.children
                  )
                )
              );
        }),
        CartesianAxis = react.forwardRef((outsideProps, ref) => {
          var props = (0, resolveDefaultProps.e)(outsideProps, defaultCartesianAxisProps);
          return react.createElement(CartesianAxisComponent, _extends({}, props, { ref }));
        });
      CartesianAxis.displayName = 'CartesianAxis';
    },
    './node_modules/recharts/es6/cartesian/XAxis.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { W: () => XAxis });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/clsx/dist/clsx.mjs'
        ),
        _CartesianAxis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/cartesian/CartesianAxis.js'
        ),
        _state_hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _state_cartesianAxisSlice__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/state/cartesianAxisSlice.js'
        ),
        _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/axisSelectors.js'
        ),
        _state_selectors_selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
          ),
        _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        ),
        _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        _util_axisPropsAreEqual__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          './node_modules/recharts/es6/util/axisPropsAreEqual.js'
        ),
        _excluded = ['dangerouslySetInnerHTML', 'ticks', 'scale'],
        _excluded2 = ['id', 'scale'];
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function _objectWithoutProperties(e, t) {
        if (null == e) return {};
        var o,
          r,
          i = (function _objectWithoutPropertiesLoose(r, e) {
            if (null == r) return {};
            var t = {};
            for (var n in r)
              if ({}.hasOwnProperty.call(r, n)) {
                if (-1 !== e.indexOf(n)) continue;
                t[n] = r[n];
              }
            return t;
          })(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++)
            ((o = n[r]),
              -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
        }
        return i;
      }
      function SetXAxisSettings(settings) {
        var dispatch = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_3__.j)(),
          prevSettingsRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
        return (
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
            (null === prevSettingsRef.current
              ? dispatch((0, _state_cartesianAxisSlice__WEBPACK_IMPORTED_MODULE_4__.Vi)(settings))
              : prevSettingsRef.current !== settings &&
                dispatch(
                  (0, _state_cartesianAxisSlice__WEBPACK_IMPORTED_MODULE_4__.m2)({
                    prev: prevSettingsRef.current,
                    next: settings,
                  })
                ),
              (prevSettingsRef.current = settings));
          }, [settings, dispatch]),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(
            () => () => {
              prevSettingsRef.current &&
                (dispatch(
                  (0, _state_cartesianAxisSlice__WEBPACK_IMPORTED_MODULE_4__.MC)(
                    prevSettingsRef.current
                  )
                ),
                (prevSettingsRef.current = null));
            },
            [dispatch]
          ),
          null
        );
      }
      var XAxisImpl = (props) => {
          var { xAxisId, className } = props,
            viewBox = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_3__.G)(
              _state_selectors_selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_6__.c2
            ),
            isPanorama = (0, _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_7__.r)(),
            cartesianTickItems = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_3__.G)((state) =>
              (0, _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.Zi)(
                state,
                'xAxis',
                xAxisId,
                isPanorama
              )
            ),
            axisSize = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_3__.G)((state) =>
              (0, _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.Lw)(state, xAxisId)
            ),
            position = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_3__.G)((state) =>
              (0, _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.L$)(state, xAxisId)
            ),
            synchronizedSettings = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_3__.G)((state) =>
              (0, _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.y7)(state, xAxisId)
            );
          if (null == axisSize || null == position || null == synchronizedSettings) return null;
          var { dangerouslySetInnerHTML, ticks, scale: del } = props,
            allOtherProps = _objectWithoutProperties(props, _excluded),
            { id, scale: del2 } = synchronizedSettings,
            restSynchronizedSettings = _objectWithoutProperties(synchronizedSettings, _excluded2);
          return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
            _CartesianAxis__WEBPACK_IMPORTED_MODULE_2__.u,
            _extends({}, allOtherProps, restSynchronizedSettings, {
              x: position.x,
              y: position.y,
              width: axisSize.width,
              height: axisSize.height,
              className: (0, clsx__WEBPACK_IMPORTED_MODULE_1__.$)(
                'recharts-'.concat('xAxis', ' ').concat('xAxis'),
                className
              ),
              viewBox,
              ticks: cartesianTickItems,
              axisType: 'xAxis',
            })
          );
        },
        xAxisDefaultProps = {
          allowDataOverflow:
            _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.allowDataOverflow,
          allowDecimals:
            _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.allowDecimals,
          allowDuplicatedCategory:
            _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.allowDuplicatedCategory,
          angle: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.angle,
          axisLine: _CartesianAxis__WEBPACK_IMPORTED_MODULE_2__.F.axisLine,
          height: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.height,
          hide: !1,
          includeHidden:
            _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.includeHidden,
          interval: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.interval,
          minTickGap: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.minTickGap,
          mirror: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.mirror,
          orientation: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.orientation,
          padding: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.padding,
          reversed: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.reversed,
          scale: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.scale,
          tick: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.tick,
          tickCount: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.tickCount,
          tickLine: _CartesianAxis__WEBPACK_IMPORTED_MODULE_2__.F.tickLine,
          tickSize: _CartesianAxis__WEBPACK_IMPORTED_MODULE_2__.F.tickSize,
          type: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.PU.type,
          xAxisId: 0,
        },
        XAxisSettingsDispatcher = (outsideProps) => {
          var props = (0, _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_8__.e)(
            outsideProps,
            xAxisDefaultProps
          );
          return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
            react__WEBPACK_IMPORTED_MODULE_0__.Fragment,
            null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(SetXAxisSettings, {
              allowDataOverflow: props.allowDataOverflow,
              allowDecimals: props.allowDecimals,
              allowDuplicatedCategory: props.allowDuplicatedCategory,
              angle: props.angle,
              dataKey: props.dataKey,
              domain: props.domain,
              height: props.height,
              hide: props.hide,
              id: props.xAxisId,
              includeHidden: props.includeHidden,
              interval: props.interval,
              minTickGap: props.minTickGap,
              mirror: props.mirror,
              name: props.name,
              orientation: props.orientation,
              padding: props.padding,
              reversed: props.reversed,
              scale: props.scale,
              tick: props.tick,
              tickCount: props.tickCount,
              tickFormatter: props.tickFormatter,
              ticks: props.ticks,
              type: props.type,
              unit: props.unit,
            }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(XAxisImpl, props)
          );
        },
        XAxis = react__WEBPACK_IMPORTED_MODULE_0__.memo(
          XAxisSettingsDispatcher,
          _util_axisPropsAreEqual__WEBPACK_IMPORTED_MODULE_9__.Q
        );
      XAxis.displayName = 'XAxis';
    },
    './node_modules/recharts/es6/cartesian/YAxis.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { h: () => YAxis });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/clsx/dist/clsx.mjs'
        ),
        _CartesianAxis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/cartesian/CartesianAxis.js'
        ),
        _state_cartesianAxisSlice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/state/cartesianAxisSlice.js'
        ),
        _state_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/axisSelectors.js'
        ),
        _state_selectors_selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
          ),
        _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        ),
        _component_Label__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          './node_modules/recharts/es6/component/Label.js'
        ),
        _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        _util_axisPropsAreEqual__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          './node_modules/recharts/es6/util/axisPropsAreEqual.js'
        ),
        _excluded = ['dangerouslySetInnerHTML', 'ticks', 'scale'],
        _excluded2 = ['id', 'scale'];
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function _objectWithoutProperties(e, t) {
        if (null == e) return {};
        var o,
          r,
          i = (function _objectWithoutPropertiesLoose(r, e) {
            if (null == r) return {};
            var t = {};
            for (var n in r)
              if ({}.hasOwnProperty.call(r, n)) {
                if (-1 !== e.indexOf(n)) continue;
                t[n] = r[n];
              }
            return t;
          })(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++)
            ((o = n[r]),
              -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
        }
        return i;
      }
      function SetYAxisSettings(settings) {
        var dispatch = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_4__.j)(),
          prevSettingsRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
        return (
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
            (null === prevSettingsRef.current
              ? dispatch((0, _state_cartesianAxisSlice__WEBPACK_IMPORTED_MODULE_3__.cU)(settings))
              : prevSettingsRef.current !== settings &&
                dispatch(
                  (0, _state_cartesianAxisSlice__WEBPACK_IMPORTED_MODULE_3__.hd)({
                    prev: prevSettingsRef.current,
                    next: settings,
                  })
                ),
              (prevSettingsRef.current = settings));
          }, [settings, dispatch]),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(
            () => () => {
              prevSettingsRef.current &&
                (dispatch(
                  (0, _state_cartesianAxisSlice__WEBPACK_IMPORTED_MODULE_3__.fR)(
                    prevSettingsRef.current
                  )
                ),
                (prevSettingsRef.current = null));
            },
            [dispatch]
          ),
          null
        );
      }
      var YAxisImpl = (props) => {
          var { yAxisId, className, width, label } = props,
            cartesianAxisRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),
            labelRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),
            viewBox = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_4__.G)(
              _state_selectors_selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_6__.c2
            ),
            isPanorama = (0, _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_7__.r)(),
            dispatch = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_4__.j)(),
            axisSize = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_4__.G)((state) =>
              (0, _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.wP)(state, yAxisId)
            ),
            position = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_4__.G)((state) =>
              (0, _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.KR)(state, yAxisId)
            ),
            cartesianTickItems = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_4__.G)((state) =>
              (0, _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.Zi)(
                state,
                'yAxis',
                yAxisId,
                isPanorama
              )
            ),
            synchronizedSettings = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_4__.G)((state) =>
              (0, _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.hc)(state, yAxisId)
            );
          if (
            ((0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
              if (
                'auto' === width &&
                axisSize &&
                !(0, _component_Label__WEBPACK_IMPORTED_MODULE_8__.ZY)(label) &&
                !(0, react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(label) &&
                null != synchronizedSettings
              ) {
                var axisComponent = cartesianAxisRef.current;
                if (axisComponent) {
                  var updatedYAxisWidth = axisComponent.getCalculatedWidth();
                  Math.round(axisSize.width) !== Math.round(updatedYAxisWidth) &&
                    dispatch(
                      (0, _state_cartesianAxisSlice__WEBPACK_IMPORTED_MODULE_3__.QG)({
                        id: yAxisId,
                        width: updatedYAxisWidth,
                      })
                    );
                }
              }
            }, [
              cartesianTickItems,
              axisSize,
              dispatch,
              label,
              yAxisId,
              width,
              synchronizedSettings,
            ]),
            null == axisSize || null == position || null == synchronizedSettings)
          )
            return null;
          var { dangerouslySetInnerHTML, ticks, scale: del } = props,
            allOtherProps = _objectWithoutProperties(props, _excluded),
            { id, scale: del2 } = synchronizedSettings,
            restSynchronizedSettings = _objectWithoutProperties(synchronizedSettings, _excluded2);
          return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
            _CartesianAxis__WEBPACK_IMPORTED_MODULE_2__.u,
            _extends({}, allOtherProps, restSynchronizedSettings, {
              ref: cartesianAxisRef,
              labelRef,
              x: position.x,
              y: position.y,
              tickTextProps: 'auto' === width ? { width: void 0 } : { width },
              width: axisSize.width,
              height: axisSize.height,
              className: (0, clsx__WEBPACK_IMPORTED_MODULE_1__.$)(
                'recharts-'.concat('yAxis', ' ').concat('yAxis'),
                className
              ),
              viewBox,
              ticks: cartesianTickItems,
              axisType: 'yAxis',
            })
          );
        },
        yAxisDefaultProps = {
          allowDataOverflow:
            _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.allowDataOverflow,
          allowDecimals:
            _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.allowDecimals,
          allowDuplicatedCategory:
            _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.allowDuplicatedCategory,
          angle: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.angle,
          axisLine: _CartesianAxis__WEBPACK_IMPORTED_MODULE_2__.F.axisLine,
          hide: !1,
          includeHidden:
            _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.includeHidden,
          interval: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.interval,
          minTickGap: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.minTickGap,
          mirror: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.mirror,
          orientation: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.orientation,
          padding: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.padding,
          reversed: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.reversed,
          scale: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.scale,
          tick: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.tick,
          tickCount: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.tickCount,
          tickLine: _CartesianAxis__WEBPACK_IMPORTED_MODULE_2__.F.tickLine,
          tickSize: _CartesianAxis__WEBPACK_IMPORTED_MODULE_2__.F.tickSize,
          type: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.type,
          width: _state_selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_5__.cd.width,
          yAxisId: 0,
        },
        YAxisSettingsDispatcher = (outsideProps) => {
          var props = (0, _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_9__.e)(
            outsideProps,
            yAxisDefaultProps
          );
          return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
            react__WEBPACK_IMPORTED_MODULE_0__.Fragment,
            null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(SetYAxisSettings, {
              interval: props.interval,
              id: props.yAxisId,
              scale: props.scale,
              type: props.type,
              domain: props.domain,
              allowDataOverflow: props.allowDataOverflow,
              dataKey: props.dataKey,
              allowDuplicatedCategory: props.allowDuplicatedCategory,
              allowDecimals: props.allowDecimals,
              tickCount: props.tickCount,
              padding: props.padding,
              includeHidden: props.includeHidden,
              reversed: props.reversed,
              ticks: props.ticks,
              width: props.width,
              orientation: props.orientation,
              mirror: props.mirror,
              hide: props.hide,
              unit: props.unit,
              name: props.name,
              angle: props.angle,
              minTickGap: props.minTickGap,
              tick: props.tick,
              tickFormatter: props.tickFormatter,
            }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(YAxisImpl, props)
          );
        },
        YAxis = react__WEBPACK_IMPORTED_MODULE_0__.memo(
          YAxisSettingsDispatcher,
          _util_axisPropsAreEqual__WEBPACK_IMPORTED_MODULE_10__.Q
        );
      YAxis.displayName = 'YAxis';
    },
    './node_modules/recharts/es6/chart/BarChart.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { E: () => BarChart });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        optionsSlice = __webpack_require__('./node_modules/recharts/es6/state/optionsSlice.js'),
        RechartsStoreProvider = __webpack_require__(
          './node_modules/recharts/es6/state/RechartsStoreProvider.js'
        ),
        chartDataContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartDataContext.js'
        ),
        ReportMainChartProps = __webpack_require__(
          './node_modules/recharts/es6/state/ReportMainChartProps.js'
        ),
        ReportChartProps = __webpack_require__(
          './node_modules/recharts/es6/state/ReportChartProps.js'
        ),
        CategoricalChart = __webpack_require__(
          './node_modules/recharts/es6/chart/CategoricalChart.js'
        ),
        resolveDefaultProps = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        );
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      var defaultCartesianChartProps = {
          accessibilityLayer: !0,
          barCategoryGap: '10%',
          barGap: 4,
          layout: 'horizontal',
          margin: { top: 5, right: 5, bottom: 5, left: 5 },
          responsive: !1,
          reverseStackOrder: !1,
          stackOffset: 'none',
          syncMethod: 'index',
        },
        CartesianChart = (0, react.forwardRef)(function CartesianChart(props, ref) {
          var _categoricalChartProp,
            rootChartProps = (0, resolveDefaultProps.e)(
              props.categoricalChartProps,
              defaultCartesianChartProps
            ),
            {
              chartName,
              defaultTooltipEventType,
              validateTooltipEventTypes,
              tooltipPayloadSearcher,
              categoricalChartProps,
            } = props,
            options = {
              chartName,
              defaultTooltipEventType,
              validateTooltipEventTypes,
              tooltipPayloadSearcher,
              eventEmitter: void 0,
            };
          return react.createElement(
            RechartsStoreProvider.J,
            {
              preloadedState: { options },
              reduxStoreName:
                null !== (_categoricalChartProp = categoricalChartProps.id) &&
                void 0 !== _categoricalChartProp
                  ? _categoricalChartProp
                  : chartName,
            },
            react.createElement(chartDataContext.TK, { chartData: categoricalChartProps.data }),
            react.createElement(ReportMainChartProps.s, {
              layout: rootChartProps.layout,
              margin: rootChartProps.margin,
            }),
            react.createElement(ReportChartProps.p, {
              baseValue: rootChartProps.baseValue,
              accessibilityLayer: rootChartProps.accessibilityLayer,
              barCategoryGap: rootChartProps.barCategoryGap,
              maxBarSize: rootChartProps.maxBarSize,
              stackOffset: rootChartProps.stackOffset,
              barGap: rootChartProps.barGap,
              barSize: rootChartProps.barSize,
              syncId: rootChartProps.syncId,
              syncMethod: rootChartProps.syncMethod,
              className: rootChartProps.className,
              reverseStackOrder: rootChartProps.reverseStackOrder,
            }),
            react.createElement(CategoricalChart.L, _extends({}, rootChartProps, { ref }))
          );
        }),
        allowedTooltipTypes = ['axis', 'item'],
        BarChart = (0, react.forwardRef)((props, ref) =>
          react.createElement(CartesianChart, {
            chartName: 'BarChart',
            defaultTooltipEventType: 'axis',
            validateTooltipEventTypes: allowedTooltipTypes,
            tooltipPayloadSearcher: optionsSlice.uN,
            categoricalChartProps: props,
            ref,
          })
        );
    },
    './node_modules/recharts/es6/chart/CategoricalChart.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { L: () => CategoricalChart });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        chartLayoutContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        accessibilityContext = __webpack_require__(
          './node_modules/recharts/es6/context/accessibilityContext.js'
        ),
        PanoramaContext = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        ),
        clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
        svgPropertiesAndEvents = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesAndEvents.js'
        ),
        _excluded = [
          'children',
          'width',
          'height',
          'viewBox',
          'className',
          'style',
          'title',
          'desc',
        ];
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      var Surface = (0, react.forwardRef)((props, ref) => {
          var { children, width, height, viewBox, className, style, title, desc } = props,
            others = (function _objectWithoutProperties(e, t) {
              if (null == e) return {};
              var o,
                r,
                i = (function _objectWithoutPropertiesLoose(r, e) {
                  if (null == r) return {};
                  var t = {};
                  for (var n in r)
                    if ({}.hasOwnProperty.call(r, n)) {
                      if (-1 !== e.indexOf(n)) continue;
                      t[n] = r[n];
                    }
                  return t;
                })(e, t);
              if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(e);
                for (r = 0; r < n.length; r++)
                  ((o = n[r]),
                    -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
              }
              return i;
            })(props, _excluded),
            svgView = viewBox || { width, height, x: 0, y: 0 },
            layerClass = (0, clsx.$)('recharts-surface', className);
          return react.createElement(
            'svg',
            _extends({}, (0, svgPropertiesAndEvents.a)(others), {
              className: layerClass,
              width,
              height,
              style,
              viewBox: ''
                .concat(svgView.x, ' ')
                .concat(svgView.y, ' ')
                .concat(svgView.width, ' ')
                .concat(svgView.height),
              ref,
            }),
            react.createElement('title', null, title),
            react.createElement('desc', null, desc),
            children
          );
        }),
        hooks = __webpack_require__('./node_modules/recharts/es6/state/hooks.js'),
        brushSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/brushSelectors.js'
        ),
        isWellBehavedNumber = __webpack_require__(
          './node_modules/recharts/es6/util/isWellBehavedNumber.js'
        ),
        zIndexSlice = __webpack_require__('./node_modules/recharts/es6/state/zIndexSlice.js'),
        zIndexSelectors = __webpack_require__(
          './node_modules/recharts/es6/zIndex/zIndexSelectors.js'
        );
      function ZIndexSvgPortal(_ref) {
        var { zIndex, isPanorama } = _ref,
          ref = (0, react.useRef)(null),
          dispatch = (0, hooks.j)();
        return (
          (0, react.useLayoutEffect)(
            () => (
              ref.current &&
                dispatch((0, zIndexSlice.WO)({ zIndex, element: ref.current, isPanorama })),
              () => {
                dispatch((0, zIndexSlice.B8)({ zIndex, isPanorama }));
              }
            ),
            [dispatch, zIndex, isPanorama]
          ),
          react.createElement('g', { tabIndex: -1, ref })
        );
      }
      function AllZIndexPortals(_ref2) {
        var { children, isPanorama } = _ref2,
          allRegisteredZIndexes = (0, hooks.G)(zIndexSelectors.I);
        if (!allRegisteredZIndexes || 0 === allRegisteredZIndexes.length) return children;
        var allNegativeZIndexes = allRegisteredZIndexes.filter((zIndex) => zIndex < 0),
          allPositiveZIndexes = allRegisteredZIndexes.filter((zIndex) => zIndex > 0);
        return react.createElement(
          react.Fragment,
          null,
          allNegativeZIndexes.map((zIndex) =>
            react.createElement(ZIndexSvgPortal, { key: zIndex, zIndex, isPanorama })
          ),
          children,
          allPositiveZIndexes.map((zIndex) =>
            react.createElement(ZIndexSvgPortal, { key: zIndex, zIndex, isPanorama })
          )
        );
      }
      var RootSurface_excluded = ['children'];
      function RootSurface_extends() {
        return (
          (RootSurface_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          RootSurface_extends.apply(null, arguments)
        );
      }
      var FULL_WIDTH_AND_HEIGHT = { width: '100%', height: '100%', display: 'block' },
        MainChartSurface = (0, react.forwardRef)((props, ref) => {
          var width = (0, chartLayoutContext.yi)(),
            height = (0, chartLayoutContext.rY)(),
            hasAccessibilityLayer = (0, accessibilityContext.$)();
          if (!(0, isWellBehavedNumber.F)(width) || !(0, isWellBehavedNumber.F)(height))
            return null;
          var tabIndex,
            role,
            { children, otherAttributes, title, desc } = props;
          return (
            null != otherAttributes &&
              ((tabIndex =
                'number' == typeof otherAttributes.tabIndex
                  ? otherAttributes.tabIndex
                  : hasAccessibilityLayer
                    ? 0
                    : void 0),
              (role =
                'string' == typeof otherAttributes.role
                  ? otherAttributes.role
                  : hasAccessibilityLayer
                    ? 'application'
                    : void 0)),
            react.createElement(
              Surface,
              RootSurface_extends({}, otherAttributes, {
                title,
                desc,
                role,
                tabIndex,
                width,
                height,
                style: FULL_WIDTH_AND_HEIGHT,
                ref,
              }),
              children
            )
          );
        }),
        BrushPanoramaSurface = (_ref) => {
          var { children } = _ref,
            brushDimensions = (0, hooks.G)(brushSelectors.U);
          if (!brushDimensions) return null;
          var { width, height, y, x } = brushDimensions;
          return react.createElement(Surface, { width, height, x, y }, children);
        },
        RootSurface = (0, react.forwardRef)((_ref2, ref) => {
          var { children } = _ref2,
            rest = (function RootSurface_objectWithoutProperties(e, t) {
              if (null == e) return {};
              var o,
                r,
                i = (function RootSurface_objectWithoutPropertiesLoose(r, e) {
                  if (null == r) return {};
                  var t = {};
                  for (var n in r)
                    if ({}.hasOwnProperty.call(r, n)) {
                      if (-1 !== e.indexOf(n)) continue;
                      t[n] = r[n];
                    }
                  return t;
                })(e, t);
              if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(e);
                for (r = 0; r < n.length; r++)
                  ((o = n[r]),
                    -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
              }
              return i;
            })(_ref2, RootSurface_excluded);
          return (0, PanoramaContext.r)()
            ? react.createElement(
                BrushPanoramaSurface,
                null,
                react.createElement(AllZIndexPortals, { isPanorama: !0 }, children)
              )
            : react.createElement(
                MainChartSurface,
                RootSurface_extends({ ref }, rest),
                react.createElement(AllZIndexPortals, { isPanorama: !1 }, children)
              );
        }),
        tooltipSlice = __webpack_require__('./node_modules/recharts/es6/state/tooltipSlice.js'),
        mouseEventsMiddleware = __webpack_require__(
          './node_modules/recharts/es6/state/mouseEventsMiddleware.js'
        ),
        useChartSynchronisation = __webpack_require__(
          './node_modules/recharts/es6/synchronisation/useChartSynchronisation.js'
        ),
        keyboardEventsMiddleware = __webpack_require__(
          './node_modules/recharts/es6/state/keyboardEventsMiddleware.js'
        ),
        containerSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/containerSelectors.js'
        ),
        layoutSlice = __webpack_require__('./node_modules/recharts/es6/state/layoutSlice.js');
      var externalEventsMiddleware = __webpack_require__(
          './node_modules/recharts/es6/state/externalEventsMiddleware.js'
        ),
        touchEventsMiddleware = __webpack_require__(
          './node_modules/recharts/es6/state/touchEventsMiddleware.js'
        ),
        tooltipPortalContext = __webpack_require__(
          './node_modules/recharts/es6/context/tooltipPortalContext.js'
        ),
        LegendPortalContext = (0, react.createContext)(null),
        ResponsiveContainer = __webpack_require__(
          './node_modules/recharts/es6/component/ResponsiveContainer.js'
        ),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js');
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function RechartsWrapper_extends() {
        return (
          (RechartsWrapper_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          RechartsWrapper_extends.apply(null, arguments)
        );
      }
      var EventSynchronizer = () => ((0, useChartSynchronisation.l3)(), null);
      function getNumberOrZero(value) {
        if ('number' == typeof value) return value;
        if ('string' == typeof value) {
          var parsed = parseFloat(value);
          if (!Number.isNaN(parsed)) return parsed;
        }
        return 0;
      }
      var ResponsiveDiv = (0, react.forwardRef)((props, ref) => {
          var _props$style,
            _props$style2,
            observerRef = (0, react.useRef)(null),
            [sizes, setSizes] = (0, react.useState)({
              containerWidth: getNumberOrZero(
                null === (_props$style = props.style) || void 0 === _props$style
                  ? void 0
                  : _props$style.width
              ),
              containerHeight: getNumberOrZero(
                null === (_props$style2 = props.style) || void 0 === _props$style2
                  ? void 0
                  : _props$style2.height
              ),
            }),
            setContainerSize = (0, react.useCallback)((newWidth, newHeight) => {
              setSizes((prevState) => {
                var roundedWidth = Math.round(newWidth),
                  roundedHeight = Math.round(newHeight);
                return prevState.containerWidth === roundedWidth &&
                  prevState.containerHeight === roundedHeight
                  ? prevState
                  : { containerWidth: roundedWidth, containerHeight: roundedHeight };
              });
            }, []),
            innerRef = (0, react.useCallback)(
              (node) => {
                if (
                  ('function' == typeof ref && ref(node),
                  null != node && 'undefined' != typeof ResizeObserver)
                ) {
                  var { width: containerWidth, height: containerHeight } =
                    node.getBoundingClientRect();
                  setContainerSize(containerWidth, containerHeight);
                  var observer = new ResizeObserver((entries) => {
                    var { width, height } = entries[0].contentRect;
                    setContainerSize(width, height);
                  });
                  (observer.observe(node), (observerRef.current = observer));
                }
              },
              [ref, setContainerSize]
            );
          return (
            (0, react.useEffect)(
              () => () => {
                var observer = observerRef.current;
                null != observer && observer.disconnect();
              },
              [setContainerSize]
            ),
            react.createElement(
              react.Fragment,
              null,
              react.createElement(chartLayoutContext.A3, {
                width: sizes.containerWidth,
                height: sizes.containerHeight,
              }),
              react.createElement('div', RechartsWrapper_extends({ ref: innerRef }, props))
            )
          );
        }),
        ReadSizeOnceDiv = (0, react.forwardRef)((props, ref) => {
          var { width, height } = props,
            [sizes, setSizes] = (0, react.useState)({
              containerWidth: getNumberOrZero(width),
              containerHeight: getNumberOrZero(height),
            }),
            setContainerSize = (0, react.useCallback)((newWidth, newHeight) => {
              setSizes((prevState) => {
                var roundedWidth = Math.round(newWidth),
                  roundedHeight = Math.round(newHeight);
                return prevState.containerWidth === roundedWidth &&
                  prevState.containerHeight === roundedHeight
                  ? prevState
                  : { containerWidth: roundedWidth, containerHeight: roundedHeight };
              });
            }, []),
            innerRef = (0, react.useCallback)(
              (node) => {
                if (('function' == typeof ref && ref(node), null != node)) {
                  var { width: containerWidth, height: containerHeight } =
                    node.getBoundingClientRect();
                  setContainerSize(containerWidth, containerHeight);
                }
              },
              [ref, setContainerSize]
            );
          return react.createElement(
            react.Fragment,
            null,
            react.createElement(chartLayoutContext.A3, {
              width: sizes.containerWidth,
              height: sizes.containerHeight,
            }),
            react.createElement('div', RechartsWrapper_extends({ ref: innerRef }, props))
          );
        }),
        StaticDiv = (0, react.forwardRef)((props, ref) => {
          var { width, height } = props;
          return react.createElement(
            react.Fragment,
            null,
            react.createElement(chartLayoutContext.A3, { width, height }),
            react.createElement('div', RechartsWrapper_extends({ ref }, props))
          );
        }),
        NonResponsiveDiv = (0, react.forwardRef)((props, ref) => {
          var { width, height } = props;
          return (0, DataUtils._3)(width) || (0, DataUtils._3)(height)
            ? react.createElement(ReadSizeOnceDiv, RechartsWrapper_extends({}, props, { ref }))
            : react.createElement(StaticDiv, RechartsWrapper_extends({}, props, { ref }));
        });
      var RechartsWrapper = (0, react.forwardRef)((props, ref) => {
          var {
              children,
              className,
              height: heightFromProps,
              onClick,
              onContextMenu,
              onDoubleClick,
              onMouseDown,
              onMouseEnter,
              onMouseLeave,
              onMouseMove,
              onMouseUp,
              onTouchEnd,
              onTouchMove,
              onTouchStart,
              style,
              width: widthFromProps,
              responsive,
              dispatchTouchEvents = !0,
            } = props,
            containerRef = (0, react.useRef)(null),
            dispatch = (0, hooks.j)(),
            [tooltipPortal, setTooltipPortal] = (0, react.useState)(null),
            [legendPortal, setLegendPortal] = (0, react.useState)(null),
            setScaleRef = (function useReportScale() {
              var dispatch = (0, hooks.j)(),
                [ref, setRef] = (0, react.useState)(null),
                scale = (0, hooks.G)(containerSelectors.et);
              return (
                (0, react.useEffect)(() => {
                  if (null != ref) {
                    var newScale = ref.getBoundingClientRect().width / ref.offsetWidth;
                    (0, isWellBehavedNumber.H)(newScale) &&
                      newScale !== scale &&
                      dispatch((0, layoutSlice.hF)(newScale));
                  }
                }, [ref, dispatch, scale]),
                setRef
              );
            })(),
            responsiveContainerCalculations = (0, ResponsiveContainer.w)(),
            width =
              (null == responsiveContainerCalculations
                ? void 0
                : responsiveContainerCalculations.width) > 0
                ? responsiveContainerCalculations.width
                : widthFromProps,
            height =
              (null == responsiveContainerCalculations
                ? void 0
                : responsiveContainerCalculations.height) > 0
                ? responsiveContainerCalculations.height
                : heightFromProps,
            innerRef = (0, react.useCallback)(
              (node) => {
                (setScaleRef(node),
                  'function' == typeof ref && ref(node),
                  setTooltipPortal(node),
                  setLegendPortal(node),
                  null != node && (containerRef.current = node));
              },
              [setScaleRef, ref, setTooltipPortal, setLegendPortal]
            ),
            myOnClick = (0, react.useCallback)(
              (e) => {
                (dispatch((0, mouseEventsMiddleware.ky)(e)),
                  dispatch((0, externalEventsMiddleware.y)({ handler: onClick, reactEvent: e })));
              },
              [dispatch, onClick]
            ),
            myOnMouseEnter = (0, react.useCallback)(
              (e) => {
                (dispatch((0, mouseEventsMiddleware.dj)(e)),
                  dispatch(
                    (0, externalEventsMiddleware.y)({ handler: onMouseEnter, reactEvent: e })
                  ));
              },
              [dispatch, onMouseEnter]
            ),
            myOnMouseLeave = (0, react.useCallback)(
              (e) => {
                (dispatch((0, tooltipSlice.xS)()),
                  dispatch(
                    (0, externalEventsMiddleware.y)({ handler: onMouseLeave, reactEvent: e })
                  ));
              },
              [dispatch, onMouseLeave]
            ),
            myOnMouseMove = (0, react.useCallback)(
              (e) => {
                (dispatch((0, mouseEventsMiddleware.dj)(e)),
                  dispatch(
                    (0, externalEventsMiddleware.y)({ handler: onMouseMove, reactEvent: e })
                  ));
              },
              [dispatch, onMouseMove]
            ),
            onFocus = (0, react.useCallback)(() => {
              dispatch((0, keyboardEventsMiddleware.Ru)());
            }, [dispatch]),
            onKeyDown = (0, react.useCallback)(
              (e) => {
                dispatch((0, keyboardEventsMiddleware.uZ)(e.key));
              },
              [dispatch]
            ),
            myOnContextMenu = (0, react.useCallback)(
              (e) => {
                dispatch(
                  (0, externalEventsMiddleware.y)({ handler: onContextMenu, reactEvent: e })
                );
              },
              [dispatch, onContextMenu]
            ),
            myOnDoubleClick = (0, react.useCallback)(
              (e) => {
                dispatch(
                  (0, externalEventsMiddleware.y)({ handler: onDoubleClick, reactEvent: e })
                );
              },
              [dispatch, onDoubleClick]
            ),
            myOnMouseDown = (0, react.useCallback)(
              (e) => {
                dispatch((0, externalEventsMiddleware.y)({ handler: onMouseDown, reactEvent: e }));
              },
              [dispatch, onMouseDown]
            ),
            myOnMouseUp = (0, react.useCallback)(
              (e) => {
                dispatch((0, externalEventsMiddleware.y)({ handler: onMouseUp, reactEvent: e }));
              },
              [dispatch, onMouseUp]
            ),
            myOnTouchStart = (0, react.useCallback)(
              (e) => {
                dispatch((0, externalEventsMiddleware.y)({ handler: onTouchStart, reactEvent: e }));
              },
              [dispatch, onTouchStart]
            ),
            myOnTouchMove = (0, react.useCallback)(
              (e) => {
                (dispatchTouchEvents && dispatch((0, touchEventsMiddleware.e)(e)),
                  dispatch(
                    (0, externalEventsMiddleware.y)({ handler: onTouchMove, reactEvent: e })
                  ));
              },
              [dispatch, dispatchTouchEvents, onTouchMove]
            ),
            myOnTouchEnd = (0, react.useCallback)(
              (e) => {
                dispatch((0, externalEventsMiddleware.y)({ handler: onTouchEnd, reactEvent: e }));
              },
              [dispatch, onTouchEnd]
            ),
            WrapperDiv = (function getWrapperDivComponent(responsive) {
              return !0 === responsive ? ResponsiveDiv : NonResponsiveDiv;
            })(responsive);
          return react.createElement(
            tooltipPortalContext.$.Provider,
            { value: tooltipPortal },
            react.createElement(
              LegendPortalContext.Provider,
              { value: legendPortal },
              react.createElement(
                WrapperDiv,
                {
                  width: null != width ? width : null == style ? void 0 : style.width,
                  height: null != height ? height : null == style ? void 0 : style.height,
                  className: (0, clsx.$)('recharts-wrapper', className),
                  style: _objectSpread(
                    { position: 'relative', cursor: 'default', width, height },
                    style
                  ),
                  onClick: myOnClick,
                  onContextMenu: myOnContextMenu,
                  onDoubleClick: myOnDoubleClick,
                  onFocus,
                  onKeyDown,
                  onMouseDown: myOnMouseDown,
                  onMouseEnter: myOnMouseEnter,
                  onMouseLeave: myOnMouseLeave,
                  onMouseMove: myOnMouseMove,
                  onMouseUp: myOnMouseUp,
                  onTouchEnd: myOnTouchEnd,
                  onTouchMove: myOnTouchMove,
                  onTouchStart: myOnTouchStart,
                  ref: innerRef,
                },
                react.createElement(EventSynchronizer, null),
                children
              )
            )
          );
        }),
        es6_hooks = __webpack_require__('./node_modules/recharts/es6/hooks.js'),
        ClipPathIdContext = (0, react.createContext)(void 0),
        ClipPathProvider = (_ref) => {
          var { children } = _ref,
            [clipPathId] = (0, react.useState)(''.concat((0, DataUtils.NF)('recharts'), '-clip')),
            plotArea = (0, es6_hooks.oM)();
          if (null == plotArea) return null;
          var { x, y, width, height } = plotArea;
          return react.createElement(
            ClipPathIdContext.Provider,
            { value: clipPathId },
            react.createElement(
              'defs',
              null,
              react.createElement(
                'clipPath',
                { id: clipPathId },
                react.createElement('rect', { x, y, height, width })
              )
            ),
            children
          );
        },
        svgPropertiesNoEvents = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesNoEvents.js'
        ),
        CategoricalChart_excluded = [
          'width',
          'height',
          'responsive',
          'children',
          'className',
          'style',
          'compact',
          'title',
          'desc',
        ];
      var CategoricalChart = (0, react.forwardRef)((props, ref) => {
        var { width, height, responsive, children, className, style, compact, title, desc } = props,
          others = (function CategoricalChart_objectWithoutProperties(e, t) {
            if (null == e) return {};
            var o,
              r,
              i = (function CategoricalChart_objectWithoutPropertiesLoose(r, e) {
                if (null == r) return {};
                var t = {};
                for (var n in r)
                  if ({}.hasOwnProperty.call(r, n)) {
                    if (-1 !== e.indexOf(n)) continue;
                    t[n] = r[n];
                  }
                return t;
              })(e, t);
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              for (r = 0; r < n.length; r++)
                ((o = n[r]),
                  -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
            }
            return i;
          })(props, CategoricalChart_excluded),
          attrs = (0, svgPropertiesNoEvents.uZ)(others);
        return compact
          ? react.createElement(
              react.Fragment,
              null,
              react.createElement(chartLayoutContext.A3, { width, height }),
              react.createElement(RootSurface, { otherAttributes: attrs, title, desc }, children)
            )
          : react.createElement(
              RechartsWrapper,
              {
                className,
                style,
                width,
                height,
                responsive: null != responsive && responsive,
                onClick: props.onClick,
                onMouseLeave: props.onMouseLeave,
                onMouseEnter: props.onMouseEnter,
                onMouseMove: props.onMouseMove,
                onMouseDown: props.onMouseDown,
                onMouseUp: props.onMouseUp,
                onContextMenu: props.onContextMenu,
                onDoubleClick: props.onDoubleClick,
                onTouchStart: props.onTouchStart,
                onTouchMove: props.onTouchMove,
                onTouchEnd: props.onTouchEnd,
              },
              react.createElement(
                RootSurface,
                { otherAttributes: attrs, title, desc, ref },
                react.createElement(ClipPathProvider, null, children)
              )
            );
      });
    },
    './node_modules/recharts/es6/chart/PieChart.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { r: () => PieChart });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        optionsSlice = __webpack_require__('./node_modules/recharts/es6/state/optionsSlice.js'),
        RechartsStoreProvider = __webpack_require__(
          './node_modules/recharts/es6/state/RechartsStoreProvider.js'
        ),
        chartDataContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartDataContext.js'
        ),
        ReportMainChartProps = __webpack_require__(
          './node_modules/recharts/es6/state/ReportMainChartProps.js'
        ),
        ReportChartProps = __webpack_require__(
          './node_modules/recharts/es6/state/ReportChartProps.js'
        ),
        hooks = __webpack_require__('./node_modules/recharts/es6/state/hooks.js'),
        polarOptionsSlice = __webpack_require__(
          './node_modules/recharts/es6/state/polarOptionsSlice.js'
        );
      function ReportPolarOptions(props) {
        var dispatch = (0, hooks.j)();
        return (
          (0, react.useEffect)(() => {
            dispatch((0, polarOptionsSlice.U)(props));
          }, [dispatch, props]),
          null
        );
      }
      var CategoricalChart = __webpack_require__(
          './node_modules/recharts/es6/chart/CategoricalChart.js'
        ),
        resolveDefaultProps = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        _excluded = ['layout'];
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      var defaultPolarChartProps = {
          accessibilityLayer: !0,
          stackOffset: 'none',
          barCategoryGap: '10%',
          barGap: 4,
          margin: { top: 5, right: 5, bottom: 5, left: 5 },
          reverseStackOrder: !1,
          syncMethod: 'index',
          layout: 'radial',
          responsive: !1,
          cx: '50%',
          cy: '50%',
          innerRadius: 0,
          outerRadius: '80%',
        },
        PolarChart = (0, react.forwardRef)(function PolarChart(props, ref) {
          var _polarChartProps$id,
            polarChartProps = (0, resolveDefaultProps.e)(
              props.categoricalChartProps,
              defaultPolarChartProps
            ),
            { layout } = polarChartProps,
            otherCategoricalProps = (function _objectWithoutProperties(e, t) {
              if (null == e) return {};
              var o,
                r,
                i = (function _objectWithoutPropertiesLoose(r, e) {
                  if (null == r) return {};
                  var t = {};
                  for (var n in r)
                    if ({}.hasOwnProperty.call(r, n)) {
                      if (-1 !== e.indexOf(n)) continue;
                      t[n] = r[n];
                    }
                  return t;
                })(e, t);
              if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(e);
                for (r = 0; r < n.length; r++)
                  ((o = n[r]),
                    -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
              }
              return i;
            })(polarChartProps, _excluded),
            {
              chartName,
              defaultTooltipEventType,
              validateTooltipEventTypes,
              tooltipPayloadSearcher,
            } = props,
            options = {
              chartName,
              defaultTooltipEventType,
              validateTooltipEventTypes,
              tooltipPayloadSearcher,
              eventEmitter: void 0,
            };
          return react.createElement(
            RechartsStoreProvider.J,
            {
              preloadedState: { options },
              reduxStoreName:
                null !== (_polarChartProps$id = polarChartProps.id) &&
                void 0 !== _polarChartProps$id
                  ? _polarChartProps$id
                  : chartName,
            },
            react.createElement(chartDataContext.TK, { chartData: polarChartProps.data }),
            react.createElement(ReportMainChartProps.s, { layout, margin: polarChartProps.margin }),
            react.createElement(ReportChartProps.p, {
              baseValue: void 0,
              accessibilityLayer: polarChartProps.accessibilityLayer,
              barCategoryGap: polarChartProps.barCategoryGap,
              maxBarSize: polarChartProps.maxBarSize,
              stackOffset: polarChartProps.stackOffset,
              barGap: polarChartProps.barGap,
              barSize: polarChartProps.barSize,
              syncId: polarChartProps.syncId,
              syncMethod: polarChartProps.syncMethod,
              className: polarChartProps.className,
              reverseStackOrder: polarChartProps.reverseStackOrder,
            }),
            react.createElement(ReportPolarOptions, {
              cx: polarChartProps.cx,
              cy: polarChartProps.cy,
              startAngle: polarChartProps.startAngle,
              endAngle: polarChartProps.endAngle,
              innerRadius: polarChartProps.innerRadius,
              outerRadius: polarChartProps.outerRadius,
            }),
            react.createElement(CategoricalChart.L, _extends({}, otherCategoricalProps, { ref }))
          );
        });
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var allowedTooltipTypes = ['item'],
        defaultPieChartProps = _objectSpread(
          _objectSpread({}, defaultPolarChartProps),
          {},
          { layout: 'centric', startAngle: 0, endAngle: 360 }
        ),
        PieChart = (0, react.forwardRef)((props, ref) => {
          var propsWithDefaults = (0, resolveDefaultProps.e)(props, defaultPieChartProps);
          return react.createElement(PolarChart, {
            chartName: 'PieChart',
            defaultTooltipEventType: 'item',
            validateTooltipEventTypes: allowedTooltipTypes,
            tooltipPayloadSearcher: optionsSlice.uN,
            categoricalChartProps: propsWithDefaults,
            ref,
          });
        });
    },
    './node_modules/recharts/es6/component/Cell.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { f: () => Cell });
      var Cell = (_props) => null;
      Cell.displayName = 'Cell';
    },
    './node_modules/recharts/es6/component/Label.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        JU: () => Label,
        ZY: () => isLabelContentAFunction,
        _I: () => CartesianLabelFromLabelProp,
        zJ: () => CartesianLabelContextProvider,
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/clsx/dist/clsx.mjs'
        ),
        _Text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/component/Text.js'
        ),
        _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        ),
        _util_PolarUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/util/PolarUtils.js'
        ),
        _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        _state_hooks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _state_selectors_polarAxisSelectors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/polarAxisSelectors.js'
        ),
        _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesAndEvents.js'
        ),
        _zIndex_ZIndexLayer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          './node_modules/recharts/es6/zIndex/ZIndexLayer.js'
        ),
        _zIndex_DefaultZIndexes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
          './node_modules/recharts/es6/zIndex/DefaultZIndexes.js'
        ),
        _excluded = ['labelRef'],
        _excluded2 = ['content'];
      function _objectWithoutProperties(e, t) {
        if (null == e) return {};
        var o,
          r,
          i = (function _objectWithoutPropertiesLoose(r, e) {
            if (null == r) return {};
            var t = {};
            for (var n in r)
              if ({}.hasOwnProperty.call(r, n)) {
                if (-1 !== e.indexOf(n)) continue;
                t[n] = r[n];
              }
            return t;
          })(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++)
            ((o = n[r]),
              -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
        }
        return i;
      }
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      var CartesianLabelContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null),
        CartesianLabelContextProvider = (_ref) => {
          var { x, y, upperWidth, lowerWidth, width, height, children } = _ref,
            viewBox = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(
              () => ({ x, y, upperWidth, lowerWidth, width, height }),
              [x, y, upperWidth, lowerWidth, width, height]
            );
          return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
            CartesianLabelContext.Provider,
            { value: viewBox },
            children
          );
        },
        useCartesianLabelContext = () => {
          var labelChildContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(
              CartesianLabelContext
            ),
            chartContext = (0, _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_5__.sk)();
          return (
            labelChildContext ||
            (0, _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_5__.qC)(chartContext)
          );
        },
        PolarLabelContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null),
        usePolarLabelContext = () => {
          var labelChildContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(
              PolarLabelContext
            ),
            chartContext = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_6__.G)(
              _state_selectors_polarAxisSelectors__WEBPACK_IMPORTED_MODULE_7__.D0
            );
          return labelChildContext || chartContext;
        },
        isLabelContentAFunction = (content) => null != content && 'function' == typeof content,
        renderRadialLabel = (labelProps, position, label, attrs, viewBox) => {
          var labelAngle,
            direction,
            { offset, className } = labelProps,
            { cx, cy, innerRadius, outerRadius, startAngle, endAngle, clockWise } = viewBox,
            radius = (innerRadius + outerRadius) / 2,
            deltaAngle = ((startAngle, endAngle) =>
              (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.sA)(endAngle - startAngle) *
              Math.min(Math.abs(endAngle - startAngle), 360))(startAngle, endAngle),
            sign = deltaAngle >= 0 ? 1 : -1;
          switch (position) {
            case 'insideStart':
              ((labelAngle = startAngle + sign * offset), (direction = clockWise));
              break;
            case 'insideEnd':
              ((labelAngle = endAngle - sign * offset), (direction = !clockWise));
              break;
            case 'end':
              ((labelAngle = endAngle + sign * offset), (direction = clockWise));
              break;
            default:
              throw new Error('Unsupported position '.concat(position));
          }
          direction = deltaAngle <= 0 ? direction : !direction;
          var startPoint = (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_4__.IZ)(
              cx,
              cy,
              radius,
              labelAngle
            ),
            endPoint = (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_4__.IZ)(
              cx,
              cy,
              radius,
              labelAngle + 359 * (direction ? 1 : -1)
            ),
            path = 'M'
              .concat(startPoint.x, ',')
              .concat(startPoint.y, '\n    A')
              .concat(radius, ',')
              .concat(radius, ',0,1,')
              .concat(direction ? 0 : 1, ',\n    ')
              .concat(endPoint.x, ',')
              .concat(endPoint.y),
            id = (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.uy)(labelProps.id)
              ? (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.NF)('recharts-radial-line-')
              : labelProps.id;
          return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
            'text',
            _extends({}, attrs, {
              dominantBaseline: 'central',
              className: (0, clsx__WEBPACK_IMPORTED_MODULE_1__.$)(
                'recharts-radial-bar-label',
                className
              ),
            }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(
              'defs',
              null,
              react__WEBPACK_IMPORTED_MODULE_0__.createElement('path', { id, d: path })
            ),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(
              'textPath',
              { xlinkHref: '#'.concat(id) },
              label
            )
          );
        },
        isPolar = (viewBox) =>
          'cx' in viewBox && (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.Et)(viewBox.cx),
        defaultLabelProps = {
          angle: 0,
          offset: 5,
          zIndex: _zIndex_DefaultZIndexes__WEBPACK_IMPORTED_MODULE_11__.I.label,
          position: 'middle',
          textBreakAll: !1,
        };
      function Label(outerProps) {
        var viewBox,
          label,
          positionAttrs,
          props = (0, _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_8__.e)(
            outerProps,
            defaultLabelProps
          ),
          {
            viewBox: viewBoxFromProps,
            position,
            value,
            children,
            content,
            className = '',
            textBreakAll,
            labelRef,
          } = props,
          polarViewBox = usePolarLabelContext(),
          cartesianViewBox = useCartesianLabelContext();
        if (
          !(viewBox =
            null == viewBoxFromProps
              ? 'center' === position
                ? cartesianViewBox
                : null != polarViewBox
                  ? polarViewBox
                  : cartesianViewBox
              : isPolar(viewBoxFromProps)
                ? viewBoxFromProps
                : (0, _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_5__.qC)(
                    viewBoxFromProps
                  )) ||
          ((0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.uy)(value) &&
            (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.uy)(children) &&
            !(0, react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(content) &&
            'function' != typeof content)
        )
          return null;
        var propsWithViewBox = _objectSpread(_objectSpread({}, props), {}, { viewBox });
        if ((0, react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(content)) {
          var { labelRef: _ } = propsWithViewBox,
            propsWithoutLabelRef = _objectWithoutProperties(propsWithViewBox, _excluded);
          return (0, react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(
            content,
            propsWithoutLabelRef
          );
        }
        if ('function' == typeof content) {
          var { content: _2 } = propsWithViewBox,
            propsForContent = _objectWithoutProperties(propsWithViewBox, _excluded2);
          if (
            ((label = (0, react__WEBPACK_IMPORTED_MODULE_0__.createElement)(
              content,
              propsForContent
            )),
            (0, react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(label))
          )
            return label;
        } else
          label = ((props) => {
            var { value, formatter } = props,
              label = (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.uy)(props.children)
                ? value
                : props.children;
            return 'function' == typeof formatter ? formatter(label) : label;
          })(props);
        var attrs = (0, _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_9__.a)(props);
        if (isPolar(viewBox)) {
          if ('insideStart' === position || 'insideEnd' === position || 'end' === position)
            return renderRadialLabel(props, position, label, attrs, viewBox);
          positionAttrs = ((viewBox, offset, position) => {
            var { cx, cy, innerRadius, outerRadius, startAngle, endAngle } = viewBox,
              midAngle = (startAngle + endAngle) / 2;
            if ('outside' === position) {
              var { x: _x, y: _y } = (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_4__.IZ)(
                cx,
                cy,
                outerRadius + offset,
                midAngle
              );
              return {
                x: _x,
                y: _y,
                textAnchor: _x >= cx ? 'start' : 'end',
                verticalAnchor: 'middle',
              };
            }
            if ('center' === position)
              return { x: cx, y: cy, textAnchor: 'middle', verticalAnchor: 'middle' };
            if ('centerTop' === position)
              return { x: cx, y: cy, textAnchor: 'middle', verticalAnchor: 'start' };
            if ('centerBottom' === position)
              return { x: cx, y: cy, textAnchor: 'middle', verticalAnchor: 'end' };
            var r = (innerRadius + outerRadius) / 2,
              { x, y } = (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_4__.IZ)(cx, cy, r, midAngle);
            return { x, y, textAnchor: 'middle', verticalAnchor: 'middle' };
          })(viewBox, props.offset, props.position);
        } else
          positionAttrs = ((props, viewBox) => {
            var parentViewBox,
              { parentViewBox: parentViewBoxFromProps, offset, position } = props;
            null == parentViewBoxFromProps ||
              isPolar(parentViewBoxFromProps) ||
              (parentViewBox = parentViewBoxFromProps);
            var { x, y, upperWidth, lowerWidth, height } = viewBox,
              upperX = x,
              lowerX = x + (upperWidth - lowerWidth) / 2,
              middleX = (upperX + lowerX) / 2,
              midHeightWidth = (upperWidth + lowerWidth) / 2,
              centerX = upperX + upperWidth / 2,
              verticalSign = height >= 0 ? 1 : -1,
              verticalOffset = verticalSign * offset,
              verticalEnd = verticalSign > 0 ? 'end' : 'start',
              verticalStart = verticalSign > 0 ? 'start' : 'end',
              horizontalSign = upperWidth >= 0 ? 1 : -1,
              horizontalOffset = horizontalSign * offset,
              horizontalEnd = horizontalSign > 0 ? 'end' : 'start',
              horizontalStart = horizontalSign > 0 ? 'start' : 'end';
            if ('top' === position)
              return _objectSpread(
                _objectSpread(
                  {},
                  {
                    x: upperX + upperWidth / 2,
                    y: y - verticalOffset,
                    textAnchor: 'middle',
                    verticalAnchor: verticalEnd,
                  }
                ),
                parentViewBox ? { height: Math.max(y - parentViewBox.y, 0), width: upperWidth } : {}
              );
            if ('bottom' === position)
              return _objectSpread(
                _objectSpread(
                  {},
                  {
                    x: lowerX + lowerWidth / 2,
                    y: y + height + verticalOffset,
                    textAnchor: 'middle',
                    verticalAnchor: verticalStart,
                  }
                ),
                parentViewBox
                  ? {
                      height: Math.max(parentViewBox.y + parentViewBox.height - (y + height), 0),
                      width: lowerWidth,
                    }
                  : {}
              );
            if ('left' === position) {
              var _attrs2 = {
                x: middleX - horizontalOffset,
                y: y + height / 2,
                textAnchor: horizontalEnd,
                verticalAnchor: 'middle',
              };
              return _objectSpread(
                _objectSpread({}, _attrs2),
                parentViewBox ? { width: Math.max(_attrs2.x - parentViewBox.x, 0), height } : {}
              );
            }
            if ('right' === position) {
              var _attrs3 = {
                x: middleX + midHeightWidth + horizontalOffset,
                y: y + height / 2,
                textAnchor: horizontalStart,
                verticalAnchor: 'middle',
              };
              return _objectSpread(
                _objectSpread({}, _attrs3),
                parentViewBox
                  ? {
                      width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
                      height,
                    }
                  : {}
              );
            }
            var sizeAttrs = parentViewBox ? { width: midHeightWidth, height } : {};
            return 'insideLeft' === position
              ? _objectSpread(
                  {
                    x: middleX + horizontalOffset,
                    y: y + height / 2,
                    textAnchor: horizontalStart,
                    verticalAnchor: 'middle',
                  },
                  sizeAttrs
                )
              : 'insideRight' === position
                ? _objectSpread(
                    {
                      x: middleX + midHeightWidth - horizontalOffset,
                      y: y + height / 2,
                      textAnchor: horizontalEnd,
                      verticalAnchor: 'middle',
                    },
                    sizeAttrs
                  )
                : 'insideTop' === position
                  ? _objectSpread(
                      {
                        x: upperX + upperWidth / 2,
                        y: y + verticalOffset,
                        textAnchor: 'middle',
                        verticalAnchor: verticalStart,
                      },
                      sizeAttrs
                    )
                  : 'insideBottom' === position
                    ? _objectSpread(
                        {
                          x: lowerX + lowerWidth / 2,
                          y: y + height - verticalOffset,
                          textAnchor: 'middle',
                          verticalAnchor: verticalEnd,
                        },
                        sizeAttrs
                      )
                    : 'insideTopLeft' === position
                      ? _objectSpread(
                          {
                            x: upperX + horizontalOffset,
                            y: y + verticalOffset,
                            textAnchor: horizontalStart,
                            verticalAnchor: verticalStart,
                          },
                          sizeAttrs
                        )
                      : 'insideTopRight' === position
                        ? _objectSpread(
                            {
                              x: upperX + upperWidth - horizontalOffset,
                              y: y + verticalOffset,
                              textAnchor: horizontalEnd,
                              verticalAnchor: verticalStart,
                            },
                            sizeAttrs
                          )
                        : 'insideBottomLeft' === position
                          ? _objectSpread(
                              {
                                x: lowerX + horizontalOffset,
                                y: y + height - verticalOffset,
                                textAnchor: horizontalStart,
                                verticalAnchor: verticalEnd,
                              },
                              sizeAttrs
                            )
                          : 'insideBottomRight' === position
                            ? _objectSpread(
                                {
                                  x: lowerX + lowerWidth - horizontalOffset,
                                  y: y + height - verticalOffset,
                                  textAnchor: horizontalEnd,
                                  verticalAnchor: verticalEnd,
                                },
                                sizeAttrs
                              )
                            : position &&
                                'object' == typeof position &&
                                ((0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.Et)(position.x) ||
                                  (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__._3)(
                                    position.x
                                  )) &&
                                ((0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.Et)(position.y) ||
                                  (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__._3)(position.y))
                              ? _objectSpread(
                                  {
                                    x:
                                      x +
                                      (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.F4)(
                                        position.x,
                                        midHeightWidth
                                      ),
                                    y:
                                      y +
                                      (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.F4)(
                                        position.y,
                                        height
                                      ),
                                    textAnchor: 'end',
                                    verticalAnchor: 'end',
                                  },
                                  sizeAttrs
                                )
                              : _objectSpread(
                                  {
                                    x: centerX,
                                    y: y + height / 2,
                                    textAnchor: 'middle',
                                    verticalAnchor: 'middle',
                                  },
                                  sizeAttrs
                                );
          })(props, viewBox);
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
          _zIndex_ZIndexLayer__WEBPACK_IMPORTED_MODULE_10__.g,
          { zIndex: props.zIndex },
          react__WEBPACK_IMPORTED_MODULE_0__.createElement(
            _Text__WEBPACK_IMPORTED_MODULE_2__.EY,
            _extends(
              {
                ref: labelRef,
                className: (0, clsx__WEBPACK_IMPORTED_MODULE_1__.$)('recharts-label', className),
              },
              attrs,
              positionAttrs,
              {
                textAnchor: (0, _Text__WEBPACK_IMPORTED_MODULE_2__.fU)(attrs.textAnchor)
                  ? attrs.textAnchor
                  : positionAttrs.textAnchor,
                breakAll: textBreakAll,
              }
            ),
            label
          )
        );
      }
      Label.displayName = 'Label';
      var parseLabel = (label, viewBox, labelRef) => {
        if (!label) return null;
        var commonProps = { viewBox, labelRef };
        return !0 === label
          ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(
              Label,
              _extends({ key: 'label-implicit' }, commonProps)
            )
          : (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.vh)(label)
            ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(
                Label,
                _extends({ key: 'label-implicit', value: label }, commonProps)
              )
            : (0, react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(label)
              ? label.type === Label
                ? (0, react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(
                    label,
                    _objectSpread({ key: 'label-implicit' }, commonProps)
                  )
                : react__WEBPACK_IMPORTED_MODULE_0__.createElement(
                    Label,
                    _extends({ key: 'label-implicit', content: label }, commonProps)
                  )
              : isLabelContentAFunction(label)
                ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(
                    Label,
                    _extends({ key: 'label-implicit', content: label }, commonProps)
                  )
                : label && 'object' == typeof label
                  ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(
                      Label,
                      _extends({}, label, { key: 'label-implicit' }, commonProps)
                    )
                  : null;
      };
      function CartesianLabelFromLabelProp(_ref3) {
        var { label, labelRef } = _ref3,
          viewBox = useCartesianLabelContext();
        return parseLabel(label, viewBox, labelRef) || null;
      }
    },
    './node_modules/recharts/es6/component/LabelList.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        dL: () => PolarLabelListContextProvider,
        h8: () => CartesianLabelListContextProvider,
        qY: () => LabelListFromLabelProp,
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        es_toolkit_compat_last__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/es-toolkit/compat/last.js'
        ),
        es_toolkit_compat_last__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(
          es_toolkit_compat_last__WEBPACK_IMPORTED_MODULE_1__
        ),
        _Label__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/component/Label.js'
        ),
        _container_Layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/container/Layer.js'
        ),
        _util_ChartUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/util/ChartUtils.js'
        ),
        _util_DataUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        ),
        _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesAndEvents.js'
        ),
        _zIndex_ZIndexLayer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          './node_modules/recharts/es6/zIndex/ZIndexLayer.js'
        ),
        _zIndex_DefaultZIndexes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          './node_modules/recharts/es6/zIndex/DefaultZIndexes.js'
        ),
        _excluded = ['valueAccessor'],
        _excluded2 = ['dataKey', 'clockWise', 'id', 'textBreakAll', 'zIndex'];
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function _objectWithoutProperties(e, t) {
        if (null == e) return {};
        var o,
          r,
          i = (function _objectWithoutPropertiesLoose(r, e) {
            if (null == r) return {};
            var t = {};
            for (var n in r)
              if ({}.hasOwnProperty.call(r, n)) {
                if (-1 !== e.indexOf(n)) continue;
                t[n] = r[n];
              }
            return t;
          })(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++)
            ((o = n[r]),
              -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
        }
        return i;
      }
      var defaultAccessor = (entry) =>
          Array.isArray(entry.value)
            ? es_toolkit_compat_last__WEBPACK_IMPORTED_MODULE_1___default()(entry.value)
            : entry.value,
        CartesianLabelListContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0),
        CartesianLabelListContextProvider = CartesianLabelListContext.Provider,
        PolarLabelListContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0),
        PolarLabelListContextProvider = PolarLabelListContext.Provider;
      function LabelList(_ref) {
        var { valueAccessor = defaultAccessor } = _ref,
          restProps = _objectWithoutProperties(_ref, _excluded),
          { dataKey, clockWise, id, textBreakAll, zIndex } = restProps,
          others = _objectWithoutProperties(restProps, _excluded2),
          cartesianData = (function useCartesianLabelListContext() {
            return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CartesianLabelListContext);
          })(),
          polarData = (function usePolarLabelListContext() {
            return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PolarLabelListContext);
          })(),
          data = cartesianData || polarData;
        return data && data.length
          ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(
              _zIndex_ZIndexLayer__WEBPACK_IMPORTED_MODULE_7__.g,
              {
                zIndex:
                  null != zIndex
                    ? zIndex
                    : _zIndex_DefaultZIndexes__WEBPACK_IMPORTED_MODULE_8__.I.label,
              },
              react__WEBPACK_IMPORTED_MODULE_0__.createElement(
                _container_Layer__WEBPACK_IMPORTED_MODULE_3__.W,
                { className: 'recharts-label-list' },
                data.map((entry, index) => {
                  var _restProps$fill,
                    value = (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_5__.uy)(dataKey)
                      ? valueAccessor(entry, index)
                      : (0, _util_ChartUtils__WEBPACK_IMPORTED_MODULE_4__.kr)(
                          entry && entry.payload,
                          dataKey
                        ),
                    idProps = (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_5__.uy)(id)
                      ? {}
                      : { id: ''.concat(id, '-').concat(index) };
                  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
                    _Label__WEBPACK_IMPORTED_MODULE_2__.JU,
                    _extends(
                      { key: 'label-'.concat(index) },
                      (0, _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_6__.a)(entry),
                      others,
                      idProps,
                      {
                        fill:
                          null !== (_restProps$fill = restProps.fill) && void 0 !== _restProps$fill
                            ? _restProps$fill
                            : entry.fill,
                        parentViewBox: entry.parentViewBox,
                        value,
                        textBreakAll,
                        viewBox: entry.viewBox,
                        index,
                        zIndex: 0,
                      }
                    )
                  );
                })
              )
            )
          : null;
      }
      function LabelListFromLabelProp(_ref2) {
        var { label } = _ref2;
        return label
          ? !0 === label
            ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(LabelList, {
                key: 'labelList-implicit',
              })
            : react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(label) ||
                (0, _Label__WEBPACK_IMPORTED_MODULE_2__.ZY)(label)
              ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(LabelList, {
                  key: 'labelList-implicit',
                  content: label,
                })
              : 'object' == typeof label
                ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(
                    LabelList,
                    _extends({ key: 'labelList-implicit' }, label, { type: String(label.type) })
                  )
                : null
          : null;
      }
      LabelList.displayName = 'LabelList';
    },
    './node_modules/recharts/es6/component/ResponsiveContainer.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        u: () => ResponsiveContainer,
        w: () => useResponsiveContainerContext,
      });
      var clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
        react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        throttle = __webpack_require__('./node_modules/es-toolkit/compat/throttle.js'),
        throttle_default = __webpack_require__.n(throttle),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        console = __webpack_require__('./node_modules/console-browserify/index.js'),
        warn = function warn(condition, format) {
          for (
            var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2;
            _key < _len;
            _key++
          )
            args[_key - 2] = arguments[_key];
          if (
            void 0 !== console &&
            console.warn &&
            (void 0 === format && console.warn('LogUtils requires an error message argument'),
            !condition)
          )
            if (void 0 === format)
              console.warn(
                'Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.'
              );
            else {
              var argIndex = 0;
              console.warn(format.replace(/%s/g, () => args[argIndex++]));
            }
        },
        calculateChartDimensions = (containerWidth, containerHeight, props) => {
          var { width = '100%', height = '100%', aspect, maxHeight } = props,
            calculatedWidth = (0, DataUtils._3)(width) ? containerWidth : Number(width),
            calculatedHeight = (0, DataUtils._3)(height) ? containerHeight : Number(height);
          return (
            aspect &&
              aspect > 0 &&
              (calculatedWidth
                ? (calculatedHeight = calculatedWidth / aspect)
                : calculatedHeight && (calculatedWidth = calculatedHeight * aspect),
              maxHeight &&
                null != calculatedHeight &&
                calculatedHeight > maxHeight &&
                (calculatedHeight = maxHeight)),
            { calculatedWidth, calculatedHeight }
          );
        },
        bothOverflow = { width: 0, height: 0, overflow: 'visible' },
        overflowX = { width: 0, overflowX: 'visible' },
        overflowY = { height: 0, overflowY: 'visible' },
        noStyle = {},
        getInnerDivStyle = (props) => {
          var { width, height } = props,
            isWidthPercent = (0, DataUtils._3)(width),
            isHeightPercent = (0, DataUtils._3)(height);
          return isWidthPercent && isHeightPercent
            ? bothOverflow
            : isWidthPercent
              ? overflowX
              : isHeightPercent
                ? overflowY
                : noStyle;
        };
      var isWellBehavedNumber = __webpack_require__(
        './node_modules/recharts/es6/util/isWellBehavedNumber.js'
      );
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var ResponsiveContainerContext = (0, react.createContext)({ width: -1, height: -1 });
      function ResponsiveContainerContextProvider(_ref) {
        var { children, width, height } = _ref,
          size = (0, react.useMemo)(() => ({ width, height }), [width, height]);
        return (function isAcceptableSize(size) {
          return (0, isWellBehavedNumber.F)(size.width) && (0, isWellBehavedNumber.F)(size.height);
        })(size)
          ? react.createElement(ResponsiveContainerContext.Provider, { value: size }, children)
          : null;
      }
      var useResponsiveContainerContext = () => (0, react.useContext)(ResponsiveContainerContext),
        SizeDetectorContainer = (0, react.forwardRef)((_ref2, ref) => {
          var {
              aspect,
              initialDimension = { width: -1, height: -1 },
              width,
              height,
              minWidth = 0,
              minHeight,
              maxHeight,
              children,
              debounce = 0,
              id,
              className,
              onResize,
              style = {},
            } = _ref2,
            containerRef = (0, react.useRef)(null),
            onResizeRef = (0, react.useRef)();
          ((onResizeRef.current = onResize),
            (0, react.useImperativeHandle)(ref, () => containerRef.current));
          var [sizes, setSizes] = (0, react.useState)({
              containerWidth: initialDimension.width,
              containerHeight: initialDimension.height,
            }),
            setContainerSize = (0, react.useCallback)((newWidth, newHeight) => {
              setSizes((prevState) => {
                var roundedWidth = Math.round(newWidth),
                  roundedHeight = Math.round(newHeight);
                return prevState.containerWidth === roundedWidth &&
                  prevState.containerHeight === roundedHeight
                  ? prevState
                  : { containerWidth: roundedWidth, containerHeight: roundedHeight };
              });
            }, []);
          (0, react.useEffect)(() => {
            if (null == containerRef.current || 'undefined' == typeof ResizeObserver)
              return DataUtils.lQ;
            var callback = (entries) => {
              var _onResizeRef$current,
                { width: containerWidth, height: containerHeight } = entries[0].contentRect;
              (setContainerSize(containerWidth, containerHeight),
                null === (_onResizeRef$current = onResizeRef.current) ||
                  void 0 === _onResizeRef$current ||
                  _onResizeRef$current.call(onResizeRef, containerWidth, containerHeight));
            };
            debounce > 0 &&
              (callback = throttle_default()(callback, debounce, { trailing: !0, leading: !1 }));
            var observer = new ResizeObserver(callback),
              { width: containerWidth, height: containerHeight } =
                containerRef.current.getBoundingClientRect();
            return (
              setContainerSize(containerWidth, containerHeight),
              observer.observe(containerRef.current),
              () => {
                observer.disconnect();
              }
            );
          }, [setContainerSize, debounce]);
          var { containerWidth, containerHeight } = sizes;
          warn(!aspect || aspect > 0, 'The aspect(%s) must be greater than zero.', aspect);
          var { calculatedWidth, calculatedHeight } = calculateChartDimensions(
            containerWidth,
            containerHeight,
            { width, height, aspect, maxHeight }
          );
          return (
            warn(
              (null != calculatedWidth && calculatedWidth > 0) ||
                (null != calculatedHeight && calculatedHeight > 0),
              'The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.',
              calculatedWidth,
              calculatedHeight,
              width,
              height,
              minWidth,
              minHeight,
              aspect
            ),
            react.createElement(
              'div',
              {
                id: id ? ''.concat(id) : void 0,
                className: (0, clsx.$)('recharts-responsive-container', className),
                style: _objectSpread(
                  _objectSpread({}, style),
                  {},
                  { width, height, minWidth, minHeight, maxHeight }
                ),
                ref: containerRef,
              },
              react.createElement(
                'div',
                { style: getInnerDivStyle({ width, height }) },
                react.createElement(
                  ResponsiveContainerContextProvider,
                  { width: calculatedWidth, height: calculatedHeight },
                  children
                )
              )
            )
          );
        }),
        ResponsiveContainer = (0, react.forwardRef)((props, ref) => {
          var responsiveContainerContext = useResponsiveContainerContext();
          if (
            (0, isWellBehavedNumber.F)(responsiveContainerContext.width) &&
            (0, isWellBehavedNumber.F)(responsiveContainerContext.height)
          )
            return props.children;
          var { width, height } = (function getDefaultWidthAndHeight(_ref) {
              var { width, height, aspect } = _ref,
                calculatedWidth = width,
                calculatedHeight = height;
              return (
                void 0 === calculatedWidth && void 0 === calculatedHeight
                  ? ((calculatedWidth = '100%'), (calculatedHeight = '100%'))
                  : void 0 === calculatedWidth
                    ? (calculatedWidth = aspect && aspect > 0 ? void 0 : '100%')
                    : void 0 === calculatedHeight &&
                      (calculatedHeight = aspect && aspect > 0 ? void 0 : '100%'),
                { width: calculatedWidth, height: calculatedHeight }
              );
            })({ width: props.width, height: props.height, aspect: props.aspect }),
            { calculatedWidth, calculatedHeight } = calculateChartDimensions(void 0, void 0, {
              width,
              height,
              aspect: props.aspect,
              maxHeight: props.maxHeight,
            });
          return (0, DataUtils.Et)(calculatedWidth) && (0, DataUtils.Et)(calculatedHeight)
            ? react.createElement(
                ResponsiveContainerContextProvider,
                { width: calculatedWidth, height: calculatedHeight },
                props.children
              )
            : react.createElement(
                SizeDetectorContainer,
                _extends({}, props, { width, height, ref })
              );
        });
    },
    './node_modules/recharts/es6/component/Text.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { EY: () => Text, fU: () => isValidTextAnchor });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        Global = __webpack_require__('./node_modules/recharts/es6/util/Global.js'),
        DOMUtils = __webpack_require__('./node_modules/recharts/es6/util/DOMUtils.js');
      var MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/,
        ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/,
        CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/,
        NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/,
        CONVERSION_RATES = {
          cm: 96 / 2.54,
          mm: 96 / 25.4,
          pt: 96 / 72,
          pc: 16,
          in: 96,
          Q: 96 / 101.6,
          px: 1,
        },
        FIXED_CSS_LENGTH_UNITS = ['cm', 'mm', 'pt', 'pc', 'in', 'Q', 'px'];
      class DecimalCSS {
        static parse(str) {
          var _NUM_SPLIT_REGEX$exec,
            [, numStr, unit] =
              null !== (_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) &&
              void 0 !== _NUM_SPLIT_REGEX$exec
                ? _NUM_SPLIT_REGEX$exec
                : [];
          return null == numStr
            ? DecimalCSS.NaN
            : new DecimalCSS(parseFloat(numStr), null != unit ? unit : '');
        }
        constructor(num, unit) {
          ((this.num = num),
            (this.unit = unit),
            (this.num = num),
            (this.unit = unit),
            (0, DataUtils.M8)(num) && (this.unit = ''),
            '' === unit || CSS_LENGTH_UNIT_REGEX.test(unit) || ((this.num = NaN), (this.unit = '')),
            (function isSupportedUnit(unit) {
              return FIXED_CSS_LENGTH_UNITS.includes(unit);
            })(unit) &&
              ((this.num = (function convertToPx(value, unit) {
                return value * CONVERSION_RATES[unit];
              })(num, unit)),
              (this.unit = 'px')));
        }
        add(other) {
          return this.unit !== other.unit
            ? new DecimalCSS(NaN, '')
            : new DecimalCSS(this.num + other.num, this.unit);
        }
        subtract(other) {
          return this.unit !== other.unit
            ? new DecimalCSS(NaN, '')
            : new DecimalCSS(this.num - other.num, this.unit);
        }
        multiply(other) {
          return '' !== this.unit && '' !== other.unit && this.unit !== other.unit
            ? new DecimalCSS(NaN, '')
            : new DecimalCSS(this.num * other.num, this.unit || other.unit);
        }
        divide(other) {
          return '' !== this.unit && '' !== other.unit && this.unit !== other.unit
            ? new DecimalCSS(NaN, '')
            : new DecimalCSS(this.num / other.num, this.unit || other.unit);
        }
        toString() {
          return ''.concat(this.num).concat(this.unit);
        }
        isNaN() {
          return (0, DataUtils.M8)(this.num);
        }
      }
      function calculateArithmetic(expr) {
        if (null == expr || expr.includes('NaN')) return 'NaN';
        for (var newExpr = expr; newExpr.includes('*') || newExpr.includes('/'); ) {
          var _MULTIPLY_OR_DIVIDE_R,
            [, leftOperand, operator, rightOperand] =
              null !== (_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) &&
              void 0 !== _MULTIPLY_OR_DIVIDE_R
                ? _MULTIPLY_OR_DIVIDE_R
                : [],
            lTs = DecimalCSS.parse(null != leftOperand ? leftOperand : ''),
            rTs = DecimalCSS.parse(null != rightOperand ? rightOperand : ''),
            result = '*' === operator ? lTs.multiply(rTs) : lTs.divide(rTs);
          if (result.isNaN()) return 'NaN';
          newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());
        }
        for (; newExpr.includes('+') || /.-\d+(?:\.\d+)?/.test(newExpr); ) {
          var _ADD_OR_SUBTRACT_REGE,
            [, _leftOperand, _operator, _rightOperand] =
              null !== (_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) &&
              void 0 !== _ADD_OR_SUBTRACT_REGE
                ? _ADD_OR_SUBTRACT_REGE
                : [],
            _lTs = DecimalCSS.parse(null != _leftOperand ? _leftOperand : ''),
            _rTs = DecimalCSS.parse(null != _rightOperand ? _rightOperand : ''),
            _result = '+' === _operator ? _lTs.add(_rTs) : _lTs.subtract(_rTs);
          if (_result.isNaN()) return 'NaN';
          newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());
        }
        return newExpr;
      }
      (function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      })(DecimalCSS, 'NaN', new DecimalCSS(NaN, ''));
      var PARENTHESES_REGEX = /\(([^()]*)\)/;
      function evaluateExpression(expression) {
        var newExpr = expression.replace(/\s+/g, '');
        return (
          (newExpr = (function calculateParentheses(expr) {
            for (var match, newExpr = expr; null != (match = PARENTHESES_REGEX.exec(newExpr)); ) {
              var [, parentheticalExpression] = match;
              newExpr = newExpr.replace(
                PARENTHESES_REGEX,
                calculateArithmetic(parentheticalExpression)
              );
            }
            return newExpr;
          })(newExpr)),
          (newExpr = calculateArithmetic(newExpr))
        );
      }
      function reduceCSSCalc(expression) {
        var result = (function safeEvaluateExpression(expression) {
          try {
            return evaluateExpression(expression);
          } catch (_unused) {
            return 'NaN';
          }
        })(expression.slice(5, -1));
        return 'NaN' === result ? '' : result;
      }
      var svgPropertiesAndEvents = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesAndEvents.js'
        ),
        resolveDefaultProps = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        isWellBehavedNumber = __webpack_require__(
          './node_modules/recharts/es6/util/isWellBehavedNumber.js'
        ),
        _excluded = [
          'x',
          'y',
          'lineHeight',
          'capHeight',
          'fill',
          'scaleToFit',
          'textAnchor',
          'verticalAnchor',
        ],
        _excluded2 = ['dx', 'dy', 'angle', 'className', 'breakAll'];
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function _objectWithoutProperties(e, t) {
        if (null == e) return {};
        var o,
          r,
          i = (function _objectWithoutPropertiesLoose(r, e) {
            if (null == r) return {};
            var t = {};
            for (var n in r)
              if ({}.hasOwnProperty.call(r, n)) {
                if (-1 !== e.indexOf(n)) continue;
                t[n] = r[n];
              }
            return t;
          })(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++)
            ((o = n[r]),
              -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
        }
        return i;
      }
      var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/,
        calculateWordWidths = (_ref) => {
          var { children, breakAll, style } = _ref;
          try {
            var words = [];
            return (
              (0, DataUtils.uy)(children) ||
                (words = breakAll
                  ? children.toString().split('')
                  : children.toString().split(BREAKING_SPACES)),
              {
                wordsWithComputedWidth: words.map((word) => ({
                  word,
                  width: (0, DOMUtils.Pu)(word, style).width,
                })),
                spaceWidth: breakAll ? 0 : (0, DOMUtils.Pu)('', style).width,
              }
            );
          } catch (_unused) {
            return null;
          }
        };
      function isValidTextAnchor(value) {
        return 'start' === value || 'middle' === value || 'end' === value || 'inherit' === value;
      }
      var calculate = (words, lineWidth, spaceWidth, scaleToFit) =>
          words.reduce((result, _ref2) => {
            var { word, width } = _ref2,
              currentLine = result[result.length - 1];
            if (
              currentLine &&
              null != width &&
              (null == lineWidth ||
                scaleToFit ||
                currentLine.width + width + spaceWidth < Number(lineWidth))
            )
              (currentLine.words.push(word), (currentLine.width += width + spaceWidth));
            else {
              var newLine = { words: [word], width };
              result.push(newLine);
            }
            return result;
          }, []),
        findLongestLine = (words) => words.reduce((a, b) => (a.width > b.width ? a : b)),
        checkOverflow = (
          text,
          index,
          breakAll,
          style,
          maxLines,
          lineWidth,
          spaceWidth,
          scaleToFit
        ) => {
          var tempText = text.slice(0, index),
            words = calculateWordWidths({ breakAll, style, children: tempText + '' });
          if (!words) return [!1, []];
          var result = calculate(words.wordsWithComputedWidth, lineWidth, spaceWidth, scaleToFit);
          return [
            result.length > maxLines || findLongestLine(result).width > Number(lineWidth),
            result,
          ];
        },
        getWordsWithoutCalculate = (children) => [
          {
            words: (0, DataUtils.uy)(children) ? [] : children.toString().split(BREAKING_SPACES),
            width: void 0,
          },
        ],
        getWordsByLines = (_ref4) => {
          var { width, scaleToFit, children, style, breakAll, maxLines } = _ref4;
          if ((width || scaleToFit) && !Global.m.isSsr) {
            var wordWidths = calculateWordWidths({ breakAll, children, style });
            if (!wordWidths) return getWordsWithoutCalculate(children);
            var { wordsWithComputedWidth: wcw, spaceWidth: sw } = wordWidths;
            return ((_ref3, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) => {
              var { maxLines, children, style, breakAll } = _ref3,
                shouldLimitLines = (0, DataUtils.Et)(maxLines),
                text = String(children),
                originalResult = calculate(
                  initialWordsWithComputedWith,
                  lineWidth,
                  spaceWidth,
                  scaleToFit
                );
              if (!shouldLimitLines || scaleToFit) return originalResult;
              if (
                !(
                  originalResult.length > maxLines ||
                  findLongestLine(originalResult).width > Number(lineWidth)
                )
              )
                return originalResult;
              for (
                var trimmedResult, start = 0, end = text.length - 1, iterations = 0;
                start <= end && iterations <= text.length - 1;
              ) {
                var middle = Math.floor((start + end) / 2),
                  prev = middle - 1,
                  [doesPrevOverflow, result] = checkOverflow(
                    text,
                    prev,
                    breakAll,
                    style,
                    maxLines,
                    lineWidth,
                    spaceWidth,
                    scaleToFit
                  ),
                  [doesMiddleOverflow] = checkOverflow(
                    text,
                    middle,
                    breakAll,
                    style,
                    maxLines,
                    lineWidth,
                    spaceWidth,
                    scaleToFit
                  );
                if (
                  (doesPrevOverflow || doesMiddleOverflow || (start = middle + 1),
                  doesPrevOverflow && doesMiddleOverflow && (end = middle - 1),
                  !doesPrevOverflow && doesMiddleOverflow)
                ) {
                  trimmedResult = result;
                  break;
                }
                iterations++;
              }
              return trimmedResult || originalResult;
            })({ breakAll, children, maxLines, style }, wcw, sw, width, Boolean(scaleToFit));
          }
          return getWordsWithoutCalculate(children);
        },
        textDefaultProps = {
          angle: 0,
          breakAll: !1,
          capHeight: '0.71em',
          fill: '#808080',
          lineHeight: '1em',
          scaleToFit: !1,
          textAnchor: 'start',
          verticalAnchor: 'end',
          x: 0,
          y: 0,
        },
        Text = (0, react.forwardRef)((outsideProps, ref) => {
          var _resolveDefaultProps = (0, resolveDefaultProps.e)(outsideProps, textDefaultProps),
            {
              x: propsX,
              y: propsY,
              lineHeight,
              capHeight,
              fill,
              scaleToFit,
              textAnchor,
              verticalAnchor,
            } = _resolveDefaultProps,
            props = _objectWithoutProperties(_resolveDefaultProps, _excluded),
            wordsByLines = (0, react.useMemo)(
              () =>
                getWordsByLines({
                  breakAll: props.breakAll,
                  children: props.children,
                  maxLines: props.maxLines,
                  scaleToFit,
                  style: props.style,
                  width: props.width,
                }),
              [props.breakAll, props.children, props.maxLines, scaleToFit, props.style, props.width]
            ),
            { dx, dy, angle, className, breakAll } = props,
            textProps = _objectWithoutProperties(props, _excluded2);
          if (!(0, DataUtils.vh)(propsX) || !(0, DataUtils.vh)(propsY) || 0 === wordsByLines.length)
            return null;
          var startDy,
            x = Number(propsX) + ((0, DataUtils.Et)(dx) ? dx : 0),
            y = Number(propsY) + ((0, DataUtils.Et)(dy) ? dy : 0);
          if (!(0, isWellBehavedNumber.H)(x) || !(0, isWellBehavedNumber.H)(y)) return null;
          switch (verticalAnchor) {
            case 'start':
              startDy = reduceCSSCalc('calc('.concat(capHeight, ')'));
              break;
            case 'middle':
              startDy = reduceCSSCalc(
                'calc('
                  .concat((wordsByLines.length - 1) / 2, ' * -')
                  .concat(lineHeight, ' + (')
                  .concat(capHeight, ' / 2))')
              );
              break;
            default:
              startDy = reduceCSSCalc(
                'calc('.concat(wordsByLines.length - 1, ' * -').concat(lineHeight, ')')
              );
          }
          var transforms = [];
          if (scaleToFit) {
            var lineWidth = wordsByLines[0].width,
              { width } = props;
            transforms.push(
              'scale('.concat(
                (0, DataUtils.Et)(width) && (0, DataUtils.Et)(lineWidth) ? width / lineWidth : 1,
                ')'
              )
            );
          }
          return (
            angle && transforms.push('rotate('.concat(angle, ', ').concat(x, ', ').concat(y, ')')),
            transforms.length && (textProps.transform = transforms.join(' ')),
            react.createElement(
              'text',
              _extends({}, (0, svgPropertiesAndEvents.a)(textProps), {
                ref,
                x,
                y,
                className: (0, clsx.$)('recharts-text', className),
                textAnchor,
                fill: fill.includes('url') ? '#808080' : fill,
              }),
              wordsByLines.map((line, index) => {
                var words = line.words.join(breakAll ? '' : ' ');
                return react.createElement(
                  'tspan',
                  {
                    x,
                    dy: 0 === index ? startDy : lineHeight,
                    key: ''.concat(words, '-').concat(index),
                  },
                  words
                );
              })
            )
          );
        });
      Text.displayName = 'Text';
    },
    './node_modules/recharts/es6/component/Tooltip.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { m: () => Tooltip });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        react_dom = __webpack_require__('./node_modules/next/dist/compiled/react-dom/index.js'),
        sortBy = __webpack_require__('./node_modules/es-toolkit/compat/sortBy.js'),
        sortBy_default = __webpack_require__.n(sortBy),
        clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js');
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function defaultFormatter(value) {
        return Array.isArray(value) && (0, DataUtils.vh)(value[0]) && (0, DataUtils.vh)(value[1])
          ? value.join(' ~ ')
          : value;
      }
      var DefaultTooltipContent = (props) => {
          var {
              separator = ' : ',
              contentStyle = {},
              itemStyle = {},
              labelStyle = {},
              payload,
              formatter,
              itemSorter,
              wrapperClassName,
              labelClassName,
              label,
              labelFormatter,
              accessibilityLayer = !1,
            } = props,
            finalStyle = _objectSpread(
              {
                margin: 0,
                padding: 10,
                backgroundColor: '#fff',
                border: '1px solid #ccc',
                whiteSpace: 'nowrap',
              },
              contentStyle
            ),
            finalLabelStyle = _objectSpread({ margin: 0 }, labelStyle),
            hasLabel = !(0, DataUtils.uy)(label),
            finalLabel = hasLabel ? label : '',
            wrapperCN = (0, clsx.$)('recharts-default-tooltip', wrapperClassName),
            labelCN = (0, clsx.$)('recharts-tooltip-label', labelClassName);
          hasLabel &&
            labelFormatter &&
            null != payload &&
            (finalLabel = labelFormatter(label, payload));
          var accessibilityAttributes = accessibilityLayer
            ? { role: 'status', 'aria-live': 'assertive' }
            : {};
          return react.createElement(
            'div',
            _extends({ className: wrapperCN, style: finalStyle }, accessibilityAttributes),
            react.createElement(
              'p',
              { className: labelCN, style: finalLabelStyle },
              react.isValidElement(finalLabel) ? finalLabel : ''.concat(finalLabel)
            ),
            (() => {
              if (payload && payload.length) {
                var items = (itemSorter ? sortBy_default()(payload, itemSorter) : payload).map(
                  (entry, i) => {
                    if ('none' === entry.type) return null;
                    var finalFormatter = entry.formatter || formatter || defaultFormatter,
                      { value, name } = entry,
                      finalValue = value,
                      finalName = name;
                    if (finalFormatter) {
                      var formatted = finalFormatter(value, name, entry, i, payload);
                      if (Array.isArray(formatted)) [finalValue, finalName] = formatted;
                      else {
                        if (null == formatted) return null;
                        finalValue = formatted;
                      }
                    }
                    var finalItemStyle = _objectSpread(
                      {
                        display: 'block',
                        paddingTop: 4,
                        paddingBottom: 4,
                        color: entry.color || '#000',
                      },
                      itemStyle
                    );
                    return react.createElement(
                      'li',
                      {
                        className: 'recharts-tooltip-item',
                        key: 'tooltip-item-'.concat(i),
                        style: finalItemStyle,
                      },
                      (0, DataUtils.vh)(finalName)
                        ? react.createElement(
                            'span',
                            { className: 'recharts-tooltip-item-name' },
                            finalName
                          )
                        : null,
                      (0, DataUtils.vh)(finalName)
                        ? react.createElement(
                            'span',
                            { className: 'recharts-tooltip-item-separator' },
                            separator
                          )
                        : null,
                      react.createElement(
                        'span',
                        { className: 'recharts-tooltip-item-value' },
                        finalValue
                      ),
                      react.createElement(
                        'span',
                        { className: 'recharts-tooltip-item-unit' },
                        entry.unit || ''
                      )
                    );
                  }
                );
                return react.createElement(
                  'ul',
                  { className: 'recharts-tooltip-item-list', style: { padding: 0, margin: 0 } },
                  items
                );
              }
              return null;
            })()
          );
        },
        CSS_CLASS_PREFIX = 'recharts-tooltip-wrapper',
        TOOLTIP_HIDDEN = { visibility: 'hidden' };
      function getTooltipCSSClassName(_ref) {
        var { coordinate, translateX, translateY } = _ref;
        return (0, clsx.$)(CSS_CLASS_PREFIX, {
          [''.concat(CSS_CLASS_PREFIX, '-right')]:
            (0, DataUtils.Et)(translateX) &&
            coordinate &&
            (0, DataUtils.Et)(coordinate.x) &&
            translateX >= coordinate.x,
          [''.concat(CSS_CLASS_PREFIX, '-left')]:
            (0, DataUtils.Et)(translateX) &&
            coordinate &&
            (0, DataUtils.Et)(coordinate.x) &&
            translateX < coordinate.x,
          [''.concat(CSS_CLASS_PREFIX, '-bottom')]:
            (0, DataUtils.Et)(translateY) &&
            coordinate &&
            (0, DataUtils.Et)(coordinate.y) &&
            translateY >= coordinate.y,
          [''.concat(CSS_CLASS_PREFIX, '-top')]:
            (0, DataUtils.Et)(translateY) &&
            coordinate &&
            (0, DataUtils.Et)(coordinate.y) &&
            translateY < coordinate.y,
        });
      }
      function getTooltipTranslateXY(_ref2) {
        var {
          allowEscapeViewBox,
          coordinate,
          key,
          offsetTopLeft,
          position,
          reverseDirection,
          tooltipDimension,
          viewBox,
          viewBoxDimension,
        } = _ref2;
        if (position && (0, DataUtils.Et)(position[key])) return position[key];
        var negative = coordinate[key] - tooltipDimension - (offsetTopLeft > 0 ? offsetTopLeft : 0),
          positive = coordinate[key] + offsetTopLeft;
        if (allowEscapeViewBox[key]) return reverseDirection[key] ? negative : positive;
        var viewBoxKey = viewBox[key];
        return null == viewBoxKey
          ? 0
          : reverseDirection[key]
            ? negative < viewBoxKey
              ? Math.max(positive, viewBoxKey)
              : Math.max(negative, viewBoxKey)
            : null == viewBoxDimension
              ? 0
              : positive + tooltipDimension > viewBoxKey + viewBoxDimension
                ? Math.max(negative, viewBoxKey)
                : Math.max(positive, viewBoxKey);
      }
      function TooltipBoundingBox_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function TooltipBoundingBox_objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? TooltipBoundingBox_ownKeys(Object(t), !0).forEach(function (r) {
                TooltipBoundingBox_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : TooltipBoundingBox_ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function TooltipBoundingBox_defineProperty(e, r, t) {
        return (
          (r = (function TooltipBoundingBox_toPropertyKey(t) {
            var i = (function TooltipBoundingBox_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      class TooltipBoundingBox extends react.PureComponent {
        constructor() {
          (super(...arguments),
            TooltipBoundingBox_defineProperty(this, 'state', {
              dismissed: !1,
              dismissedAtCoordinate: { x: 0, y: 0 },
            }),
            TooltipBoundingBox_defineProperty(this, 'handleKeyDown', (event) => {
              var _this$props$coordinat,
                _this$props$coordinat2,
                _this$props$coordinat3,
                _this$props$coordinat4;
              'Escape' === event.key &&
                this.setState({
                  dismissed: !0,
                  dismissedAtCoordinate: {
                    x:
                      null !==
                        (_this$props$coordinat =
                          null === (_this$props$coordinat2 = this.props.coordinate) ||
                          void 0 === _this$props$coordinat2
                            ? void 0
                            : _this$props$coordinat2.x) && void 0 !== _this$props$coordinat
                        ? _this$props$coordinat
                        : 0,
                    y:
                      null !==
                        (_this$props$coordinat3 =
                          null === (_this$props$coordinat4 = this.props.coordinate) ||
                          void 0 === _this$props$coordinat4
                            ? void 0
                            : _this$props$coordinat4.y) && void 0 !== _this$props$coordinat3
                        ? _this$props$coordinat3
                        : 0,
                  },
                });
            }));
        }
        componentDidMount() {
          document.addEventListener('keydown', this.handleKeyDown);
        }
        componentWillUnmount() {
          document.removeEventListener('keydown', this.handleKeyDown);
        }
        componentDidUpdate() {
          var _this$props$coordinat5, _this$props$coordinat6;
          this.state.dismissed &&
            (((null === (_this$props$coordinat5 = this.props.coordinate) ||
            void 0 === _this$props$coordinat5
              ? void 0
              : _this$props$coordinat5.x) === this.state.dismissedAtCoordinate.x &&
              (null === (_this$props$coordinat6 = this.props.coordinate) ||
              void 0 === _this$props$coordinat6
                ? void 0
                : _this$props$coordinat6.y) === this.state.dismissedAtCoordinate.y) ||
              (this.state.dismissed = !1));
        }
        render() {
          var {
              active,
              allowEscapeViewBox,
              animationDuration,
              animationEasing,
              children,
              coordinate,
              hasPayload,
              isAnimationActive,
              offset,
              position,
              reverseDirection,
              useTranslate3d,
              viewBox,
              wrapperStyle,
              lastBoundingBox,
              innerRef,
              hasPortalFromProps,
            } = this.props,
            { cssClasses, cssProperties } = (function getTooltipTranslate(_ref4) {
              var cssProperties,
                translateX,
                translateY,
                {
                  allowEscapeViewBox,
                  coordinate,
                  offsetTopLeft,
                  position,
                  reverseDirection,
                  tooltipBox,
                  useTranslate3d,
                  viewBox,
                } = _ref4;
              return (
                (cssProperties =
                  tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate
                    ? (function getTransformStyle(_ref3) {
                        var { translateX, translateY, useTranslate3d } = _ref3;
                        return {
                          transform: useTranslate3d
                            ? 'translate3d('.concat(translateX, 'px, ').concat(translateY, 'px, 0)')
                            : 'translate('.concat(translateX, 'px, ').concat(translateY, 'px)'),
                        };
                      })({
                        translateX: (translateX = getTooltipTranslateXY({
                          allowEscapeViewBox,
                          coordinate,
                          key: 'x',
                          offsetTopLeft,
                          position,
                          reverseDirection,
                          tooltipDimension: tooltipBox.width,
                          viewBox,
                          viewBoxDimension: viewBox.width,
                        })),
                        translateY: (translateY = getTooltipTranslateXY({
                          allowEscapeViewBox,
                          coordinate,
                          key: 'y',
                          offsetTopLeft,
                          position,
                          reverseDirection,
                          tooltipDimension: tooltipBox.height,
                          viewBox,
                          viewBoxDimension: viewBox.height,
                        })),
                        useTranslate3d,
                      })
                    : TOOLTIP_HIDDEN),
                {
                  cssProperties,
                  cssClasses: getTooltipCSSClassName({ translateX, translateY, coordinate }),
                }
              );
            })({
              allowEscapeViewBox,
              coordinate,
              offsetTopLeft: offset,
              position,
              reverseDirection,
              tooltipBox: { height: lastBoundingBox.height, width: lastBoundingBox.width },
              useTranslate3d,
              viewBox,
            }),
            positionStyles = hasPortalFromProps
              ? {}
              : TooltipBoundingBox_objectSpread(
                  TooltipBoundingBox_objectSpread(
                    {
                      transition:
                        isAnimationActive && active
                          ? 'transform '.concat(animationDuration, 'ms ').concat(animationEasing)
                          : void 0,
                    },
                    cssProperties
                  ),
                  {},
                  {
                    pointerEvents: 'none',
                    visibility:
                      !this.state.dismissed && active && hasPayload ? 'visible' : 'hidden',
                    position: 'absolute',
                    top: 0,
                    left: 0,
                  }
                ),
            outerStyle = TooltipBoundingBox_objectSpread(
              TooltipBoundingBox_objectSpread({}, positionStyles),
              {},
              { visibility: !this.state.dismissed && active && hasPayload ? 'visible' : 'hidden' },
              wrapperStyle
            );
          return react.createElement(
            'div',
            {
              xmlns: 'http://www.w3.org/1999/xhtml',
              tabIndex: -1,
              className: cssClasses,
              style: outerStyle,
              ref: innerRef,
            },
            children
          );
        }
      }
      var uniqBy = __webpack_require__('./node_modules/es-toolkit/compat/uniqBy.js'),
        uniqBy_default = __webpack_require__.n(uniqBy);
      var chartLayoutContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        accessibilityContext = __webpack_require__(
          './node_modules/recharts/es6/context/accessibilityContext.js'
        );
      var types = __webpack_require__('./node_modules/recharts/es6/util/types.js'),
        Curve = __webpack_require__('./node_modules/recharts/es6/shape/Curve.js'),
        svgPropertiesAndEvents = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesAndEvents.js'
        ),
        _excluded = ['x', 'y', 'top', 'left', 'width', 'height', 'className'];
      function Cross_extends() {
        return (
          (Cross_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          Cross_extends.apply(null, arguments)
        );
      }
      function Cross_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function Cross_defineProperty(e, r, t) {
        return (
          (r = (function Cross_toPropertyKey(t) {
            var i = (function Cross_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var getPath = (x, y, width, height, top, left) =>
          'M'
            .concat(x, ',')
            .concat(top, 'v')
            .concat(height, 'M')
            .concat(left, ',')
            .concat(y, 'h')
            .concat(width),
        Cross = (_ref) => {
          var { x = 0, y = 0, top = 0, left = 0, width = 0, height = 0, className } = _ref,
            props = (function Cross_objectSpread(e) {
              for (var r = 1; r < arguments.length; r++) {
                var t = null != arguments[r] ? arguments[r] : {};
                r % 2
                  ? Cross_ownKeys(Object(t), !0).forEach(function (r) {
                      Cross_defineProperty(e, r, t[r]);
                    })
                  : Object.getOwnPropertyDescriptors
                    ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
                    : Cross_ownKeys(Object(t)).forEach(function (r) {
                        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                      });
              }
              return e;
            })(
              { x, y, top, left, width, height },
              (function _objectWithoutProperties(e, t) {
                if (null == e) return {};
                var o,
                  r,
                  i = (function _objectWithoutPropertiesLoose(r, e) {
                    if (null == r) return {};
                    var t = {};
                    for (var n in r)
                      if ({}.hasOwnProperty.call(r, n)) {
                        if (-1 !== e.indexOf(n)) continue;
                        t[n] = r[n];
                      }
                    return t;
                  })(e, t);
                if (Object.getOwnPropertySymbols) {
                  var n = Object.getOwnPropertySymbols(e);
                  for (r = 0; r < n.length; r++)
                    ((o = n[r]),
                      -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
                }
                return i;
              })(_ref, _excluded)
            );
          return (0, DataUtils.Et)(x) &&
            (0, DataUtils.Et)(y) &&
            (0, DataUtils.Et)(width) &&
            (0, DataUtils.Et)(height) &&
            (0, DataUtils.Et)(top) &&
            (0, DataUtils.Et)(left)
            ? react.createElement(
                'path',
                Cross_extends({}, (0, svgPropertiesAndEvents.a)(props), {
                  className: (0, clsx.$)('recharts-cross', className),
                  d: getPath(x, y, width, height, top, left),
                })
              )
            : null;
        };
      var Rectangle = __webpack_require__('./node_modules/recharts/es6/shape/Rectangle.js'),
        PolarUtils = __webpack_require__('./node_modules/recharts/es6/util/PolarUtils.js');
      function getRadialCursorPoints(activeCoordinate) {
        var { cx, cy, radius, startAngle, endAngle } = activeCoordinate;
        return {
          points: [
            (0, PolarUtils.IZ)(cx, cy, radius, startAngle),
            (0, PolarUtils.IZ)(cx, cy, radius, endAngle),
          ],
          cx,
          cy,
          radius,
          startAngle,
          endAngle,
        };
      }
      var Sector = __webpack_require__('./node_modules/recharts/es6/shape/Sector.js');
      function getCursorPoints(layout, activeCoordinate, offset) {
        if ('horizontal' === layout)
          return [
            { x: activeCoordinate.x, y: offset.top },
            { x: activeCoordinate.x, y: offset.top + offset.height },
          ];
        if ('vertical' === layout)
          return [
            { x: offset.left, y: activeCoordinate.y },
            { x: offset.left + offset.width, y: activeCoordinate.y },
          ];
        if ((0, types.TT)(activeCoordinate)) {
          if ('centric' === layout) {
            var { cx, cy, innerRadius, outerRadius, angle } = activeCoordinate,
              innerPoint = (0, PolarUtils.IZ)(cx, cy, innerRadius, angle),
              outerPoint = (0, PolarUtils.IZ)(cx, cy, outerRadius, angle);
            return [
              { x: innerPoint.x, y: innerPoint.y },
              { x: outerPoint.x, y: outerPoint.y },
            ];
          }
          return getRadialCursorPoints(activeCoordinate);
        }
      }
      var hooks = __webpack_require__('./node_modules/recharts/es6/state/hooks.js'),
        ChartUtils = __webpack_require__('./node_modules/recharts/es6/util/ChartUtils.js'),
        axisSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/axisSelectors.js'
        ),
        tooltipSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/tooltipSelectors.js'
        );
      function useTooltipAxis_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function useTooltipAxis_objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? useTooltipAxis_ownKeys(Object(t), !0).forEach(function (r) {
                useTooltipAxis_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : useTooltipAxis_ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function useTooltipAxis_defineProperty(e, r, t) {
        return (
          (r = (function useTooltipAxis_toPropertyKey(t) {
            var i = (function useTooltipAxis_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var useTooltipAxisBandSize = () => {
          var tooltipAxis = (0, hooks.G)(axisSelectors.Dn),
            tooltipTicks = (0, hooks.G)(tooltipSelectors.R4),
            tooltipAxisScale = (0, hooks.G)(tooltipSelectors.fl);
          return tooltipAxis && tooltipAxisScale
            ? (0, ChartUtils.Hj)(
                useTooltipAxis_objectSpread(
                  useTooltipAxis_objectSpread({}, tooltipAxis),
                  {},
                  { scale: tooltipAxisScale }
                ),
                tooltipTicks
              )
            : (0, ChartUtils.Hj)(void 0, tooltipTicks);
        },
        selectors = __webpack_require__('./node_modules/recharts/es6/state/selectors/selectors.js'),
        svgPropertiesNoEvents = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesNoEvents.js'
        ),
        ZIndexLayer = __webpack_require__('./node_modules/recharts/es6/zIndex/ZIndexLayer.js'),
        DefaultZIndexes = __webpack_require__(
          './node_modules/recharts/es6/zIndex/DefaultZIndexes.js'
        );
      function Cursor_extends() {
        return (
          (Cursor_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          Cursor_extends.apply(null, arguments)
        );
      }
      function Cursor_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function Cursor_objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? Cursor_ownKeys(Object(t), !0).forEach(function (r) {
                Cursor_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : Cursor_ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function Cursor_defineProperty(e, r, t) {
        return (
          (r = (function Cursor_toPropertyKey(t) {
            var i = (function Cursor_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function RenderCursor(_ref) {
        var { cursor, cursorComp, cursorProps } = _ref;
        return (0, react.isValidElement)(cursor)
          ? (0, react.cloneElement)(cursor, cursorProps)
          : (0, react.createElement)(cursorComp, cursorProps);
      }
      function CursorInternal(props) {
        var _props$zIndex,
          restProps,
          cursorComp,
          preferredZIndex,
          {
            coordinate,
            payload,
            index,
            offset,
            tooltipAxisBandSize,
            layout,
            cursor,
            tooltipEventType,
            chartName,
          } = props,
          activeCoordinate = coordinate,
          activePayload = payload,
          activeTooltipIndex = index;
        if (
          !cursor ||
          !activeCoordinate ||
          ('ScatterChart' !== chartName && 'axis' !== tooltipEventType)
        )
          return null;
        if ('ScatterChart' === chartName)
          ((restProps = activeCoordinate),
            (cursorComp = Cross),
            (preferredZIndex = DefaultZIndexes.I.cursorLine));
        else if ('BarChart' === chartName)
          ((restProps = (function getCursorRectangle(
            layout,
            activeCoordinate,
            offset,
            tooltipAxisBandSize
          ) {
            var halfSize = tooltipAxisBandSize / 2;
            return {
              stroke: 'none',
              fill: '#ccc',
              x: 'horizontal' === layout ? activeCoordinate.x - halfSize : offset.left + 0.5,
              y: 'horizontal' === layout ? offset.top + 0.5 : activeCoordinate.y - halfSize,
              width: 'horizontal' === layout ? tooltipAxisBandSize : offset.width - 1,
              height: 'horizontal' === layout ? offset.height - 1 : tooltipAxisBandSize,
            };
          })(layout, activeCoordinate, offset, tooltipAxisBandSize)),
            (cursorComp = Rectangle.M),
            (preferredZIndex = DefaultZIndexes.I.cursorRectangle));
        else if ('radial' === layout && (0, types.TT)(activeCoordinate)) {
          var { cx, cy, radius, startAngle, endAngle } = getRadialCursorPoints(activeCoordinate);
          ((restProps = { cx, cy, startAngle, endAngle, innerRadius: radius, outerRadius: radius }),
            (cursorComp = Sector.h),
            (preferredZIndex = DefaultZIndexes.I.cursorLine));
        } else
          ((restProps = { points: getCursorPoints(layout, activeCoordinate, offset) }),
            (cursorComp = Curve.I),
            (preferredZIndex = DefaultZIndexes.I.cursorLine));
        var extraClassName =
            'object' == typeof cursor && 'className' in cursor ? cursor.className : void 0,
          cursorProps = Cursor_objectSpread(
            Cursor_objectSpread(
              Cursor_objectSpread(
                Cursor_objectSpread({ stroke: '#ccc', pointerEvents: 'none' }, offset),
                restProps
              ),
              (0, svgPropertiesNoEvents.ic)(cursor)
            ),
            {},
            {
              payload: activePayload,
              payloadIndex: activeTooltipIndex,
              className: (0, clsx.$)('recharts-tooltip-cursor', extraClassName),
            }
          );
        return react.createElement(
          ZIndexLayer.g,
          {
            zIndex:
              null !== (_props$zIndex = props.zIndex) && void 0 !== _props$zIndex
                ? _props$zIndex
                : preferredZIndex,
          },
          react.createElement(RenderCursor, { cursor, cursorComp, cursorProps })
        );
      }
      function Cursor(props) {
        var tooltipAxisBandSize = useTooltipAxisBandSize(),
          offset = (0, chartLayoutContext.W7)(),
          layout = (0, chartLayoutContext.WX)(),
          chartName = (0, selectors.fW)();
        return null == tooltipAxisBandSize || null == offset || null == layout || null == chartName
          ? null
          : react.createElement(
              CursorInternal,
              Cursor_extends({}, props, { offset, layout, tooltipAxisBandSize, chartName })
            );
      }
      var tooltipPortalContext = __webpack_require__(
          './node_modules/recharts/es6/context/tooltipPortalContext.js'
        ),
        tooltipSlice = __webpack_require__('./node_modules/recharts/es6/state/tooltipSlice.js'),
        useChartSynchronisation = __webpack_require__(
          './node_modules/recharts/es6/synchronisation/useChartSynchronisation.js'
        ),
        selectTooltipEventType = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipEventType.js'
        ),
        resolveDefaultProps = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        );
      function Tooltip_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function Tooltip_objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? Tooltip_ownKeys(Object(t), !0).forEach(function (r) {
                Tooltip_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : Tooltip_ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function Tooltip_defineProperty(e, r, t) {
        return (
          (r = (function Tooltip_toPropertyKey(t) {
            var i = (function Tooltip_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function defaultUniqBy(entry) {
        return entry.dataKey;
      }
      var emptyPayload = [],
        defaultTooltipProps = {
          allowEscapeViewBox: { x: !1, y: !1 },
          animationDuration: 400,
          animationEasing: 'ease',
          axisId: 0,
          contentStyle: {},
          cursor: !0,
          filterNull: !0,
          includeHidden: !1,
          isAnimationActive: 'auto',
          itemSorter: 'name',
          itemStyle: {},
          labelStyle: {},
          offset: 10,
          reverseDirection: { x: !1, y: !1 },
          separator: ' : ',
          trigger: 'hover',
          useTranslate3d: !1,
          wrapperStyle: {},
        };
      function Tooltip(outsideProps) {
        var _useAppSelector,
          _ref,
          props = (0, resolveDefaultProps.e)(outsideProps, defaultTooltipProps),
          {
            active: activeFromProps,
            allowEscapeViewBox,
            animationDuration,
            animationEasing,
            content,
            filterNull,
            isAnimationActive,
            offset,
            payloadUniqBy,
            position,
            reverseDirection,
            useTranslate3d,
            wrapperStyle,
            cursor,
            shared,
            trigger,
            defaultIndex,
            portal: portalFromProps,
            axisId,
          } = props,
          dispatch = (0, hooks.j)(),
          defaultIndexAsString =
            'number' == typeof defaultIndex ? String(defaultIndex) : defaultIndex;
        (0, react.useEffect)(() => {
          dispatch(
            (0, tooltipSlice.UF)({
              shared,
              trigger,
              axisId,
              active: activeFromProps,
              defaultIndex: defaultIndexAsString,
            })
          );
        }, [dispatch, shared, trigger, axisId, activeFromProps, defaultIndexAsString]);
        var viewBox = (0, chartLayoutContext.sk)(),
          accessibilityLayer = (0, accessibilityContext.$)(),
          tooltipEventType = (0, selectTooltipEventType.Td)(shared),
          { activeIndex, isActive } =
            null !==
              (_useAppSelector = (0, hooks.G)((state) =>
                (0, selectors.yn)(state, tooltipEventType, trigger, defaultIndexAsString)
              )) && void 0 !== _useAppSelector
              ? _useAppSelector
              : {},
          payloadFromRedux = (0, hooks.G)((state) =>
            (0, selectors.u9)(state, tooltipEventType, trigger, defaultIndexAsString)
          ),
          labelFromRedux = (0, hooks.G)((state) =>
            (0, selectors.BZ)(state, tooltipEventType, trigger, defaultIndexAsString)
          ),
          coordinate = (0, hooks.G)((state) =>
            (0, selectors.dS)(state, tooltipEventType, trigger, defaultIndexAsString)
          ),
          payload = payloadFromRedux,
          tooltipPortalFromContext = (0, tooltipPortalContext.X)(),
          finalIsActive =
            null !== (_ref = null != activeFromProps ? activeFromProps : isActive) &&
            void 0 !== _ref &&
            _ref,
          [lastBoundingBox, updateBoundingBox] = (function useElementOffset() {
            var extraDependencies =
                arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
              [lastBoundingBox, setLastBoundingBox] = (0, react.useState)({
                height: 0,
                left: 0,
                top: 0,
                width: 0,
              }),
              updateBoundingBox = (0, react.useCallback)(
                (node) => {
                  if (null != node) {
                    var rect = node.getBoundingClientRect(),
                      box = {
                        height: rect.height,
                        left: rect.left,
                        top: rect.top,
                        width: rect.width,
                      };
                    (Math.abs(box.height - lastBoundingBox.height) > 1 ||
                      Math.abs(box.left - lastBoundingBox.left) > 1 ||
                      Math.abs(box.top - lastBoundingBox.top) > 1 ||
                      Math.abs(box.width - lastBoundingBox.width) > 1) &&
                      setLastBoundingBox({
                        height: box.height,
                        left: box.left,
                        top: box.top,
                        width: box.width,
                      });
                  }
                },
                [
                  lastBoundingBox.width,
                  lastBoundingBox.height,
                  lastBoundingBox.top,
                  lastBoundingBox.left,
                  ...extraDependencies,
                ]
              );
            return [lastBoundingBox, updateBoundingBox];
          })([payload, finalIsActive]),
          finalLabel = 'axis' === tooltipEventType ? labelFromRedux : void 0;
        (0, useChartSynchronisation.m7)(
          tooltipEventType,
          trigger,
          coordinate,
          finalLabel,
          activeIndex,
          finalIsActive
        );
        var tooltipPortal = null != portalFromProps ? portalFromProps : tooltipPortalFromContext;
        if (null == tooltipPortal || null == viewBox || null == tooltipEventType) return null;
        var finalPayload = null != payload ? payload : emptyPayload;
        (finalIsActive || (finalPayload = emptyPayload),
          filterNull &&
            finalPayload.length &&
            (finalPayload = (function getUniqPayload(payload, option, defaultUniqBy) {
              return !0 === option
                ? uniqBy_default()(payload, defaultUniqBy)
                : 'function' == typeof option
                  ? uniqBy_default()(payload, option)
                  : payload;
            })(
              finalPayload.filter(
                (entry) => null != entry.value && (!0 !== entry.hide || props.includeHidden)
              ),
              payloadUniqBy,
              defaultUniqBy
            )));
        var hasPayload = finalPayload.length > 0,
          tooltipElement = react.createElement(
            TooltipBoundingBox,
            {
              allowEscapeViewBox,
              animationDuration,
              animationEasing,
              isAnimationActive,
              active: finalIsActive,
              coordinate,
              hasPayload,
              offset,
              position,
              reverseDirection,
              useTranslate3d,
              viewBox,
              wrapperStyle,
              lastBoundingBox,
              innerRef: updateBoundingBox,
              hasPortalFromProps: Boolean(portalFromProps),
            },
            (function renderContent(content, props) {
              return react.isValidElement(content)
                ? react.cloneElement(content, props)
                : 'function' == typeof content
                  ? react.createElement(content, props)
                  : react.createElement(DefaultTooltipContent, props);
            })(
              content,
              Tooltip_objectSpread(
                Tooltip_objectSpread({}, props),
                {},
                {
                  payload: finalPayload,
                  label: finalLabel,
                  active: finalIsActive,
                  activeIndex,
                  coordinate,
                  accessibilityLayer,
                }
              )
            )
          );
        return react.createElement(
          react.Fragment,
          null,
          (0, react_dom.createPortal)(tooltipElement, tooltipPortal),
          finalIsActive &&
            react.createElement(Cursor, {
              cursor,
              tooltipEventType,
              coordinate,
              payload: finalPayload,
              index: activeIndex,
            })
        );
      }
    },
    './node_modules/recharts/es6/container/Layer.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { W: () => Layer });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/clsx/dist/clsx.mjs'
        ),
        _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesAndEvents.js'
        ),
        _excluded = ['children', 'className'];
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      var Layer = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {
        var { children, className } = props,
          others = (function _objectWithoutProperties(e, t) {
            if (null == e) return {};
            var o,
              r,
              i = (function _objectWithoutPropertiesLoose(r, e) {
                if (null == r) return {};
                var t = {};
                for (var n in r)
                  if ({}.hasOwnProperty.call(r, n)) {
                    if (-1 !== e.indexOf(n)) continue;
                    t[n] = r[n];
                  }
                return t;
              })(e, t);
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              for (r = 0; r < n.length; r++)
                ((o = n[r]),
                  -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
            }
            return i;
          })(props, _excluded),
          layerClass = (0, clsx__WEBPACK_IMPORTED_MODULE_1__.$)('recharts-layer', className);
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
          'g',
          _extends(
            { className: layerClass },
            (0, _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_2__.a)(others),
            { ref }
          ),
          children
        );
      });
    },
    './node_modules/recharts/es6/context/PanoramaContext.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { r: () => useIsPanorama });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        PanoramaContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null),
        useIsPanorama = () =>
          null != (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PanoramaContext);
    },
    './node_modules/recharts/es6/context/RegisterGraphicalItemId.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { x: () => RegisterGraphicalItemId });
      var _ref,
        react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        react_namespaceObject = __webpack_require__.t(react, 2),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        useId =
          null !== (_ref = react_namespaceObject['useId'.toString()]) && void 0 !== _ref
            ? _ref
            : () => {
                var [id] = react.useState(() => (0, DataUtils.NF)('uid-'));
                return id;
              };
      var GraphicalItemIdContext = (0, react.createContext)(void 0),
        RegisterGraphicalItemId = (_ref) => {
          var { id, type, children } = _ref,
            resolvedId = (function useUniqueId(prefix, customId) {
              var generatedId = useId();
              return (
                customId || (prefix ? ''.concat(prefix, '-').concat(generatedId) : generatedId)
              );
            })('recharts-'.concat(type), id);
          return react.createElement(
            GraphicalItemIdContext.Provider,
            { value: resolvedId },
            children(resolvedId)
          );
        };
    },
    './node_modules/recharts/es6/context/accessibilityContext.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { $: () => useAccessibilityLayer });
      var _state_hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        useAccessibilityLayer = () => {
          var _useAppSelector;
          return (
            null ===
              (_useAppSelector = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_0__.G)(
                (state) => state.rootProps.accessibilityLayer
              )) ||
            void 0 === _useAppSelector ||
            _useAppSelector
          );
        };
    },
    './node_modules/recharts/es6/context/chartDataContext.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { TK: () => ChartDataContextProvider });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        _state_chartDataSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/chartDataSlice.js'
        ),
        _state_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _PanoramaContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        ),
        ChartDataContextProvider = (props) => {
          var { chartData } = props,
            dispatch = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_2__.j)(),
            isPanorama = (0, _PanoramaContext__WEBPACK_IMPORTED_MODULE_3__.r)();
          return (
            (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(
              () =>
                isPanorama
                  ? () => {}
                  : (dispatch(
                      (0, _state_chartDataSlice__WEBPACK_IMPORTED_MODULE_1__.hq)(chartData)
                    ),
                    () => {
                      dispatch((0, _state_chartDataSlice__WEBPACK_IMPORTED_MODULE_1__.hq)(void 0));
                    }),
              [chartData, dispatch, isPanorama]
            ),
            null
          );
        };
    },
    './node_modules/recharts/es6/context/chartLayoutContext.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        A3: () => ReportChartSize,
        SG: () => useIsInChartContext,
        W7: () => useOffsetInternal,
        WX: () => useChartLayout,
        fz: () => selectChartLayout,
        qC: () => cartesianViewBoxToTrapezoid,
        rY: () => useChartHeight,
        sk: () => useViewBox,
        yi: () => useChartWidth,
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        _state_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _state_layoutSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/state/layoutSlice.js'
        ),
        _state_selectors_selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
          ),
        _state_selectors_containerSelectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/containerSelectors.js'
        ),
        _PanoramaContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        ),
        _state_selectors_brushSelectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/brushSelectors.js'
        ),
        _component_ResponsiveContainer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          './node_modules/recharts/es6/component/ResponsiveContainer.js'
        ),
        _util_isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          './node_modules/recharts/es6/util/isWellBehavedNumber.js'
        );
      function cartesianViewBoxToTrapezoid(box) {
        if (box)
          return {
            x: box.x,
            y: box.y,
            upperWidth: 'upperWidth' in box ? box.upperWidth : box.width,
            lowerWidth: 'lowerWidth' in box ? box.lowerWidth : box.width,
            width: box.width,
            height: box.height,
          };
      }
      var useViewBox = () => {
          var _useAppSelector,
            panorama = (0, _PanoramaContext__WEBPACK_IMPORTED_MODULE_5__.r)(),
            rootViewBox = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_1__.G)(
              _state_selectors_selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_3__.Ds
            ),
            brushDimensions = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_1__.G)(
              _state_selectors_brushSelectors__WEBPACK_IMPORTED_MODULE_6__.U
            ),
            brushPadding =
              null ===
                (_useAppSelector = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_1__.G)(
                  _state_selectors_brushSelectors__WEBPACK_IMPORTED_MODULE_6__.C
                )) || void 0 === _useAppSelector
                ? void 0
                : _useAppSelector.padding;
          return panorama && brushDimensions && brushPadding
            ? {
                width: brushDimensions.width - brushPadding.left - brushPadding.right,
                height: brushDimensions.height - brushPadding.top - brushPadding.bottom,
                x: brushPadding.left,
                y: brushPadding.top,
              }
            : rootViewBox;
        },
        manyComponentsThrowErrorsIfOffsetIsUndefined = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          width: 0,
          height: 0,
          brushBottom: 0,
        },
        useOffsetInternal = () => {
          var _useAppSelector2;
          return null !==
            (_useAppSelector2 = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_1__.G)(
              _state_selectors_selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_3__.HZ
            )) && void 0 !== _useAppSelector2
            ? _useAppSelector2
            : manyComponentsThrowErrorsIfOffsetIsUndefined;
        },
        useChartWidth = () =>
          (0, _state_hooks__WEBPACK_IMPORTED_MODULE_1__.G)(
            _state_selectors_containerSelectors__WEBPACK_IMPORTED_MODULE_4__.Lp
          ),
        useChartHeight = () =>
          (0, _state_hooks__WEBPACK_IMPORTED_MODULE_1__.G)(
            _state_selectors_containerSelectors__WEBPACK_IMPORTED_MODULE_4__.A$
          ),
        selectChartLayout = (state) => state.layout.layoutType,
        useChartLayout = () => (0, _state_hooks__WEBPACK_IMPORTED_MODULE_1__.G)(selectChartLayout),
        useIsInChartContext = () => void 0 !== useChartLayout(),
        ReportChartSize = (props) => {
          var dispatch = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_1__.j)(),
            isPanorama = (0, _PanoramaContext__WEBPACK_IMPORTED_MODULE_5__.r)(),
            { width: widthFromProps, height: heightFromProps } = props,
            responsiveContainerCalculations = (0,
            _component_ResponsiveContainer__WEBPACK_IMPORTED_MODULE_7__.w)(),
            width = widthFromProps,
            height = heightFromProps;
          return (
            responsiveContainerCalculations &&
              ((width =
                responsiveContainerCalculations.width > 0
                  ? responsiveContainerCalculations.width
                  : widthFromProps),
              (height =
                responsiveContainerCalculations.height > 0
                  ? responsiveContainerCalculations.height
                  : heightFromProps)),
            (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
              !isPanorama &&
                (0, _util_isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_8__.F)(width) &&
                (0, _util_isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_8__.F)(height) &&
                dispatch(
                  (0, _state_layoutSlice__WEBPACK_IMPORTED_MODULE_2__.gX)({ width, height })
                );
            }, [dispatch, isPanorama, width, height]),
            null
          );
        };
    },
    './node_modules/recharts/es6/context/tooltipContext.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        Cj: () => useMouseEnterItemDispatch,
        Pg: () => useMouseLeaveItemDispatch,
        Ub: () => useMouseClickItemDispatch,
      });
      var _state_hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _state_tooltipSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/tooltipSlice.js'
        ),
        useMouseEnterItemDispatch = (onMouseEnterFromProps, dataKey, graphicalItemId) => {
          var dispatch = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_0__.j)();
          return (data, index) => (event) => {
            (null == onMouseEnterFromProps || onMouseEnterFromProps(data, index, event),
              dispatch(
                (0, _state_tooltipSlice__WEBPACK_IMPORTED_MODULE_1__.RD)({
                  activeIndex: String(index),
                  activeDataKey: dataKey,
                  activeCoordinate: data.tooltipPosition,
                  activeGraphicalItemId: graphicalItemId,
                })
              ));
          };
        },
        useMouseLeaveItemDispatch = (onMouseLeaveFromProps) => {
          var dispatch = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_0__.j)();
          return (data, index) => (event) => {
            (null == onMouseLeaveFromProps || onMouseLeaveFromProps(data, index, event),
              dispatch((0, _state_tooltipSlice__WEBPACK_IMPORTED_MODULE_1__.oP)()));
          };
        },
        useMouseClickItemDispatch = (onMouseClickFromProps, dataKey, graphicalItemId) => {
          var dispatch = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_0__.j)();
          return (data, index) => (event) => {
            (null == onMouseClickFromProps || onMouseClickFromProps(data, index, event),
              dispatch(
                (0, _state_tooltipSlice__WEBPACK_IMPORTED_MODULE_1__.ML)({
                  activeIndex: String(index),
                  activeDataKey: dataKey,
                  activeCoordinate: data.tooltipPosition,
                  activeGraphicalItemId: graphicalItemId,
                })
              ));
          };
        };
    },
    './node_modules/recharts/es6/context/tooltipPortalContext.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        $: () => TooltipPortalContext,
        X: () => useTooltipPortal,
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        TooltipPortalContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null),
        useTooltipPortal = () =>
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TooltipPortalContext);
    },
    './node_modules/recharts/es6/hooks.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { oM: () => usePlotArea });
      var hooks = __webpack_require__('./node_modules/recharts/es6/state/hooks.js'),
        reselect = __webpack_require__('./node_modules/reselect/dist/reselect.mjs'),
        selectChartOffsetInternal = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
        ),
        selectChartOffset_selectChartOffset = (0, reselect.Mz)(
          [selectChartOffsetInternal.HZ],
          (offsetInternal) => ({
            top: offsetInternal.top,
            bottom: offsetInternal.bottom,
            left: offsetInternal.left,
            right: offsetInternal.right,
          })
        ),
        containerSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/containerSelectors.js'
        ),
        selectPlotArea = (0, reselect.Mz)(
          [selectChartOffset_selectChartOffset, containerSelectors.Lp, containerSelectors.A$],
          (offset, chartWidth, chartHeight) => {
            if (offset && null != chartWidth && null != chartHeight)
              return {
                x: offset.left,
                y: offset.top,
                width: Math.max(0, chartWidth - offset.left - offset.right),
                height: Math.max(0, chartHeight - offset.top - offset.bottom),
              };
          }
        ),
        usePlotArea = () => (0, hooks.G)(selectPlotArea);
    },
    './node_modules/recharts/es6/polar/Pie.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { Fq: () => Pie, L_: () => computePieSectors });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        get = __webpack_require__('./node_modules/es-toolkit/compat/get.js'),
        get_default = __webpack_require__.n(get),
        clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
        reselect = __webpack_require__('./node_modules/reselect/dist/reselect.mjs'),
        dataSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/dataSelectors.js'
        ),
        selectChartOffsetInternal = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
        ),
        ChartUtils = __webpack_require__('./node_modules/recharts/es6/util/ChartUtils.js'),
        axisSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/axisSelectors.js'
        ),
        chartLayoutContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        pickAxisType = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/pickAxisType.js'
        ),
        pickAxisId = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/pickAxisId.js'
        ),
        rootPropsSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/rootPropsSelectors.js'
        ),
        selectUnfilteredPolarItems = (state) => state.graphicalItems.polarItems,
        selectAxisPredicate = (0, reselect.Mz)([pickAxisType.N, pickAxisId.E], axisSelectors.eo),
        selectPolarItemsSettings = (0, reselect.Mz)(
          [selectUnfilteredPolarItems, axisSelectors.DP, selectAxisPredicate],
          axisSelectors.ec
        ),
        selectPolarGraphicalItemsData = (0, reselect.Mz)(
          [selectPolarItemsSettings],
          axisSelectors.rj
        ),
        selectPolarDisplayedData = (0, reselect.Mz)(
          [selectPolarGraphicalItemsData, dataSelectors.z3],
          axisSelectors.Nk
        ),
        selectPolarAppliedValues = (0, reselect.Mz)(
          [selectPolarDisplayedData, axisSelectors.DP, selectPolarItemsSettings],
          axisSelectors.fb
        ),
        unsupportedInPolarChart =
          ((0, reselect.Mz)(
            [selectPolarDisplayedData, axisSelectors.DP, selectPolarItemsSettings],
            (data, axisSettings, items) =>
              items.length > 0
                ? data
                    .flatMap((entry) =>
                      items.flatMap((item) => {
                        var _axisSettings$dataKey;
                        return {
                          value: (0, ChartUtils.kr)(
                            entry,
                            null !== (_axisSettings$dataKey = axisSettings.dataKey) &&
                              void 0 !== _axisSettings$dataKey
                              ? _axisSettings$dataKey
                              : item.dataKey
                          ),
                          errorDomain: [],
                        };
                      })
                    )
                    .filter(Boolean)
                : null != (null == axisSettings ? void 0 : axisSettings.dataKey)
                  ? data.map((item) => ({
                      value: (0, ChartUtils.kr)(item, axisSettings.dataKey),
                      errorDomain: [],
                    }))
                  : data.map((entry) => ({ value: entry, errorDomain: [] }))
          ),
          () => {}),
        selectDomainOfAllPolarAppliedNumericalValues = (0, reselect.Mz)(
          [
            selectPolarDisplayedData,
            axisSelectors.DP,
            selectPolarItemsSettings,
            axisSelectors.CH,
            pickAxisType.N,
          ],
          axisSelectors.EZ
        ),
        selectPolarNumericalDomain = (0, reselect.Mz)(
          [
            axisSelectors.DP,
            axisSelectors.AV,
            axisSelectors.Lu,
            unsupportedInPolarChart,
            selectDomainOfAllPolarAppliedNumericalValues,
            unsupportedInPolarChart,
            chartLayoutContext.fz,
            pickAxisType.N,
          ],
          axisSelectors.wL
        ),
        selectPolarAxisDomain = (0, reselect.Mz)(
          [
            axisSelectors.DP,
            chartLayoutContext.fz,
            selectPolarDisplayedData,
            selectPolarAppliedValues,
            rootPropsSelectors.eC,
            pickAxisType.N,
            selectPolarNumericalDomain,
          ],
          axisSelectors.tP
        ),
        selectPolarNiceTicks = (0, reselect.Mz)(
          [selectPolarAxisDomain, axisSelectors.DP, axisSelectors.xM],
          axisSelectors.xp
        );
      (0, reselect.Mz)(
        [axisSelectors.DP, selectPolarAxisDomain, selectPolarNiceTicks, pickAxisType.N],
        axisSelectors.g1
      );
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var selectSynchronisedPieSettings = (0, reselect.Mz)(
          [selectUnfilteredPolarItems, (_state, id) => id],
          (graphicalItems, id) =>
            graphicalItems.filter((item) => 'pie' === item.type).find((item) => item.id === id)
        ),
        emptyArray = [],
        pickCells = (_state, _id, cells) =>
          0 === (null == cells ? void 0 : cells.length) ? emptyArray : cells,
        selectDisplayedData = (0, reselect.Mz)(
          [dataSelectors.z3, selectSynchronisedPieSettings, pickCells],
          (_ref, pieSettings, cells) => {
            var displayedData,
              { chartData } = _ref;
            if (
              null != pieSettings &&
              (((displayedData =
                null != (null == pieSettings ? void 0 : pieSettings.data) &&
                pieSettings.data.length > 0
                  ? pieSettings.data
                  : chartData) &&
                displayedData.length) ||
                null == cells ||
                (displayedData = cells.map((cell) =>
                  _objectSpread(_objectSpread({}, pieSettings.presentationProps), cell.props)
                )),
              null != displayedData)
            )
              return displayedData;
          }
        ),
        selectPieLegend = (0, reselect.Mz)(
          [selectDisplayedData, selectSynchronisedPieSettings, pickCells],
          (displayedData, pieSettings, cells) => {
            if (null != displayedData && null != pieSettings)
              return displayedData.map((entry, i) => {
                var _cells$i,
                  color,
                  name = (0, ChartUtils.kr)(entry, pieSettings.nameKey, pieSettings.name);
                return (
                  (color =
                    null != cells &&
                    null !== (_cells$i = cells[i]) &&
                    void 0 !== _cells$i &&
                    null !== (_cells$i = _cells$i.props) &&
                    void 0 !== _cells$i &&
                    _cells$i.fill
                      ? cells[i].props.fill
                      : 'object' == typeof entry && null != entry && 'fill' in entry
                        ? entry.fill
                        : pieSettings.fill),
                  {
                    value: (0, ChartUtils.uM)(name, pieSettings.dataKey),
                    color,
                    payload: entry,
                    type: pieSettings.legendType,
                  }
                );
              });
          }
        ),
        selectPieSectors = (0, reselect.Mz)(
          [
            selectDisplayedData,
            selectSynchronisedPieSettings,
            pickCells,
            selectChartOffsetInternal.HZ,
          ],
          (displayedData, pieSettings, cells, offset) => {
            if (null != pieSettings && null != displayedData)
              return computePieSectors({ offset, pieSettings, displayedData, cells });
          }
        ),
        hooks = __webpack_require__('./node_modules/recharts/es6/state/hooks.js'),
        Layer = __webpack_require__('./node_modules/recharts/es6/container/Layer.js'),
        Curve = __webpack_require__('./node_modules/recharts/es6/shape/Curve.js'),
        Text = __webpack_require__('./node_modules/recharts/es6/component/Text.js'),
        Cell = __webpack_require__('./node_modules/recharts/es6/component/Cell.js'),
        ReactUtils = __webpack_require__('./node_modules/recharts/es6/util/ReactUtils.js'),
        PolarUtils = __webpack_require__('./node_modules/recharts/es6/util/PolarUtils.js'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        types = __webpack_require__('./node_modules/recharts/es6/util/types.js'),
        ActiveShapeUtils = __webpack_require__(
          './node_modules/recharts/es6/util/ActiveShapeUtils.js'
        ),
        tooltipContext = __webpack_require__(
          './node_modules/recharts/es6/context/tooltipContext.js'
        ),
        SetTooltipEntrySettings = __webpack_require__(
          './node_modules/recharts/es6/state/SetTooltipEntrySettings.js'
        ),
        tooltipSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/tooltipSelectors.js'
        ),
        SetLegendPayload = __webpack_require__(
          './node_modules/recharts/es6/state/SetLegendPayload.js'
        ),
        Constants = __webpack_require__('./node_modules/recharts/es6/util/Constants.js'),
        useAnimationId = __webpack_require__('./node_modules/recharts/es6/util/useAnimationId.js'),
        resolveDefaultProps = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        RegisterGraphicalItemId = __webpack_require__(
          './node_modules/recharts/es6/context/RegisterGraphicalItemId.js'
        ),
        SetGraphicalItem = __webpack_require__(
          './node_modules/recharts/es6/state/SetGraphicalItem.js'
        ),
        svgPropertiesNoEvents = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesNoEvents.js'
        ),
        JavascriptAnimate = __webpack_require__(
          './node_modules/recharts/es6/animation/JavascriptAnimate.js'
        ),
        LabelList = __webpack_require__('./node_modules/recharts/es6/component/LabelList.js'),
        ZIndexLayer = __webpack_require__('./node_modules/recharts/es6/zIndex/ZIndexLayer.js'),
        DefaultZIndexes = __webpack_require__(
          './node_modules/recharts/es6/zIndex/DefaultZIndexes.js'
        ),
        _excluded = ['key'],
        _excluded2 = ['onMouseEnter', 'onClick', 'onMouseLeave'],
        _excluded3 = ['id'],
        _excluded4 = ['id'];
      function Pie_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function Pie_objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? Pie_ownKeys(Object(t), !0).forEach(function (r) {
                Pie_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : Pie_ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function Pie_defineProperty(e, r, t) {
        return (
          (r = (function Pie_toPropertyKey(t) {
            var i = (function Pie_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function _objectWithoutProperties(e, t) {
        if (null == e) return {};
        var o,
          r,
          i = (function _objectWithoutPropertiesLoose(r, e) {
            if (null == r) return {};
            var t = {};
            for (var n in r)
              if ({}.hasOwnProperty.call(r, n)) {
                if (-1 !== e.indexOf(n)) continue;
                t[n] = r[n];
              }
            return t;
          })(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++)
            ((o = n[r]),
              -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
        }
        return i;
      }
      function SetPiePayloadLegend(props) {
        var cells = (0, react.useMemo)(
            () => (0, ReactUtils.aS)(props.children, Cell.f),
            [props.children]
          ),
          legendPayload = (0, hooks.G)((state) => selectPieLegend(state, props.id, cells));
        return null == legendPayload
          ? null
          : react.createElement(SetLegendPayload._, { legendPayload });
      }
      var SetPieTooltipEntrySettings = react.memo((_ref) => {
          var {
              dataKey,
              nameKey,
              sectors,
              stroke,
              strokeWidth,
              fill,
              name,
              hide,
              tooltipType,
              id,
            } = _ref,
            tooltipEntrySettings = {
              dataDefinedOnItem: sectors.map((p) => p.tooltipPayload),
              positions: sectors.map((p) => p.tooltipPosition),
              settings: {
                stroke,
                strokeWidth,
                fill,
                dataKey,
                nameKey,
                name: (0, ChartUtils.uM)(name, dataKey),
                hide,
                type: tooltipType,
                color: fill,
                unit: '',
                graphicalItemId: id,
              },
            };
          return react.createElement(SetTooltipEntrySettings.r, { tooltipEntrySettings });
        }),
        parseCoordinateOfPie = (pieSettings, offset, dataPoint) => {
          var { top, left, width, height } = offset,
            maxPieRadius = (0, PolarUtils.lY)(width, height),
            cx = left + (0, DataUtils.F4)(pieSettings.cx, width, width / 2),
            cy = top + (0, DataUtils.F4)(pieSettings.cy, height, height / 2),
            innerRadius = (0, DataUtils.F4)(pieSettings.innerRadius, maxPieRadius, 0),
            outerRadius = ((dataPoint, outerRadius, maxPieRadius) =>
              'function' == typeof outerRadius
                ? (0, DataUtils.F4)(outerRadius(dataPoint), maxPieRadius, 0.8 * maxPieRadius)
                : (0, DataUtils.F4)(outerRadius, maxPieRadius, 0.8 * maxPieRadius))(
              dataPoint,
              pieSettings.outerRadius,
              maxPieRadius
            );
          return {
            cx,
            cy,
            innerRadius,
            outerRadius,
            maxRadius: pieSettings.maxRadius || Math.sqrt(width * width + height * height) / 2,
          };
        };
      function PieLabels(_ref2) {
        var { sectors, props, showLabels } = _ref2,
          { label, labelLine, dataKey } = props;
        if (!showLabels || !label || !sectors) return null;
        var pieProps = (0, svgPropertiesNoEvents.uZ)(props),
          customLabelProps = (0, svgPropertiesNoEvents.ic)(label),
          customLabelLineProps = (0, svgPropertiesNoEvents.ic)(labelLine),
          offsetRadius =
            ('object' == typeof label &&
              'offsetRadius' in label &&
              'number' == typeof label.offsetRadius &&
              label.offsetRadius) ||
            20,
          labels = sectors.map((entry, i) => {
            var x,
              cx,
              midAngle = (entry.startAngle + entry.endAngle) / 2,
              endPoint = (0, PolarUtils.IZ)(
                entry.cx,
                entry.cy,
                entry.outerRadius + offsetRadius,
                midAngle
              ),
              labelProps = Pie_objectSpread(
                Pie_objectSpread(
                  Pie_objectSpread(Pie_objectSpread({}, pieProps), entry),
                  {},
                  { stroke: 'none' },
                  customLabelProps
                ),
                {},
                {
                  index: i,
                  textAnchor:
                    ((x = endPoint.x),
                    (cx = entry.cx),
                    x > cx ? 'start' : x < cx ? 'end' : 'middle'),
                },
                endPoint
              ),
              lineProps = Pie_objectSpread(
                Pie_objectSpread(
                  Pie_objectSpread(Pie_objectSpread({}, pieProps), entry),
                  {},
                  { fill: 'none', stroke: entry.fill },
                  customLabelLineProps
                ),
                {},
                {
                  index: i,
                  points: [
                    (0, PolarUtils.IZ)(entry.cx, entry.cy, entry.outerRadius, midAngle),
                    endPoint,
                  ],
                  key: 'line',
                }
              );
            return react.createElement(
              ZIndexLayer.g,
              {
                zIndex: DefaultZIndexes.I.label,
                key: 'label-'
                  .concat(entry.startAngle, '-')
                  .concat(entry.endAngle, '-')
                  .concat(entry.midAngle, '-')
                  .concat(i),
              },
              react.createElement(
                Layer.W,
                null,
                labelLine &&
                  ((option, props) => {
                    if (react.isValidElement(option)) return react.cloneElement(option, props);
                    if ('function' == typeof option) return option(props);
                    var className = (0, clsx.$)(
                        'recharts-pie-label-line',
                        'boolean' != typeof option ? option.className : ''
                      ),
                      { key } = props,
                      otherProps = _objectWithoutProperties(props, _excluded);
                    return react.createElement(
                      Curve.I,
                      _extends({}, otherProps, { type: 'linear', className })
                    );
                  })(labelLine, lineProps),
                ((option, props, value) => {
                  if (react.isValidElement(option)) return react.cloneElement(option, props);
                  var label = value;
                  if (
                    'function' == typeof option &&
                    ((label = option(props)), react.isValidElement(label))
                  )
                    return label;
                  var className = (0, clsx.$)(
                    'recharts-pie-label-text',
                    (function getClassNamePropertyIfExists(u) {
                      return u &&
                        'object' == typeof u &&
                        'className' in u &&
                        'string' == typeof u.className
                        ? u.className
                        : '';
                    })(option)
                  );
                  return react.createElement(
                    Text.EY,
                    _extends({}, props, { alignmentBaseline: 'middle', className }),
                    label
                  );
                })(label, labelProps, (0, ChartUtils.kr)(entry, dataKey))
              )
            );
          });
        return react.createElement(Layer.W, { className: 'recharts-pie-labels' }, labels);
      }
      function PieLabelList(_ref3) {
        var { sectors, props, showLabels } = _ref3,
          { label } = props;
        return 'object' == typeof label && null != label && 'position' in label
          ? react.createElement(LabelList.qY, { label })
          : react.createElement(PieLabels, { sectors, props, showLabels });
      }
      function PieSectors(props) {
        var {
            sectors,
            activeShape,
            inactiveShape: inactiveShapeProp,
            allOtherPieProps,
            shape,
            id,
          } = props,
          activeIndex = (0, hooks.G)(tooltipSelectors.A2),
          activeDataKey = (0, hooks.G)(tooltipSelectors.Xb),
          activeGraphicalItemId = (0, hooks.G)(tooltipSelectors.fx),
          {
            onMouseEnter: onMouseEnterFromProps,
            onClick: onItemClickFromProps,
            onMouseLeave: onMouseLeaveFromProps,
          } = allOtherPieProps,
          restOfAllOtherProps = _objectWithoutProperties(allOtherPieProps, _excluded2),
          onMouseEnterFromContext = (0, tooltipContext.Cj)(
            onMouseEnterFromProps,
            allOtherPieProps.dataKey,
            id
          ),
          onMouseLeaveFromContext = (0, tooltipContext.Pg)(onMouseLeaveFromProps),
          onClickFromContext = (0, tooltipContext.Ub)(
            onItemClickFromProps,
            allOtherPieProps.dataKey,
            id
          );
        return null == sectors || 0 === sectors.length
          ? null
          : react.createElement(
              react.Fragment,
              null,
              sectors.map((entry, i) => {
                if (
                  0 === (null == entry ? void 0 : entry.startAngle) &&
                  0 === (null == entry ? void 0 : entry.endAngle) &&
                  1 !== sectors.length
                )
                  return null;
                var graphicalItemMatches =
                    null == activeGraphicalItemId || activeGraphicalItemId === id,
                  isActive =
                    String(i) === activeIndex &&
                    (null == activeDataKey || allOtherPieProps.dataKey === activeDataKey) &&
                    graphicalItemMatches,
                  sectorOptions =
                    activeShape && isActive ? activeShape : activeIndex ? inactiveShapeProp : null,
                  sectorProps = Pie_objectSpread(
                    Pie_objectSpread({}, entry),
                    {},
                    { stroke: entry.stroke, tabIndex: -1, [Constants.F0]: i, [Constants.yU]: id }
                  );
                return react.createElement(
                  Layer.W,
                  _extends(
                    {
                      key: 'sector-'
                        .concat(null == entry ? void 0 : entry.startAngle, '-')
                        .concat(null == entry ? void 0 : entry.endAngle, '-')
                        .concat(entry.midAngle, '-')
                        .concat(i),
                      tabIndex: -1,
                      className: 'recharts-pie-sector',
                    },
                    (0, types.XC)(restOfAllOtherProps, entry, i),
                    {
                      onMouseEnter: onMouseEnterFromContext(entry, i),
                      onMouseLeave: onMouseLeaveFromContext(entry, i),
                      onClick: onClickFromContext(entry, i),
                    }
                  ),
                  react.createElement(
                    ActiveShapeUtils.y,
                    _extends(
                      {
                        option: null != shape ? shape : sectorOptions,
                        index: i,
                        shapeType: 'sector',
                        isActive,
                      },
                      sectorProps
                    )
                  )
                );
              })
            );
      }
      function computePieSectors(_ref4) {
        var _pieSettings$paddingA,
          sectors,
          prev,
          { pieSettings, displayedData, cells, offset } = _ref4,
          { cornerRadius, startAngle, endAngle, dataKey, nameKey, tooltipType } = pieSettings,
          minAngle = Math.abs(pieSettings.minAngle),
          deltaAngle = ((startAngle, endAngle) =>
            (0, DataUtils.sA)(endAngle - startAngle) *
            Math.min(Math.abs(endAngle - startAngle), 360))(startAngle, endAngle),
          absDeltaAngle = Math.abs(deltaAngle),
          paddingAngle =
            displayedData.length <= 1
              ? 0
              : null !== (_pieSettings$paddingA = pieSettings.paddingAngle) &&
                  void 0 !== _pieSettings$paddingA
                ? _pieSettings$paddingA
                : 0,
          notZeroItemCount = displayedData.filter(
            (entry) => 0 !== (0, ChartUtils.kr)(entry, dataKey, 0)
          ).length,
          realTotalAngle =
            absDeltaAngle -
            notZeroItemCount * minAngle -
            (absDeltaAngle >= 360 ? notZeroItemCount : notZeroItemCount - 1) * paddingAngle,
          sum = displayedData.reduce((result, entry) => {
            var val = (0, ChartUtils.kr)(entry, dataKey, 0);
            return result + ((0, DataUtils.Et)(val) ? val : 0);
          }, 0);
        sum > 0 &&
          (sectors = displayedData.map((entry, i) => {
            var tempStartAngle,
              val = (0, ChartUtils.kr)(entry, dataKey, 0),
              name = (0, ChartUtils.kr)(entry, nameKey, i),
              coordinate = parseCoordinateOfPie(pieSettings, offset, entry),
              percent = ((0, DataUtils.Et)(val) ? val : 0) / sum,
              entryWithCellInfo = Pie_objectSpread(
                Pie_objectSpread({}, entry),
                cells && cells[i] && cells[i].props
              ),
              tempEndAngle =
                (tempStartAngle = i
                  ? prev.endAngle +
                    (0, DataUtils.sA)(deltaAngle) * paddingAngle * (0 !== val ? 1 : 0)
                  : startAngle) +
                (0, DataUtils.sA)(deltaAngle) *
                  ((0 !== val ? minAngle : 0) + percent * realTotalAngle),
              midAngle = (tempStartAngle + tempEndAngle) / 2,
              middleRadius = (coordinate.innerRadius + coordinate.outerRadius) / 2,
              tooltipPayload = [
                {
                  name,
                  value: val,
                  payload: entryWithCellInfo,
                  dataKey,
                  type: tooltipType,
                  graphicalItemId: pieSettings.id,
                },
              ],
              tooltipPosition = (0, PolarUtils.IZ)(
                coordinate.cx,
                coordinate.cy,
                middleRadius,
                midAngle
              );
            return (prev = Pie_objectSpread(
              Pie_objectSpread(
                Pie_objectSpread(
                  Pie_objectSpread({}, pieSettings.presentationProps),
                  {},
                  {
                    percent,
                    cornerRadius:
                      'string' == typeof cornerRadius ? parseFloat(cornerRadius) : cornerRadius,
                    name,
                    tooltipPayload,
                    midAngle,
                    middleRadius,
                    tooltipPosition,
                  },
                  entryWithCellInfo
                ),
                coordinate
              ),
              {},
              {
                value: val,
                dataKey,
                startAngle: tempStartAngle,
                endAngle: tempEndAngle,
                payload: entryWithCellInfo,
                paddingAngle: (0, DataUtils.sA)(deltaAngle) * paddingAngle,
              }
            ));
          }));
        return sectors;
      }
      function PieLabelListProvider(_ref5) {
        var { showLabels, sectors, children } = _ref5,
          labelListEntries = (0, react.useMemo)(
            () =>
              showLabels && sectors
                ? sectors.map((entry) => ({
                    value: entry.value,
                    payload: entry.payload,
                    clockWise: !1,
                    parentViewBox: void 0,
                    viewBox: {
                      cx: entry.cx,
                      cy: entry.cy,
                      innerRadius: entry.innerRadius,
                      outerRadius: entry.outerRadius,
                      startAngle: entry.startAngle,
                      endAngle: entry.endAngle,
                      clockWise: !1,
                    },
                    fill: entry.fill,
                  }))
                : [],
            [sectors, showLabels]
          );
        return react.createElement(
          LabelList.dL,
          { value: showLabels ? labelListEntries : void 0 },
          children
        );
      }
      function SectorsWithAnimation(_ref6) {
        var { props, previousSectorsRef, id } = _ref6,
          {
            sectors,
            isAnimationActive,
            animationBegin,
            animationDuration,
            animationEasing,
            activeShape,
            inactiveShape,
            onAnimationStart,
            onAnimationEnd,
          } = props,
          animationId = (0, useAnimationId.n)(props, 'recharts-pie-'),
          prevSectors = previousSectorsRef.current,
          [isAnimating, setIsAnimating] = (0, react.useState)(!1),
          handleAnimationEnd = (0, react.useCallback)(() => {
            ('function' == typeof onAnimationEnd && onAnimationEnd(), setIsAnimating(!1));
          }, [onAnimationEnd]),
          handleAnimationStart = (0, react.useCallback)(() => {
            ('function' == typeof onAnimationStart && onAnimationStart(), setIsAnimating(!0));
          }, [onAnimationStart]);
        return react.createElement(
          PieLabelListProvider,
          { showLabels: !isAnimating, sectors },
          react.createElement(
            JavascriptAnimate.J,
            {
              animationId,
              begin: animationBegin,
              duration: animationDuration,
              isActive: isAnimationActive,
              easing: animationEasing,
              onAnimationStart: handleAnimationStart,
              onAnimationEnd: handleAnimationEnd,
              key: animationId,
            },
            (t) => {
              var stepData = [],
                first = sectors && sectors[0],
                curAngle = null == first ? void 0 : first.startAngle;
              return (
                null == sectors ||
                  sectors.forEach((entry, index) => {
                    var prev = prevSectors && prevSectors[index],
                      paddingAngle = index > 0 ? get_default()(entry, 'paddingAngle', 0) : 0;
                    if (prev) {
                      var angle = (0, DataUtils.GW)(
                          prev.endAngle - prev.startAngle,
                          entry.endAngle - entry.startAngle,
                          t
                        ),
                        latest = Pie_objectSpread(
                          Pie_objectSpread({}, entry),
                          {},
                          {
                            startAngle: curAngle + paddingAngle,
                            endAngle: curAngle + angle + paddingAngle,
                          }
                        );
                      (stepData.push(latest), (curAngle = latest.endAngle));
                    } else {
                      var { endAngle, startAngle } = entry,
                        deltaAngle = (0, DataUtils.GW)(0, endAngle - startAngle, t),
                        _latest = Pie_objectSpread(
                          Pie_objectSpread({}, entry),
                          {},
                          {
                            startAngle: curAngle + paddingAngle,
                            endAngle: curAngle + deltaAngle + paddingAngle,
                          }
                        );
                      (stepData.push(_latest), (curAngle = _latest.endAngle));
                    }
                  }),
                (previousSectorsRef.current = stepData),
                react.createElement(
                  Layer.W,
                  null,
                  react.createElement(PieSectors, {
                    sectors: stepData,
                    activeShape,
                    inactiveShape,
                    allOtherPieProps: props,
                    shape: props.shape,
                    id,
                  })
                )
              );
            }
          ),
          react.createElement(PieLabelList, { showLabels: !isAnimating, sectors, props }),
          props.children
        );
      }
      var defaultPieProps = {
        animationBegin: 400,
        animationDuration: 1500,
        animationEasing: 'ease',
        cx: '50%',
        cy: '50%',
        dataKey: 'value',
        endAngle: 360,
        fill: '#808080',
        hide: !1,
        innerRadius: 0,
        isAnimationActive: 'auto',
        label: !1,
        labelLine: !0,
        legendType: 'rect',
        minAngle: 0,
        nameKey: 'name',
        outerRadius: '80%',
        paddingAngle: 0,
        rootTabIndex: 0,
        startAngle: 0,
        stroke: '#fff',
        zIndex: DefaultZIndexes.I.area,
      };
      function PieImpl(props) {
        var { id } = props,
          propsWithoutId = _objectWithoutProperties(props, _excluded3),
          { hide, className, rootTabIndex } = props,
          cells = (0, react.useMemo)(
            () => (0, ReactUtils.aS)(props.children, Cell.f),
            [props.children]
          ),
          sectors = (0, hooks.G)((state) => selectPieSectors(state, id, cells)),
          previousSectorsRef = (0, react.useRef)(null),
          layerClass = (0, clsx.$)('recharts-pie', className);
        return hide || null == sectors
          ? ((previousSectorsRef.current = null),
            react.createElement(Layer.W, { tabIndex: rootTabIndex, className: layerClass }))
          : react.createElement(
              ZIndexLayer.g,
              { zIndex: props.zIndex },
              react.createElement(SetPieTooltipEntrySettings, {
                dataKey: props.dataKey,
                nameKey: props.nameKey,
                sectors,
                stroke: props.stroke,
                strokeWidth: props.strokeWidth,
                fill: props.fill,
                name: props.name,
                hide: props.hide,
                tooltipType: props.tooltipType,
                id,
              }),
              react.createElement(
                Layer.W,
                { tabIndex: rootTabIndex, className: layerClass },
                react.createElement(SectorsWithAnimation, {
                  props: Pie_objectSpread(Pie_objectSpread({}, propsWithoutId), {}, { sectors }),
                  previousSectorsRef,
                  id,
                })
              )
            );
      }
      function Pie(outsideProps) {
        var props = (0, resolveDefaultProps.e)(outsideProps, defaultPieProps),
          { id: externalId } = props,
          propsWithoutId = _objectWithoutProperties(props, _excluded4),
          presentationProps = (0, svgPropertiesNoEvents.uZ)(propsWithoutId);
        return react.createElement(
          RegisterGraphicalItemId.x,
          { id: externalId, type: 'pie' },
          (id) =>
            react.createElement(
              react.Fragment,
              null,
              react.createElement(SetGraphicalItem.v, {
                type: 'pie',
                id,
                data: propsWithoutId.data,
                dataKey: propsWithoutId.dataKey,
                hide: propsWithoutId.hide,
                angleAxisId: 0,
                radiusAxisId: 0,
                name: propsWithoutId.name,
                nameKey: propsWithoutId.nameKey,
                tooltipType: propsWithoutId.tooltipType,
                legendType: propsWithoutId.legendType,
                fill: propsWithoutId.fill,
                cx: propsWithoutId.cx,
                cy: propsWithoutId.cy,
                startAngle: propsWithoutId.startAngle,
                endAngle: propsWithoutId.endAngle,
                paddingAngle: propsWithoutId.paddingAngle,
                minAngle: propsWithoutId.minAngle,
                innerRadius: propsWithoutId.innerRadius,
                outerRadius: propsWithoutId.outerRadius,
                cornerRadius: propsWithoutId.cornerRadius,
                presentationProps,
                maxRadius: props.maxRadius,
              }),
              react.createElement(SetPiePayloadLegend, _extends({}, propsWithoutId, { id })),
              react.createElement(PieImpl, _extends({}, propsWithoutId, { id }))
            )
        );
      }
      Pie.displayName = 'Pie';
    },
    './node_modules/recharts/es6/shape/Curve.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { I: () => Curve });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js');
      function noop() {}
      function point(that, x, y) {
        that._context.bezierCurveTo(
          (2 * that._x0 + that._x1) / 3,
          (2 * that._y0 + that._y1) / 3,
          (that._x0 + 2 * that._x1) / 3,
          (that._y0 + 2 * that._y1) / 3,
          (that._x0 + 4 * that._x1 + x) / 6,
          (that._y0 + 4 * that._y1 + y) / 6
        );
      }
      function Basis(context) {
        this._context = context;
      }
      function BasisClosed(context) {
        this._context = context;
      }
      function BasisOpen(context) {
        this._context = context;
      }
      ((Basis.prototype = {
        areaStart: function () {
          this._line = 0;
        },
        areaEnd: function () {
          this._line = NaN;
        },
        lineStart: function () {
          ((this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0));
        },
        lineEnd: function () {
          switch (this._point) {
            case 3:
              point(this, this._x1, this._y1);
            case 2:
              this._context.lineTo(this._x1, this._y1);
          }
          ((this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),
            (this._line = 1 - this._line));
        },
        point: function (x, y) {
          switch (((x = +x), (y = +y), this._point)) {
            case 0:
              ((this._point = 1),
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y));
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              ((this._point = 3),
                this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6));
            default:
              point(this, x, y);
          }
          ((this._x0 = this._x1), (this._x1 = x), (this._y0 = this._y1), (this._y1 = y));
        },
      }),
        (BasisClosed.prototype = {
          areaStart: noop,
          areaEnd: noop,
          lineStart: function () {
            ((this._x0 =
              this._x1 =
              this._x2 =
              this._x3 =
              this._x4 =
              this._y0 =
              this._y1 =
              this._y2 =
              this._y3 =
              this._y4 =
                NaN),
              (this._point = 0));
          },
          lineEnd: function () {
            switch (this._point) {
              case 1:
                (this._context.moveTo(this._x2, this._y2), this._context.closePath());
                break;
              case 2:
                (this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3),
                  this._context.lineTo(
                    (this._x3 + 2 * this._x2) / 3,
                    (this._y3 + 2 * this._y2) / 3
                  ),
                  this._context.closePath());
                break;
              case 3:
                (this.point(this._x2, this._y2),
                  this.point(this._x3, this._y3),
                  this.point(this._x4, this._y4));
            }
          },
          point: function (x, y) {
            switch (((x = +x), (y = +y), this._point)) {
              case 0:
                ((this._point = 1), (this._x2 = x), (this._y2 = y));
                break;
              case 1:
                ((this._point = 2), (this._x3 = x), (this._y3 = y));
                break;
              case 2:
                ((this._point = 3),
                  (this._x4 = x),
                  (this._y4 = y),
                  this._context.moveTo(
                    (this._x0 + 4 * this._x1 + x) / 6,
                    (this._y0 + 4 * this._y1 + y) / 6
                  ));
                break;
              default:
                point(this, x, y);
            }
            ((this._x0 = this._x1), (this._x1 = x), (this._y0 = this._y1), (this._y1 = y));
          },
        }),
        (BasisOpen.prototype = {
          areaStart: function () {
            this._line = 0;
          },
          areaEnd: function () {
            this._line = NaN;
          },
          lineStart: function () {
            ((this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0));
          },
          lineEnd: function () {
            ((this._line || (0 !== this._line && 3 === this._point)) && this._context.closePath(),
              (this._line = 1 - this._line));
          },
          point: function (x, y) {
            switch (((x = +x), (y = +y), this._point)) {
              case 0:
                this._point = 1;
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3;
                var x0 = (this._x0 + 4 * this._x1 + x) / 6,
                  y0 = (this._y0 + 4 * this._y1 + y) / 6;
                this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
                break;
              case 3:
                this._point = 4;
              default:
                point(this, x, y);
            }
            ((this._x0 = this._x1), (this._x1 = x), (this._y0 = this._y1), (this._y1 = y));
          },
        }));
      class Bump {
        constructor(context, x) {
          ((this._context = context), (this._x = x));
        }
        areaStart() {
          this._line = 0;
        }
        areaEnd() {
          this._line = NaN;
        }
        lineStart() {
          this._point = 0;
        }
        lineEnd() {
          ((this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),
            (this._line = 1 - this._line));
        }
        point(x, y) {
          switch (((x = +x), (y = +y), this._point)) {
            case 0:
              ((this._point = 1),
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y));
              break;
            case 1:
              this._point = 2;
            default:
              this._x
                ? this._context.bezierCurveTo(
                    (this._x0 = (this._x0 + x) / 2),
                    this._y0,
                    this._x0,
                    y,
                    x,
                    y
                  )
                : this._context.bezierCurveTo(
                    this._x0,
                    (this._y0 = (this._y0 + y) / 2),
                    x,
                    this._y0,
                    x,
                    y
                  );
          }
          ((this._x0 = x), (this._y0 = y));
        }
      }
      function LinearClosed(context) {
        this._context = context;
      }
      function Linear(context) {
        this._context = context;
      }
      function linear(context) {
        return new Linear(context);
      }
      function sign(x) {
        return x < 0 ? -1 : 1;
      }
      function slope3(that, x2, y2) {
        var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || (h1 < 0 && -0)),
          s1 = (y2 - that._y1) / (h1 || (h0 < 0 && -0)),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
        return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
      }
      function slope2(that, t) {
        var h = that._x1 - that._x0;
        return h ? ((3 * (that._y1 - that._y0)) / h - t) / 2 : t;
      }
      function monotone_point(that, t0, t1) {
        var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
        that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
      }
      function MonotoneX(context) {
        this._context = context;
      }
      function MonotoneY(context) {
        this._context = new ReflectContext(context);
      }
      function ReflectContext(context) {
        this._context = context;
      }
      function Natural(context) {
        this._context = context;
      }
      function controlPoints(x) {
        var i,
          m,
          n = x.length - 1,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n);
        for (a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1], i = 1; i < n - 1; ++i)
          ((a[i] = 1), (b[i] = 4), (r[i] = 4 * x[i] + 2 * x[i + 1]));
        for (a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n], i = 1; i < n; ++i)
          ((m = a[i] / b[i - 1]), (b[i] -= m), (r[i] -= m * r[i - 1]));
        for (a[n - 1] = r[n - 1] / b[n - 1], i = n - 2; i >= 0; --i)
          a[i] = (r[i] - a[i + 1]) / b[i];
        for (b[n - 1] = (x[n] + a[n - 1]) / 2, i = 0; i < n - 1; ++i)
          b[i] = 2 * x[i + 1] - a[i + 1];
        return [a, b];
      }
      function Step(context, t) {
        ((this._context = context), (this._t = t));
      }
      ((LinearClosed.prototype = {
        areaStart: noop,
        areaEnd: noop,
        lineStart: function () {
          this._point = 0;
        },
        lineEnd: function () {
          this._point && this._context.closePath();
        },
        point: function (x, y) {
          ((x = +x),
            (y = +y),
            this._point
              ? this._context.lineTo(x, y)
              : ((this._point = 1), this._context.moveTo(x, y)));
        },
      }),
        (Linear.prototype = {
          areaStart: function () {
            this._line = 0;
          },
          areaEnd: function () {
            this._line = NaN;
          },
          lineStart: function () {
            this._point = 0;
          },
          lineEnd: function () {
            ((this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),
              (this._line = 1 - this._line));
          },
          point: function (x, y) {
            switch (((x = +x), (y = +y), this._point)) {
              case 0:
                ((this._point = 1),
                  this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y));
                break;
              case 1:
                this._point = 2;
              default:
                this._context.lineTo(x, y);
            }
          },
        }),
        (MonotoneX.prototype = {
          areaStart: function () {
            this._line = 0;
          },
          areaEnd: function () {
            this._line = NaN;
          },
          lineStart: function () {
            ((this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN), (this._point = 0));
          },
          lineEnd: function () {
            switch (this._point) {
              case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
              case 3:
                monotone_point(this, this._t0, slope2(this, this._t0));
            }
            ((this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),
              (this._line = 1 - this._line));
          },
          point: function (x, y) {
            var t1 = NaN;
            if (((y = +y), (x = +x) !== this._x1 || y !== this._y1)) {
              switch (this._point) {
                case 0:
                  ((this._point = 1),
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y));
                  break;
                case 1:
                  this._point = 2;
                  break;
                case 2:
                  ((this._point = 3),
                    monotone_point(this, slope2(this, (t1 = slope3(this, x, y))), t1));
                  break;
                default:
                  monotone_point(this, this._t0, (t1 = slope3(this, x, y)));
              }
              ((this._x0 = this._x1),
                (this._x1 = x),
                (this._y0 = this._y1),
                (this._y1 = y),
                (this._t0 = t1));
            }
          },
        }),
        ((MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {
          MonotoneX.prototype.point.call(this, y, x);
        }),
        (ReflectContext.prototype = {
          moveTo: function (x, y) {
            this._context.moveTo(y, x);
          },
          closePath: function () {
            this._context.closePath();
          },
          lineTo: function (x, y) {
            this._context.lineTo(y, x);
          },
          bezierCurveTo: function (x1, y1, x2, y2, x, y) {
            this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
          },
        }),
        (Natural.prototype = {
          areaStart: function () {
            this._line = 0;
          },
          areaEnd: function () {
            this._line = NaN;
          },
          lineStart: function () {
            ((this._x = []), (this._y = []));
          },
          lineEnd: function () {
            var x = this._x,
              y = this._y,
              n = x.length;
            if (n)
              if (
                (this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]),
                2 === n)
              )
                this._context.lineTo(x[1], y[1]);
              else
                for (
                  var px = controlPoints(x), py = controlPoints(y), i0 = 0, i1 = 1;
                  i1 < n;
                  ++i0, ++i1
                )
                  this._context.bezierCurveTo(
                    px[0][i0],
                    py[0][i0],
                    px[1][i0],
                    py[1][i0],
                    x[i1],
                    y[i1]
                  );
            ((this._line || (0 !== this._line && 1 === n)) && this._context.closePath(),
              (this._line = 1 - this._line),
              (this._x = this._y = null));
          },
          point: function (x, y) {
            (this._x.push(+x), this._y.push(+y));
          },
        }),
        (Step.prototype = {
          areaStart: function () {
            this._line = 0;
          },
          areaEnd: function () {
            this._line = NaN;
          },
          lineStart: function () {
            ((this._x = this._y = NaN), (this._point = 0));
          },
          lineEnd: function () {
            (0 < this._t &&
              this._t < 1 &&
              2 === this._point &&
              this._context.lineTo(this._x, this._y),
              (this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),
              this._line >= 0 && ((this._t = 1 - this._t), (this._line = 1 - this._line)));
          },
          point: function (x, y) {
            switch (((x = +x), (y = +y), this._point)) {
              case 0:
                ((this._point = 1),
                  this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y));
                break;
              case 1:
                this._point = 2;
              default:
                if (this._t <= 0) (this._context.lineTo(this._x, y), this._context.lineTo(x, y));
                else {
                  var x1 = this._x * (1 - this._t) + x * this._t;
                  (this._context.lineTo(x1, this._y), this._context.lineTo(x1, y));
                }
            }
            ((this._x = x), (this._y = y));
          },
        }));
      var array = __webpack_require__('./node_modules/d3-shape/src/array.js'),
        constant = __webpack_require__('./node_modules/d3-shape/src/constant.js'),
        src_path = __webpack_require__('./node_modules/d3-shape/src/path.js');
      function point_x(p) {
        return p[0];
      }
      function point_y(p) {
        return p[1];
      }
      function line(x, y) {
        var defined = (0, constant.A)(!0),
          context = null,
          curve = linear,
          output = null,
          path = (0, src_path.i)(line);
        function line(data) {
          var i,
            d,
            buffer,
            n = (data = (0, array.A)(data)).length,
            defined0 = !1;
          for (null == context && (output = curve((buffer = path()))), i = 0; i <= n; ++i)
            (!(i < n && defined((d = data[i]), i, data)) === defined0 &&
              ((defined0 = !defined0) ? output.lineStart() : output.lineEnd()),
              defined0 && output.point(+x(d, i, data), +y(d, i, data)));
          if (buffer) return ((output = null), buffer + '' || null);
        }
        return (
          (x = 'function' == typeof x ? x : void 0 === x ? point_x : (0, constant.A)(x)),
          (y = 'function' == typeof y ? y : void 0 === y ? point_y : (0, constant.A)(y)),
          (line.x = function (_) {
            return arguments.length
              ? ((x = 'function' == typeof _ ? _ : (0, constant.A)(+_)), line)
              : x;
          }),
          (line.y = function (_) {
            return arguments.length
              ? ((y = 'function' == typeof _ ? _ : (0, constant.A)(+_)), line)
              : y;
          }),
          (line.defined = function (_) {
            return arguments.length
              ? ((defined = 'function' == typeof _ ? _ : (0, constant.A)(!!_)), line)
              : defined;
          }),
          (line.curve = function (_) {
            return arguments.length
              ? ((curve = _), null != context && (output = curve(context)), line)
              : curve;
          }),
          (line.context = function (_) {
            return arguments.length
              ? (null == _ ? (context = output = null) : (output = curve((context = _))), line)
              : context;
          }),
          line
        );
      }
      function src_area(x0, y0, y1) {
        var x1 = null,
          defined = (0, constant.A)(!0),
          context = null,
          curve = linear,
          output = null,
          path = (0, src_path.i)(area);
        function area(data) {
          var i,
            j,
            k,
            d,
            buffer,
            n = (data = (0, array.A)(data)).length,
            defined0 = !1,
            x0z = new Array(n),
            y0z = new Array(n);
          for (null == context && (output = curve((buffer = path()))), i = 0; i <= n; ++i) {
            if (!(i < n && defined((d = data[i]), i, data)) === defined0)
              if ((defined0 = !defined0)) ((j = i), output.areaStart(), output.lineStart());
              else {
                for (output.lineEnd(), output.lineStart(), k = i - 1; k >= j; --k)
                  output.point(x0z[k], y0z[k]);
                (output.lineEnd(), output.areaEnd());
              }
            defined0 &&
              ((x0z[i] = +x0(d, i, data)),
              (y0z[i] = +y0(d, i, data)),
              output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]));
          }
          if (buffer) return ((output = null), buffer + '' || null);
        }
        function arealine() {
          return line().defined(defined).curve(curve).context(context);
        }
        return (
          (x0 = 'function' == typeof x0 ? x0 : void 0 === x0 ? point_x : (0, constant.A)(+x0)),
          (y0 =
            'function' == typeof y0
              ? y0
              : void 0 === y0
                ? (0, constant.A)(0)
                : (0, constant.A)(+y0)),
          (y1 = 'function' == typeof y1 ? y1 : void 0 === y1 ? point_y : (0, constant.A)(+y1)),
          (area.x = function (_) {
            return arguments.length
              ? ((x0 = 'function' == typeof _ ? _ : (0, constant.A)(+_)), (x1 = null), area)
              : x0;
          }),
          (area.x0 = function (_) {
            return arguments.length
              ? ((x0 = 'function' == typeof _ ? _ : (0, constant.A)(+_)), area)
              : x0;
          }),
          (area.x1 = function (_) {
            return arguments.length
              ? ((x1 = null == _ ? null : 'function' == typeof _ ? _ : (0, constant.A)(+_)), area)
              : x1;
          }),
          (area.y = function (_) {
            return arguments.length
              ? ((y0 = 'function' == typeof _ ? _ : (0, constant.A)(+_)), (y1 = null), area)
              : y0;
          }),
          (area.y0 = function (_) {
            return arguments.length
              ? ((y0 = 'function' == typeof _ ? _ : (0, constant.A)(+_)), area)
              : y0;
          }),
          (area.y1 = function (_) {
            return arguments.length
              ? ((y1 = null == _ ? null : 'function' == typeof _ ? _ : (0, constant.A)(+_)), area)
              : y1;
          }),
          (area.lineX0 = area.lineY0 =
            function () {
              return arealine().x(x0).y(y0);
            }),
          (area.lineY1 = function () {
            return arealine().x(x0).y(y1);
          }),
          (area.lineX1 = function () {
            return arealine().x(x1).y(y0);
          }),
          (area.defined = function (_) {
            return arguments.length
              ? ((defined = 'function' == typeof _ ? _ : (0, constant.A)(!!_)), area)
              : defined;
          }),
          (area.curve = function (_) {
            return arguments.length
              ? ((curve = _), null != context && (output = curve(context)), area)
              : curve;
          }),
          (area.context = function (_) {
            return arguments.length
              ? (null == _ ? (context = output = null) : (output = curve((context = _))), area)
              : context;
          }),
          area
        );
      }
      var clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
        types = __webpack_require__('./node_modules/recharts/es6/util/types.js'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        isWellBehavedNumber = __webpack_require__(
          './node_modules/recharts/es6/util/isWellBehavedNumber.js'
        ),
        svgPropertiesNoEvents = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesNoEvents.js'
        ),
        chartLayoutContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        );
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var CURVE_FACTORIES = {
          curveBasisClosed: function basisClosed(context) {
            return new BasisClosed(context);
          },
          curveBasisOpen: function basisOpen(context) {
            return new BasisOpen(context);
          },
          curveBasis: function basis(context) {
            return new Basis(context);
          },
          curveBumpX: function bumpX(context) {
            return new Bump(context, !0);
          },
          curveBumpY: function bumpY(context) {
            return new Bump(context, !1);
          },
          curveLinearClosed: function linearClosed(context) {
            return new LinearClosed(context);
          },
          curveLinear: linear,
          curveMonotoneX: function monotoneX(context) {
            return new MonotoneX(context);
          },
          curveMonotoneY: function monotoneY(context) {
            return new MonotoneY(context);
          },
          curveNatural: function natural(context) {
            return new Natural(context);
          },
          curveStep: function step(context) {
            return new Step(context, 0.5);
          },
          curveStepAfter: function stepAfter(context) {
            return new Step(context, 1);
          },
          curveStepBefore: function stepBefore(context) {
            return new Step(context, 0);
          },
        },
        defined = (p) => (0, isWellBehavedNumber.H)(p.x) && (0, isWellBehavedNumber.H)(p.y),
        areaDefined = (d) => null != d.base && defined(d.base) && defined(d),
        getX = (p) => p.x,
        getY = (p) => p.y,
        getPath = (_ref) => {
          var { type = 'linear', points = [], baseLine, layout, connectNulls = !1 } = _ref,
            curveFactory = ((type, layout) => {
              if ('function' == typeof type) return type;
              var name = 'curve'.concat((0, DataUtils.Zb)(type));
              return ('curveMonotone' !== name && 'curveBump' !== name) || !layout
                ? CURVE_FACTORIES[name] || linear
                : CURVE_FACTORIES[''.concat(name).concat('vertical' === layout ? 'Y' : 'X')];
            })(type, layout),
            formatPoints = connectNulls ? points.filter(defined) : points;
          if (Array.isArray(baseLine)) {
            var areaPoints = points.map((entry, index) =>
              _objectSpread(_objectSpread({}, entry), {}, { base: baseLine[index] })
            );
            return (
              'vertical' === layout
                ? src_area()
                    .y(getY)
                    .x1(getX)
                    .x0((d) => d.base.x)
                : src_area()
                    .x(getX)
                    .y1(getY)
                    .y0((d) => d.base.y)
            )
              .defined(areaDefined)
              .curve(curveFactory)(connectNulls ? areaPoints.filter(areaDefined) : areaPoints);
          }
          return (
            'vertical' === layout && (0, DataUtils.Et)(baseLine)
              ? src_area().y(getY).x1(getX).x0(baseLine)
              : (0, DataUtils.Et)(baseLine)
                ? src_area().x(getX).y1(getY).y0(baseLine)
                : line().x(getX).y(getY)
          )
            .defined(defined)
            .curve(curveFactory)(formatPoints);
        },
        Curve = (props) => {
          var { className, points, path, pathRef } = props,
            layout = (0, chartLayoutContext.WX)();
          if (!((points && points.length) || path)) return null;
          var getPathInput = {
              type: props.type,
              points: props.points,
              baseLine: props.baseLine,
              layout: props.layout || layout,
              connectNulls: props.connectNulls,
            },
            realPath = points && points.length ? getPath(getPathInput) : path;
          return react.createElement(
            'path',
            _extends({}, (0, svgPropertiesNoEvents.uZ)(props), (0, types._U)(props), {
              className: (0, clsx.$)('recharts-curve', className),
              d: null === realPath ? void 0 : realPath,
              ref: pathRef,
            })
          );
        };
    },
    './node_modules/recharts/es6/shape/Rectangle.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { M: () => Rectangle });
      var _templateObject,
        _templateObject2,
        _templateObject3,
        _templateObject4,
        _templateObject5,
        _templateObject6,
        _templateObject7,
        _templateObject8,
        _templateObject9,
        _templateObject0,
        react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/clsx/dist/clsx.mjs'
        ),
        _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        _animation_JavascriptAnimate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/animation/JavascriptAnimate.js'
        ),
        _util_DataUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        ),
        _util_useAnimationId__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          './node_modules/recharts/es6/util/useAnimationId.js'
        ),
        _animation_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          './node_modules/recharts/es6/animation/util.js'
        ),
        _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesAndEvents.js'
        ),
        _util_round__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          './node_modules/recharts/es6/util/round.js'
        ),
        _excluded = ['radius'],
        _excluded2 = ['radius'];
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function _objectWithoutProperties(e, t) {
        if (null == e) return {};
        var o,
          r,
          i = (function _objectWithoutPropertiesLoose(r, e) {
            if (null == r) return {};
            var t = {};
            for (var n in r)
              if ({}.hasOwnProperty.call(r, n)) {
                if (-1 !== e.indexOf(n)) continue;
                t[n] = r[n];
              }
            return t;
          })(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++)
            ((o = n[r]),
              -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
        }
        return i;
      }
      function _taggedTemplateLiteral(e, t) {
        return (
          t || (t = e.slice(0)),
          Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } }))
        );
      }
      var getRectanglePath = (x, y, width, height, radius) => {
          var path,
            roundedWidth = (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.L)(width),
            roundedHeight = (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.L)(height),
            maxRadius = Math.min(Math.abs(roundedWidth) / 2, Math.abs(roundedHeight) / 2),
            ySign = roundedHeight >= 0 ? 1 : -1,
            xSign = roundedWidth >= 0 ? 1 : -1,
            clockWise =
              (roundedHeight >= 0 && roundedWidth >= 0) || (roundedHeight < 0 && roundedWidth < 0)
                ? 1
                : 0;
          if (maxRadius > 0 && radius instanceof Array) {
            for (var newRadius = [0, 0, 0, 0], i = 0; i < 4; i++)
              newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
            ((path = (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.Y)(
              _templateObject || (_templateObject = _taggedTemplateLiteral(['M', ',', ''])),
              x,
              y + ySign * newRadius[0]
            )),
              newRadius[0] > 0 &&
                (path += (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.Y)(
                  _templateObject2 ||
                    (_templateObject2 = _taggedTemplateLiteral(['A ', ',', ',0,0,', ',', ',', ''])),
                  newRadius[0],
                  newRadius[0],
                  clockWise,
                  x + xSign * newRadius[0],
                  y
                )),
              (path += (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.Y)(
                _templateObject3 || (_templateObject3 = _taggedTemplateLiteral(['L ', ',', ''])),
                x + width - xSign * newRadius[1],
                y
              )),
              newRadius[1] > 0 &&
                (path += (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.Y)(
                  _templateObject4 ||
                    (_templateObject4 = _taggedTemplateLiteral([
                      'A ',
                      ',',
                      ',0,0,',
                      ',\n        ',
                      ',',
                      '',
                    ])),
                  newRadius[1],
                  newRadius[1],
                  clockWise,
                  x + width,
                  y + ySign * newRadius[1]
                )),
              (path += (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.Y)(
                _templateObject5 || (_templateObject5 = _taggedTemplateLiteral(['L ', ',', ''])),
                x + width,
                y + height - ySign * newRadius[2]
              )),
              newRadius[2] > 0 &&
                (path += (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.Y)(
                  _templateObject6 ||
                    (_templateObject6 = _taggedTemplateLiteral([
                      'A ',
                      ',',
                      ',0,0,',
                      ',\n        ',
                      ',',
                      '',
                    ])),
                  newRadius[2],
                  newRadius[2],
                  clockWise,
                  x + width - xSign * newRadius[2],
                  y + height
                )),
              (path += (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.Y)(
                _templateObject7 || (_templateObject7 = _taggedTemplateLiteral(['L ', ',', ''])),
                x + xSign * newRadius[3],
                y + height
              )),
              newRadius[3] > 0 &&
                (path += (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.Y)(
                  _templateObject8 ||
                    (_templateObject8 = _taggedTemplateLiteral([
                      'A ',
                      ',',
                      ',0,0,',
                      ',\n        ',
                      ',',
                      '',
                    ])),
                  newRadius[3],
                  newRadius[3],
                  clockWise,
                  x,
                  y + height - ySign * newRadius[3]
                )),
              (path += 'Z'));
          } else if (maxRadius > 0 && radius === +radius && radius > 0) {
            var _newRadius = Math.min(maxRadius, radius);
            path = (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.Y)(
              _templateObject9 ||
                (_templateObject9 = _taggedTemplateLiteral([
                  'M ',
                  ',',
                  '\n            A ',
                  ',',
                  ',0,0,',
                  ',',
                  ',',
                  '\n            L ',
                  ',',
                  '\n            A ',
                  ',',
                  ',0,0,',
                  ',',
                  ',',
                  '\n            L ',
                  ',',
                  '\n            A ',
                  ',',
                  ',0,0,',
                  ',',
                  ',',
                  '\n            L ',
                  ',',
                  '\n            A ',
                  ',',
                  ',0,0,',
                  ',',
                  ',',
                  ' Z',
                ])),
              x,
              y + ySign * _newRadius,
              _newRadius,
              _newRadius,
              clockWise,
              x + xSign * _newRadius,
              y,
              x + width - xSign * _newRadius,
              y,
              _newRadius,
              _newRadius,
              clockWise,
              x + width,
              y + ySign * _newRadius,
              x + width,
              y + height - ySign * _newRadius,
              _newRadius,
              _newRadius,
              clockWise,
              x + width - xSign * _newRadius,
              y + height,
              x + xSign * _newRadius,
              y + height,
              _newRadius,
              _newRadius,
              clockWise,
              x,
              y + height - ySign * _newRadius
            );
          } else
            path = (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.Y)(
              _templateObject0 ||
                (_templateObject0 = _taggedTemplateLiteral(['M ', ',', ' h ', ' v ', ' h ', ' Z'])),
              x,
              y,
              width,
              height,
              -width
            );
          return path;
        },
        defaultRectangleProps = {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          radius: 0,
          isAnimationActive: !1,
          isUpdateAnimationActive: !1,
          animationBegin: 0,
          animationDuration: 1500,
          animationEasing: 'ease',
        },
        Rectangle = (rectangleProps) => {
          var props = (0, _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_2__.e)(
              rectangleProps,
              defaultRectangleProps
            ),
            pathRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),
            [totalLength, setTotalLength] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1);
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
            if (pathRef.current && pathRef.current.getTotalLength)
              try {
                var pathTotalLength = pathRef.current.getTotalLength();
                pathTotalLength && setTotalLength(pathTotalLength);
              } catch (_unused) {}
          }, []);
          var { x, y, width, height, radius, className } = props,
            {
              animationEasing,
              animationDuration,
              animationBegin,
              isAnimationActive,
              isUpdateAnimationActive,
            } = props,
            prevWidthRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(width),
            prevHeightRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(height),
            prevXRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(x),
            prevYRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(y),
            animationIdInput = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(
              () => ({ x, y, width, height, radius }),
              [x, y, width, height, radius]
            ),
            animationId = (0, _util_useAnimationId__WEBPACK_IMPORTED_MODULE_5__.n)(
              animationIdInput,
              'rectangle-'
            );
          if (
            x !== +x ||
            y !== +y ||
            width !== +width ||
            height !== +height ||
            0 === width ||
            0 === height
          )
            return null;
          var layerClass = (0, clsx__WEBPACK_IMPORTED_MODULE_1__.$)(
            'recharts-rectangle',
            className
          );
          if (!isUpdateAnimationActive) {
            var _svgPropertiesAndEven = (0,
              _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_7__.a)(props),
              { radius: _ } = _svgPropertiesAndEven,
              otherPathProps = _objectWithoutProperties(_svgPropertiesAndEven, _excluded);
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
              'path',
              _extends({}, otherPathProps, {
                x: (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.L)(x),
                y: (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.L)(y),
                width: (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.L)(width),
                height: (0, _util_round__WEBPACK_IMPORTED_MODULE_8__.L)(height),
                radius: 'number' == typeof radius ? radius : void 0,
                className: layerClass,
                d: getRectanglePath(x, y, width, height, radius),
              })
            );
          }
          var prevWidth = prevWidthRef.current,
            prevHeight = prevHeightRef.current,
            prevX = prevXRef.current,
            prevY = prevYRef.current,
            from = '0px '.concat(-1 === totalLength ? 1 : totalLength, 'px'),
            to = ''.concat(totalLength, 'px 0px'),
            transition = (0, _animation_util__WEBPACK_IMPORTED_MODULE_6__.dl)(
              ['strokeDasharray'],
              animationDuration,
              'string' == typeof animationEasing
                ? animationEasing
                : defaultRectangleProps.animationEasing
            );
          return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
            _animation_JavascriptAnimate__WEBPACK_IMPORTED_MODULE_3__.J,
            {
              animationId,
              key: animationId,
              canBegin: totalLength > 0,
              duration: animationDuration,
              easing: animationEasing,
              isActive: isUpdateAnimationActive,
              begin: animationBegin,
            },
            (t) => {
              var animationStyle,
                currWidth = (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_4__.GW)(
                  prevWidth,
                  width,
                  t
                ),
                currHeight = (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_4__.GW)(
                  prevHeight,
                  height,
                  t
                ),
                currX = (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_4__.GW)(prevX, x, t),
                currY = (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_4__.GW)(prevY, y, t);
              (pathRef.current &&
                ((prevWidthRef.current = currWidth),
                (prevHeightRef.current = currHeight),
                (prevXRef.current = currX),
                (prevYRef.current = currY)),
                (animationStyle = isAnimationActive
                  ? t > 0
                    ? { transition, strokeDasharray: to }
                    : { strokeDasharray: from }
                  : { strokeDasharray: to }));
              var _svgPropertiesAndEven2 = (0,
                _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_7__.a)(props),
                { radius: _ } = _svgPropertiesAndEven2,
                otherPathProps = _objectWithoutProperties(_svgPropertiesAndEven2, _excluded2);
              return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
                'path',
                _extends({}, otherPathProps, {
                  radius: 'number' == typeof radius ? radius : void 0,
                  className: layerClass,
                  d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
                  ref: pathRef,
                  style: _objectSpread(_objectSpread({}, animationStyle), props.style),
                })
              );
            }
          );
        };
    },
    './node_modules/recharts/es6/shape/Sector.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { h: () => Sector });
      var _templateObject,
        _templateObject2,
        _templateObject3,
        _templateObject4,
        _templateObject5,
        _templateObject6,
        _templateObject7,
        react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/clsx/dist/clsx.mjs'
        ),
        _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/util/PolarUtils.js'
        ),
        _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        ),
        _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesAndEvents.js'
        ),
        _util_round__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          './node_modules/recharts/es6/util/round.js'
        );
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function _taggedTemplateLiteral(e, t) {
        return (
          t || (t = e.slice(0)),
          Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } }))
        );
      }
      var getTangentCircle = (_ref) => {
          var { cx, cy, radius, angle, sign, isExternal, cornerRadius, cornerIsExternal } = _ref,
            centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius,
            theta =
              Math.asin(cornerRadius / centerRadius) /
              _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__.Kg,
            centerAngle = cornerIsExternal ? angle : angle + sign * theta,
            lineTangencyAngle = cornerIsExternal ? angle - sign * theta : angle;
          return {
            center: (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__.IZ)(
              cx,
              cy,
              centerRadius,
              centerAngle
            ),
            circleTangency: (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__.IZ)(
              cx,
              cy,
              radius,
              centerAngle
            ),
            lineTangency: (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__.IZ)(
              cx,
              cy,
              centerRadius * Math.cos(theta * _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__.Kg),
              lineTangencyAngle
            ),
            theta,
          };
        },
        getSectorPath = (_ref2) => {
          var { cx, cy, innerRadius, outerRadius, startAngle, endAngle } = _ref2,
            angle = ((startAngle, endAngle) =>
              (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.sA)(endAngle - startAngle) *
              Math.min(Math.abs(endAngle - startAngle), 359.999))(startAngle, endAngle),
            tempEndAngle = startAngle + angle,
            outerStartPoint = (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__.IZ)(
              cx,
              cy,
              outerRadius,
              startAngle
            ),
            outerEndPoint = (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__.IZ)(
              cx,
              cy,
              outerRadius,
              tempEndAngle
            ),
            path = (0, _util_round__WEBPACK_IMPORTED_MODULE_6__.Y)(
              _templateObject ||
                (_templateObject = _taggedTemplateLiteral([
                  'M ',
                  ',',
                  '\n    A ',
                  ',',
                  ',0,\n    ',
                  ',',
                  ',\n    ',
                  ',',
                  '\n  ',
                ])),
              outerStartPoint.x,
              outerStartPoint.y,
              outerRadius,
              outerRadius,
              +(Math.abs(angle) > 180),
              +(startAngle > tempEndAngle),
              outerEndPoint.x,
              outerEndPoint.y
            );
          if (innerRadius > 0) {
            var innerStartPoint = (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__.IZ)(
                cx,
                cy,
                innerRadius,
                startAngle
              ),
              innerEndPoint = (0, _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__.IZ)(
                cx,
                cy,
                innerRadius,
                tempEndAngle
              );
            path += (0, _util_round__WEBPACK_IMPORTED_MODULE_6__.Y)(
              _templateObject2 ||
                (_templateObject2 = _taggedTemplateLiteral([
                  'L ',
                  ',',
                  '\n            A ',
                  ',',
                  ',0,\n            ',
                  ',',
                  ',\n            ',
                  ',',
                  ' Z',
                ])),
              innerEndPoint.x,
              innerEndPoint.y,
              innerRadius,
              innerRadius,
              +(Math.abs(angle) > 180),
              +(startAngle <= tempEndAngle),
              innerStartPoint.x,
              innerStartPoint.y
            );
          } else
            path += (0, _util_round__WEBPACK_IMPORTED_MODULE_6__.Y)(
              _templateObject3 || (_templateObject3 = _taggedTemplateLiteral(['L ', ',', ' Z'])),
              cx,
              cy
            );
          return path;
        },
        defaultSectorProps = {
          cx: 0,
          cy: 0,
          innerRadius: 0,
          outerRadius: 0,
          startAngle: 0,
          endAngle: 0,
          cornerRadius: 0,
          forceCornerRadius: !1,
          cornerIsExternal: !1,
        },
        Sector = (sectorProps) => {
          var props = (0, _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_4__.e)(
              sectorProps,
              defaultSectorProps
            ),
            {
              cx,
              cy,
              innerRadius,
              outerRadius,
              cornerRadius,
              forceCornerRadius,
              cornerIsExternal,
              startAngle,
              endAngle,
              className,
            } = props;
          if (outerRadius < innerRadius || startAngle === endAngle) return null;
          var path,
            layerClass = (0, clsx__WEBPACK_IMPORTED_MODULE_1__.$)('recharts-sector', className),
            deltaRadius = outerRadius - innerRadius,
            cr = (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.F4)(
              cornerRadius,
              deltaRadius,
              0,
              !0
            );
          return (
            (path =
              cr > 0 && Math.abs(startAngle - endAngle) < 360
                ? ((_ref3) => {
                    var {
                        cx,
                        cy,
                        innerRadius,
                        outerRadius,
                        cornerRadius,
                        forceCornerRadius,
                        cornerIsExternal,
                        startAngle,
                        endAngle,
                      } = _ref3,
                      sign = (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.sA)(
                        endAngle - startAngle
                      ),
                      {
                        circleTangency: soct,
                        lineTangency: solt,
                        theta: sot,
                      } = getTangentCircle({
                        cx,
                        cy,
                        radius: outerRadius,
                        angle: startAngle,
                        sign,
                        cornerRadius,
                        cornerIsExternal,
                      }),
                      {
                        circleTangency: eoct,
                        lineTangency: eolt,
                        theta: eot,
                      } = getTangentCircle({
                        cx,
                        cy,
                        radius: outerRadius,
                        angle: endAngle,
                        sign: -sign,
                        cornerRadius,
                        cornerIsExternal,
                      }),
                      outerArcAngle = cornerIsExternal
                        ? Math.abs(startAngle - endAngle)
                        : Math.abs(startAngle - endAngle) - sot - eot;
                    if (outerArcAngle < 0)
                      return forceCornerRadius
                        ? (0, _util_round__WEBPACK_IMPORTED_MODULE_6__.Y)(
                            _templateObject4 ||
                              (_templateObject4 = _taggedTemplateLiteral([
                                'M ',
                                ',',
                                '\n        a',
                                ',',
                                ',0,0,1,',
                                ',0\n        a',
                                ',',
                                ',0,0,1,',
                                ',0\n      ',
                              ])),
                            solt.x,
                            solt.y,
                            cornerRadius,
                            cornerRadius,
                            2 * cornerRadius,
                            cornerRadius,
                            cornerRadius,
                            2 * -cornerRadius
                          )
                        : getSectorPath({ cx, cy, innerRadius, outerRadius, startAngle, endAngle });
                    var path = (0, _util_round__WEBPACK_IMPORTED_MODULE_6__.Y)(
                      _templateObject5 ||
                        (_templateObject5 = _taggedTemplateLiteral([
                          'M ',
                          ',',
                          '\n    A',
                          ',',
                          ',0,0,',
                          ',',
                          ',',
                          '\n    A',
                          ',',
                          ',0,',
                          ',',
                          ',',
                          ',',
                          '\n    A',
                          ',',
                          ',0,0,',
                          ',',
                          ',',
                          '\n  ',
                        ])),
                      solt.x,
                      solt.y,
                      cornerRadius,
                      cornerRadius,
                      +(sign < 0),
                      soct.x,
                      soct.y,
                      outerRadius,
                      outerRadius,
                      +(outerArcAngle > 180),
                      +(sign < 0),
                      eoct.x,
                      eoct.y,
                      cornerRadius,
                      cornerRadius,
                      +(sign < 0),
                      eolt.x,
                      eolt.y
                    );
                    if (innerRadius > 0) {
                      var {
                          circleTangency: sict,
                          lineTangency: silt,
                          theta: sit,
                        } = getTangentCircle({
                          cx,
                          cy,
                          radius: innerRadius,
                          angle: startAngle,
                          sign,
                          isExternal: !0,
                          cornerRadius,
                          cornerIsExternal,
                        }),
                        {
                          circleTangency: eict,
                          lineTangency: eilt,
                          theta: eit,
                        } = getTangentCircle({
                          cx,
                          cy,
                          radius: innerRadius,
                          angle: endAngle,
                          sign: -sign,
                          isExternal: !0,
                          cornerRadius,
                          cornerIsExternal,
                        }),
                        innerArcAngle = cornerIsExternal
                          ? Math.abs(startAngle - endAngle)
                          : Math.abs(startAngle - endAngle) - sit - eit;
                      if (innerArcAngle < 0 && 0 === cornerRadius)
                        return ''.concat(path, 'L').concat(cx, ',').concat(cy, 'Z');
                      path += (0, _util_round__WEBPACK_IMPORTED_MODULE_6__.Y)(
                        _templateObject6 ||
                          (_templateObject6 = _taggedTemplateLiteral([
                            'L',
                            ',',
                            '\n      A',
                            ',',
                            ',0,0,',
                            ',',
                            ',',
                            '\n      A',
                            ',',
                            ',0,',
                            ',',
                            ',',
                            ',',
                            '\n      A',
                            ',',
                            ',0,0,',
                            ',',
                            ',',
                            'Z',
                          ])),
                        eilt.x,
                        eilt.y,
                        cornerRadius,
                        cornerRadius,
                        +(sign < 0),
                        eict.x,
                        eict.y,
                        innerRadius,
                        innerRadius,
                        +(innerArcAngle > 180),
                        +(sign > 0),
                        sict.x,
                        sict.y,
                        cornerRadius,
                        cornerRadius,
                        +(sign < 0),
                        silt.x,
                        silt.y
                      );
                    } else
                      path += (0, _util_round__WEBPACK_IMPORTED_MODULE_6__.Y)(
                        _templateObject7 ||
                          (_templateObject7 = _taggedTemplateLiteral(['L', ',', 'Z'])),
                        cx,
                        cy
                      );
                    return path;
                  })({
                    cx,
                    cy,
                    innerRadius,
                    outerRadius,
                    cornerRadius: Math.min(cr, deltaRadius / 2),
                    forceCornerRadius,
                    cornerIsExternal,
                    startAngle,
                    endAngle,
                  })
                : getSectorPath({ cx, cy, innerRadius, outerRadius, startAngle, endAngle })),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(
              'path',
              _extends(
                {},
                (0, _util_svgPropertiesAndEvents__WEBPACK_IMPORTED_MODULE_5__.a)(props),
                { className: layerClass, d: path }
              )
            )
          );
        };
    },
    './node_modules/recharts/es6/state/RechartsReduxContext.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { E: () => RechartsReduxContext });
      var RechartsReduxContext = (0,
      __webpack_require__('./node_modules/next/dist/compiled/react/index.js').createContext)(null);
    },
    './node_modules/recharts/es6/state/RechartsStoreProvider.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { J: () => RechartsStoreProvider });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        react_redux = __webpack_require__('./node_modules/react-redux/dist/react-redux.mjs'),
        redux = __webpack_require__('./node_modules/redux/dist/redux.mjs'),
        redux_toolkit_modern = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        optionsSlice = __webpack_require__('./node_modules/recharts/es6/state/optionsSlice.js'),
        tooltipSlice = __webpack_require__('./node_modules/recharts/es6/state/tooltipSlice.js'),
        chartDataSlice = __webpack_require__('./node_modules/recharts/es6/state/chartDataSlice.js'),
        layoutSlice = __webpack_require__('./node_modules/recharts/es6/state/layoutSlice.js'),
        mouseEventsMiddleware = __webpack_require__(
          './node_modules/recharts/es6/state/mouseEventsMiddleware.js'
        );
      function reduxDevtoolsJsonStringifyReplacer(key, value) {
        return value instanceof HTMLElement
          ? 'HTMLElement <'.concat(value.tagName, ' class="').concat(value.className, '">')
          : value === window
            ? 'global.window'
            : 'children' === key && 'object' == typeof value && null !== value
              ? '<<CHILDREN>>'
              : value;
      }
      var cartesianAxisSlice = __webpack_require__(
          './node_modules/recharts/es6/state/cartesianAxisSlice.js'
        ),
        graphicalItemsSlice = __webpack_require__(
          './node_modules/recharts/es6/state/graphicalItemsSlice.js'
        ),
        immer = __webpack_require__(
          './node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs'
        ),
        dist_immer = __webpack_require__('./node_modules/immer/dist/immer.mjs'),
        referenceElementsSlice = (0, redux_toolkit_modern.Z0)({
          name: 'referenceElements',
          initialState: { dots: [], areas: [], lines: [] },
          reducers: {
            addDot: (state, action) => {
              state.dots.push(action.payload);
            },
            removeDot: (state, action) => {
              var index = (0, immer.ss)(state).dots.findIndex((dot) => dot === action.payload);
              -1 !== index && state.dots.splice(index, 1);
            },
            addArea: (state, action) => {
              state.areas.push(action.payload);
            },
            removeArea: (state, action) => {
              var index = (0, immer.ss)(state).areas.findIndex((area) => area === action.payload);
              -1 !== index && state.areas.splice(index, 1);
            },
            addLine: (state, action) => {
              state.lines.push((0, dist_immer.h4)(action.payload));
            },
            removeLine: (state, action) => {
              var index = (0, immer.ss)(state).lines.findIndex((line) => line === action.payload);
              -1 !== index && state.lines.splice(index, 1);
            },
          },
        }),
        { addDot, removeDot, addArea, removeArea, addLine, removeLine } =
          referenceElementsSlice.actions,
        referenceElementsReducer = referenceElementsSlice.reducer,
        brushSlice_initialState = {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          padding: { top: 0, right: 0, bottom: 0, left: 0 },
        },
        brushSlice = (0, redux_toolkit_modern.Z0)({
          name: 'brush',
          initialState: brushSlice_initialState,
          reducers: {
            setBrushSettings: (_state, action) =>
              null == action.payload ? brushSlice_initialState : action.payload,
          },
        }),
        { setBrushSettings } = brushSlice.actions,
        brushReducer = brushSlice.reducer,
        legendSlice = __webpack_require__('./node_modules/recharts/es6/state/legendSlice.js'),
        rootPropsSlice = __webpack_require__('./node_modules/recharts/es6/state/rootPropsSlice.js'),
        polarAxisSlice = (0, redux_toolkit_modern.Z0)({
          name: 'polarAxis',
          initialState: { radiusAxis: {}, angleAxis: {} },
          reducers: {
            addRadiusAxis(state, action) {
              state.radiusAxis[action.payload.id] = (0, dist_immer.h4)(action.payload);
            },
            removeRadiusAxis(state, action) {
              delete state.radiusAxis[action.payload.id];
            },
            addAngleAxis(state, action) {
              state.angleAxis[action.payload.id] = (0, dist_immer.h4)(action.payload);
            },
            removeAngleAxis(state, action) {
              delete state.angleAxis[action.payload.id];
            },
          },
        }),
        { addRadiusAxis, removeRadiusAxis, addAngleAxis, removeAngleAxis } = polarAxisSlice.actions,
        polarAxisReducer = polarAxisSlice.reducer,
        polarOptionsSlice = __webpack_require__(
          './node_modules/recharts/es6/state/polarOptionsSlice.js'
        ),
        keyboardEventsMiddleware = __webpack_require__(
          './node_modules/recharts/es6/state/keyboardEventsMiddleware.js'
        ),
        externalEventsMiddleware = __webpack_require__(
          './node_modules/recharts/es6/state/externalEventsMiddleware.js'
        ),
        touchEventsMiddleware = __webpack_require__(
          './node_modules/recharts/es6/state/touchEventsMiddleware.js'
        ),
        errorBarSlice = (0, redux_toolkit_modern.Z0)({
          name: 'errorBars',
          initialState: {},
          reducers: {
            addErrorBar: (state, action) => {
              var { itemId, errorBar } = action.payload;
              (state[itemId] || (state[itemId] = []), state[itemId].push(errorBar));
            },
            replaceErrorBar: (state, action) => {
              var { itemId, prev, next } = action.payload;
              state[itemId] &&
                (state[itemId] = state[itemId].map((e) =>
                  e.dataKey === prev.dataKey && e.direction === prev.direction ? next : e
                ));
            },
            removeErrorBar: (state, action) => {
              var { itemId, errorBar } = action.payload;
              state[itemId] &&
                (state[itemId] = state[itemId].filter(
                  (e) => e.dataKey !== errorBar.dataKey || e.direction !== errorBar.direction
                ));
            },
          },
        }),
        { addErrorBar, replaceErrorBar, removeErrorBar } = errorBarSlice.actions,
        errorBarReducer = errorBarSlice.reducer,
        Global = __webpack_require__('./node_modules/recharts/es6/util/Global.js'),
        zIndexSlice = __webpack_require__('./node_modules/recharts/es6/state/zIndexSlice.js'),
        rootReducer = (0, redux.HY)({
          brush: brushReducer,
          cartesianAxis: cartesianAxisSlice.CA,
          chartData: chartDataSlice.LV,
          errorBars: errorBarReducer,
          graphicalItems: graphicalItemsSlice.iZ,
          layout: layoutSlice.Vp,
          legend: legendSlice.CU,
          options: optionsSlice.lJ,
          polarAxis: polarAxisReducer,
          polarOptions: polarOptionsSlice.J,
          referenceElements: referenceElementsReducer,
          rootProps: rootPropsSlice.vE,
          tooltip: tooltipSlice.En,
          zIndex: zIndexSlice.v3,
        }),
        PanoramaContext = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        ),
        RechartsReduxContext = __webpack_require__(
          './node_modules/recharts/es6/state/RechartsReduxContext.js'
        );
      function RechartsStoreProvider(_ref) {
        var { preloadedState, children, reduxStoreName } = _ref,
          isPanorama = (0, PanoramaContext.r)(),
          storeRef = (0, react.useRef)(null);
        if (isPanorama) return children;
        null == storeRef.current &&
          (storeRef.current = (function createRechartsStore(preloadedState) {
            var chartName =
              arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'Chart';
            return (0, redux_toolkit_modern.U1)({
              reducer: rootReducer,
              preloadedState,
              middleware: (getDefaultMiddleware) =>
                getDefaultMiddleware({
                  serializableCheck: !1,
                  immutableCheck: !['commonjs', 'es6', 'production'].includes('es6'),
                }).concat([
                  mouseEventsMiddleware.YF.middleware,
                  mouseEventsMiddleware.fP.middleware,
                  keyboardEventsMiddleware.$7.middleware,
                  externalEventsMiddleware.x.middleware,
                  touchEventsMiddleware.k.middleware,
                ]),
              enhancers: (getDefaultEnhancers) => {
                var enhancers = getDefaultEnhancers;
                return (
                  'function' == typeof getDefaultEnhancers && (enhancers = getDefaultEnhancers()),
                  enhancers.concat((0, redux_toolkit_modern.CF)({ type: 'raf' }))
                );
              },
              devTools: Global.m.devToolsEnabled && {
                serialize: { replacer: reduxDevtoolsJsonStringifyReplacer },
                name: 'recharts-'.concat(chartName),
              },
            });
          })(preloadedState, reduxStoreName));
        var nonNullContext = RechartsReduxContext.E;
        return react.createElement(
          react_redux.Kq,
          { context: nonNullContext, store: storeRef.current },
          children
        );
      }
    },
    './node_modules/recharts/es6/state/ReportChartProps.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { p: () => ReportChartProps });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        _rootPropsSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/rootPropsSlice.js'
        ),
        _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        );
      function ReportChartProps(props) {
        var dispatch = (0, _hooks__WEBPACK_IMPORTED_MODULE_2__.j)();
        return (
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
            dispatch((0, _rootPropsSlice__WEBPACK_IMPORTED_MODULE_1__.mZ)(props));
          }, [dispatch, props]),
          null
        );
      }
    },
    './node_modules/recharts/es6/state/ReportMainChartProps.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { s: () => ReportMainChartProps });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        ),
        _layoutSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/state/layoutSlice.js'
        ),
        _hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _util_propsAreEqual__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/util/propsAreEqual.js'
        );
      function ReportMainChartPropsImpl(_ref) {
        var { layout, margin } = _ref,
          dispatch = (0, _hooks__WEBPACK_IMPORTED_MODULE_3__.j)(),
          isPanorama = (0, _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_1__.r)();
        return (
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
            isPanorama ||
              (dispatch((0, _layoutSlice__WEBPACK_IMPORTED_MODULE_2__.JK)(layout)),
              dispatch((0, _layoutSlice__WEBPACK_IMPORTED_MODULE_2__.B_)(margin)));
          }, [dispatch, isPanorama, layout, margin]),
          null
        );
      }
      var ReportMainChartProps = (0, react__WEBPACK_IMPORTED_MODULE_0__.memo)(
        ReportMainChartPropsImpl,
        _util_propsAreEqual__WEBPACK_IMPORTED_MODULE_4__.P
      );
    },
    './node_modules/recharts/es6/state/SetGraphicalItem.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        p: () => SetCartesianGraphicalItem,
        v: () => SetPolarGraphicalItem,
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _graphicalItemsSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/state/graphicalItemsSlice.js'
        ),
        SetCartesianGraphicalItemImpl = (props) => {
          var dispatch = (0, _hooks__WEBPACK_IMPORTED_MODULE_1__.j)(),
            prevPropsRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
          return (
            (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
              (null === prevPropsRef.current
                ? dispatch((0, _graphicalItemsSlice__WEBPACK_IMPORTED_MODULE_2__.g5)(props))
                : prevPropsRef.current !== props &&
                  dispatch(
                    (0, _graphicalItemsSlice__WEBPACK_IMPORTED_MODULE_2__.ZF)({
                      prev: prevPropsRef.current,
                      next: props,
                    })
                  ),
                (prevPropsRef.current = props));
            }, [dispatch, props]),
            (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(
              () => () => {
                prevPropsRef.current &&
                  (dispatch(
                    (0, _graphicalItemsSlice__WEBPACK_IMPORTED_MODULE_2__.Vi)(prevPropsRef.current)
                  ),
                  (prevPropsRef.current = null));
              },
              [dispatch]
            ),
            null
          );
        },
        SetCartesianGraphicalItem = (0, react__WEBPACK_IMPORTED_MODULE_0__.memo)(
          SetCartesianGraphicalItemImpl
        );
      function SetPolarGraphicalItem(props) {
        var dispatch = (0, _hooks__WEBPACK_IMPORTED_MODULE_1__.j)();
        return (
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(
            () => (
              dispatch((0, _graphicalItemsSlice__WEBPACK_IMPORTED_MODULE_2__.As)(props)),
              () => {
                dispatch((0, _graphicalItemsSlice__WEBPACK_IMPORTED_MODULE_2__.TK)(props));
              }
            ),
            [dispatch, props]
          ),
          null
        );
      }
    },
    './node_modules/recharts/es6/state/SetLegendPayload.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        A: () => SetLegendPayload,
        _: () => SetPolarLegendPayload,
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        ),
        _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        _hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _legendSlice__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/state/legendSlice.js'
        );
      function SetLegendPayload(_ref) {
        var { legendPayload } = _ref,
          dispatch = (0, _hooks__WEBPACK_IMPORTED_MODULE_3__.j)(),
          isPanorama = (0, _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_1__.r)(),
          prevPayloadRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
        return (
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
            isPanorama ||
              (null === prevPayloadRef.current
                ? dispatch((0, _legendSlice__WEBPACK_IMPORTED_MODULE_4__.Lx)(legendPayload))
                : prevPayloadRef.current !== legendPayload &&
                  dispatch(
                    (0, _legendSlice__WEBPACK_IMPORTED_MODULE_4__.c5)({
                      prev: prevPayloadRef.current,
                      next: legendPayload,
                    })
                  ),
              (prevPayloadRef.current = legendPayload));
          }, [dispatch, isPanorama, legendPayload]),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(
            () => () => {
              prevPayloadRef.current &&
                (dispatch(
                  (0, _legendSlice__WEBPACK_IMPORTED_MODULE_4__.u3)(prevPayloadRef.current)
                ),
                (prevPayloadRef.current = null));
            },
            [dispatch]
          ),
          null
        );
      }
      function SetPolarLegendPayload(_ref2) {
        var { legendPayload } = _ref2,
          dispatch = (0, _hooks__WEBPACK_IMPORTED_MODULE_3__.j)(),
          layout = (0, _hooks__WEBPACK_IMPORTED_MODULE_3__.G)(
            _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_2__.fz
          ),
          prevPayloadRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
        return (
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
            ('centric' !== layout && 'radial' !== layout) ||
              (null === prevPayloadRef.current
                ? dispatch((0, _legendSlice__WEBPACK_IMPORTED_MODULE_4__.Lx)(legendPayload))
                : prevPayloadRef.current !== legendPayload &&
                  dispatch(
                    (0, _legendSlice__WEBPACK_IMPORTED_MODULE_4__.c5)({
                      prev: prevPayloadRef.current,
                      next: legendPayload,
                    })
                  ),
              (prevPayloadRef.current = legendPayload));
          }, [dispatch, layout, legendPayload]),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(
            () => () => {
              prevPayloadRef.current &&
                (dispatch(
                  (0, _legendSlice__WEBPACK_IMPORTED_MODULE_4__.u3)(prevPayloadRef.current)
                ),
                (prevPayloadRef.current = null));
            },
            [dispatch]
          ),
          null
        );
      }
    },
    './node_modules/recharts/es6/state/SetTooltipEntrySettings.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { r: () => SetTooltipEntrySettings });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _tooltipSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/state/tooltipSlice.js'
        ),
        _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        );
      function SetTooltipEntrySettings(_ref) {
        var { tooltipEntrySettings } = _ref,
          dispatch = (0, _hooks__WEBPACK_IMPORTED_MODULE_1__.j)(),
          isPanorama = (0, _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_3__.r)(),
          prevSettingsRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
        return (
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
            isPanorama ||
              (null === prevSettingsRef.current
                ? dispatch((0, _tooltipSlice__WEBPACK_IMPORTED_MODULE_2__.Ix)(tooltipEntrySettings))
                : prevSettingsRef.current !== tooltipEntrySettings &&
                  dispatch(
                    (0, _tooltipSlice__WEBPACK_IMPORTED_MODULE_2__.Zp)({
                      prev: prevSettingsRef.current,
                      next: tooltipEntrySettings,
                    })
                  ),
              (prevSettingsRef.current = tooltipEntrySettings));
          }, [tooltipEntrySettings, dispatch, isPanorama]),
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(
            () => () => {
              prevSettingsRef.current &&
                (dispatch(
                  (0, _tooltipSlice__WEBPACK_IMPORTED_MODULE_2__.XB)(prevSettingsRef.current)
                ),
                (prevSettingsRef.current = null));
            },
            [dispatch]
          ),
          null
        );
      }
    },
    './node_modules/recharts/es6/state/cartesianAxisSlice.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        CA: () => cartesianAxisReducer,
        MC: () => removeXAxis,
        QG: () => updateYAxisWidth,
        Vi: () => addXAxis,
        W3: () => defaultAxisId,
        cU: () => addYAxis,
        fR: () => removeYAxis,
        hd: () => replaceYAxis,
        m2: () => replaceXAxis,
      });
      var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/immer/dist/immer.mjs'
        );
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var defaultAxisId = 0,
        cartesianAxisSlice = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Z0)({
          name: 'cartesianAxis',
          initialState: { xAxis: {}, yAxis: {}, zAxis: {} },
          reducers: {
            addXAxis: {
              reducer(state, action) {
                state.xAxis[action.payload.id] = (0, immer__WEBPACK_IMPORTED_MODULE_1__.h4)(
                  action.payload
                );
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            replaceXAxis: {
              reducer(state, action) {
                var { prev, next } = action.payload;
                void 0 !== state.xAxis[prev.id] &&
                  (prev.id !== next.id && delete state.xAxis[prev.id],
                  (state.xAxis[next.id] = (0, immer__WEBPACK_IMPORTED_MODULE_1__.h4)(next)));
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            removeXAxis: {
              reducer(state, action) {
                delete state.xAxis[action.payload.id];
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            addYAxis: {
              reducer(state, action) {
                state.yAxis[action.payload.id] = (0, immer__WEBPACK_IMPORTED_MODULE_1__.h4)(
                  action.payload
                );
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            replaceYAxis: {
              reducer(state, action) {
                var { prev, next } = action.payload;
                void 0 !== state.yAxis[prev.id] &&
                  (prev.id !== next.id && delete state.yAxis[prev.id],
                  (state.yAxis[next.id] = (0, immer__WEBPACK_IMPORTED_MODULE_1__.h4)(next)));
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            removeYAxis: {
              reducer(state, action) {
                delete state.yAxis[action.payload.id];
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            addZAxis: {
              reducer(state, action) {
                state.zAxis[action.payload.id] = (0, immer__WEBPACK_IMPORTED_MODULE_1__.h4)(
                  action.payload
                );
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            replaceZAxis: {
              reducer(state, action) {
                var { prev, next } = action.payload;
                void 0 !== state.zAxis[prev.id] &&
                  (prev.id !== next.id && delete state.zAxis[prev.id],
                  (state.zAxis[next.id] = (0, immer__WEBPACK_IMPORTED_MODULE_1__.h4)(next)));
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            removeZAxis: {
              reducer(state, action) {
                delete state.zAxis[action.payload.id];
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            updateYAxisWidth(state, action) {
              var { id, width } = action.payload,
                axis = state.yAxis[id];
              if (axis) {
                var history = axis.widthHistory || [];
                if (
                  3 === history.length &&
                  history[0] === history[2] &&
                  width === history[1] &&
                  width !== axis.width &&
                  Math.abs(width - history[0]) <= 1
                )
                  return;
                var newHistory = [...history, width].slice(-3);
                state.yAxis[id] = _objectSpread(
                  _objectSpread({}, state.yAxis[id]),
                  {},
                  { width, widthHistory: newHistory }
                );
              }
            },
          },
        }),
        {
          addXAxis,
          replaceXAxis,
          removeXAxis,
          addYAxis,
          replaceYAxis,
          removeYAxis,
          addZAxis,
          replaceZAxis,
          removeZAxis,
          updateYAxisWidth,
        } = cartesianAxisSlice.actions,
        cartesianAxisReducer = cartesianAxisSlice.reducer;
    },
    './node_modules/recharts/es6/state/chartDataSlice.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        LV: () => chartDataReducer,
        M: () => setDataStartEndIndexes,
        hq: () => setChartData,
      });
      var initialChartDataState = {
          chartData: void 0,
          computedData: void 0,
          dataStartIndex: 0,
          dataEndIndex: 0,
        },
        chartDataSlice = (0,
        __webpack_require__('./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs').Z0)({
          name: 'chartData',
          initialState: initialChartDataState,
          reducers: {
            setChartData(state, action) {
              if (((state.chartData = action.payload), null == action.payload))
                return ((state.dataStartIndex = 0), void (state.dataEndIndex = 0));
              action.payload.length > 0 &&
                state.dataEndIndex !== action.payload.length - 1 &&
                (state.dataEndIndex = action.payload.length - 1);
            },
            setComputedData(state, action) {
              state.computedData = action.payload;
            },
            setDataStartEndIndexes(state, action) {
              var { startIndex, endIndex } = action.payload;
              (null != startIndex && (state.dataStartIndex = startIndex),
                null != endIndex && (state.dataEndIndex = endIndex));
            },
          },
        }),
        { setChartData, setDataStartEndIndexes, setComputedData } = chartDataSlice.actions,
        chartDataReducer = chartDataSlice.reducer;
    },
    './node_modules/recharts/es6/state/externalEventsMiddleware.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        x: () => externalEventsMiddleware,
        y: () => externalEventAction,
      });
      var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/tooltipSelectors.js'
        ),
        externalEventAction = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.VP)(
          'externalEvent'
        ),
        externalEventsMiddleware = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Nc)(),
        rafIdMap = new Map();
      externalEventsMiddleware.startListening({
        actionCreator: externalEventAction,
        effect: (action, listenerApi) => {
          var { handler, reactEvent } = action.payload;
          if (null != handler) {
            reactEvent.persist();
            var eventType = reactEvent.type,
              existingRafId = rafIdMap.get(eventType);
            void 0 !== existingRafId && cancelAnimationFrame(existingRafId);
            var rafId = requestAnimationFrame(() => {
              try {
                var state = listenerApi.getState(),
                  nextState = {
                    activeCoordinate: (0,
                    _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_1__.eE)(state),
                    activeDataKey: (0, _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_1__.Xb)(
                      state
                    ),
                    activeIndex: (0, _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_1__.A2)(
                      state
                    ),
                    activeLabel: (0, _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_1__.BZ)(
                      state
                    ),
                    activeTooltipIndex: (0,
                    _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_1__.A2)(state),
                    isTooltipActive: (0,
                    _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_1__.yn)(state),
                  };
                handler(nextState, reactEvent);
              } finally {
                rafIdMap.delete(eventType);
              }
            });
            rafIdMap.set(eventType, rafId);
          }
        },
      });
    },
    './node_modules/recharts/es6/state/graphicalItemsSlice.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        As: () => addPolarGraphicalItem,
        TK: () => removePolarGraphicalItem,
        Vi: () => removeCartesianGraphicalItem,
        ZF: () => replaceCartesianGraphicalItem,
        g5: () => addCartesianGraphicalItem,
        iZ: () => graphicalItemsReducer,
      });
      var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs'
        ),
        immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/immer/dist/immer.mjs'
        ),
        graphicalItemsSlice = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Z0)({
          name: 'graphicalItems',
          initialState: { cartesianItems: [], polarItems: [] },
          reducers: {
            addCartesianGraphicalItem: {
              reducer(state, action) {
                state.cartesianItems.push(
                  (0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(action.payload)
                );
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            replaceCartesianGraphicalItem: {
              reducer(state, action) {
                var { prev, next } = action.payload,
                  index = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.ss)(
                    state
                  ).cartesianItems.indexOf((0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(prev));
                index > -1 &&
                  (state.cartesianItems[index] = (0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(next));
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            removeCartesianGraphicalItem: {
              reducer(state, action) {
                var index = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.ss)(
                  state
                ).cartesianItems.indexOf(
                  (0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(action.payload)
                );
                index > -1 && state.cartesianItems.splice(index, 1);
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            addPolarGraphicalItem: {
              reducer(state, action) {
                state.polarItems.push((0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(action.payload));
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            removePolarGraphicalItem: {
              reducer(state, action) {
                var index = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.ss)(
                  state
                ).polarItems.indexOf((0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(action.payload));
                index > -1 && state.polarItems.splice(index, 1);
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
          },
        }),
        {
          addCartesianGraphicalItem,
          replaceCartesianGraphicalItem,
          removeCartesianGraphicalItem,
          addPolarGraphicalItem,
          removePolarGraphicalItem,
        } = graphicalItemsSlice.actions,
        graphicalItemsReducer = graphicalItemsSlice.reducer;
    },
    './node_modules/recharts/es6/state/hooks.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        G: () => useAppSelector,
        j: () => useAppDispatch,
      });
      var use_sync_external_store_shim_with_selector__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__('./node_modules/use-sync-external-store/shim/with-selector.js'),
        react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        _RechartsReduxContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/state/RechartsReduxContext.js'
        ),
        noopDispatch = (a) => a,
        useAppDispatch = () => {
          var context = (0, react__WEBPACK_IMPORTED_MODULE_1__.useContext)(
            _RechartsReduxContext__WEBPACK_IMPORTED_MODULE_2__.E
          );
          return context ? context.store.dispatch : noopDispatch;
        },
        noop = () => {},
        addNestedSubNoop = () => noop,
        refEquality = (a, b) => a === b;
      function useAppSelector(selector) {
        var context = (0, react__WEBPACK_IMPORTED_MODULE_1__.useContext)(
          _RechartsReduxContext__WEBPACK_IMPORTED_MODULE_2__.E
        );
        return (0,
        use_sync_external_store_shim_with_selector__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStoreWithSelector)(
          context ? context.subscription.addNestedSub : addNestedSubNoop,
          context ? context.store.getState : noop,
          context ? context.store.getState : noop,
          context ? selector : noop,
          refEquality
        );
      }
    },
    './node_modules/recharts/es6/state/keyboardEventsMiddleware.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        $7: () => keyboardEventsMiddleware,
        Ru: () => focusAction,
        uZ: () => keyDownAction,
      });
      var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        _tooltipSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/tooltipSlice.js'
        ),
        _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/tooltipSelectors.js'
        ),
        _selectors_selectors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectors.js'
        ),
        _selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/axisSelectors.js'
        ),
        _selectors_combiners_combineActiveTooltipIndex__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            './node_modules/recharts/es6/state/selectors/combiners/combineActiveTooltipIndex.js'
          ),
        keyDownAction = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.VP)('keyDown'),
        focusAction = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.VP)('focus'),
        keyboardEventsMiddleware = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Nc)();
      (keyboardEventsMiddleware.startListening({
        actionCreator: keyDownAction,
        effect: (action, listenerApi) => {
          var state = listenerApi.getState();
          if (!1 !== state.rootProps.accessibilityLayer) {
            var { keyboardInteraction } = state.tooltip,
              key = action.payload;
            if ('ArrowRight' === key || 'ArrowLeft' === key || 'Enter' === key) {
              var resolvedIndex = (0,
                _selectors_combiners_combineActiveTooltipIndex__WEBPACK_IMPORTED_MODULE_5__.P)(
                  keyboardInteraction,
                  (0, _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_2__.n4)(state),
                  (0, _selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_4__.K6)(state),
                  (0, _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_2__.FO)(state)
                ),
                currentIndex = null == resolvedIndex ? -1 : Number(resolvedIndex);
              if (Number.isFinite(currentIndex) && !(currentIndex < 0)) {
                var tooltipTicks = (0, _selectors_tooltipSelectors__WEBPACK_IMPORTED_MODULE_2__.R4)(
                  state
                );
                if ('Enter' !== key) {
                  var nextIndex =
                    currentIndex +
                    ('ArrowRight' === key ? 1 : -1) *
                      ('left-to-right' ===
                      (0, _selectors_axisSelectors__WEBPACK_IMPORTED_MODULE_4__._y)(state)
                        ? 1
                        : -1);
                  if (
                    !(null == tooltipTicks || nextIndex >= tooltipTicks.length || nextIndex < 0)
                  ) {
                    var coordinate = (0, _selectors_selectors__WEBPACK_IMPORTED_MODULE_3__.pg)(
                      state,
                      'axis',
                      'hover',
                      String(nextIndex)
                    );
                    listenerApi.dispatch(
                      (0, _tooltipSlice__WEBPACK_IMPORTED_MODULE_1__.o4)({
                        active: !0,
                        activeIndex: nextIndex.toString(),
                        activeCoordinate: coordinate,
                      })
                    );
                  }
                } else {
                  var _coordinate = (0, _selectors_selectors__WEBPACK_IMPORTED_MODULE_3__.pg)(
                    state,
                    'axis',
                    'hover',
                    String(keyboardInteraction.index)
                  );
                  listenerApi.dispatch(
                    (0, _tooltipSlice__WEBPACK_IMPORTED_MODULE_1__.o4)({
                      active: !keyboardInteraction.active,
                      activeIndex: keyboardInteraction.index,
                      activeCoordinate: _coordinate,
                    })
                  );
                }
              }
            }
          }
        },
      }),
        keyboardEventsMiddleware.startListening({
          actionCreator: focusAction,
          effect: (_action, listenerApi) => {
            var state = listenerApi.getState();
            if (!1 !== state.rootProps.accessibilityLayer) {
              var { keyboardInteraction } = state.tooltip;
              if (!keyboardInteraction.active && null == keyboardInteraction.index) {
                var coordinate = (0, _selectors_selectors__WEBPACK_IMPORTED_MODULE_3__.pg)(
                  state,
                  'axis',
                  'hover',
                  String('0')
                );
                listenerApi.dispatch(
                  (0, _tooltipSlice__WEBPACK_IMPORTED_MODULE_1__.o4)({
                    active: !0,
                    activeIndex: '0',
                    activeCoordinate: coordinate,
                  })
                );
              }
            }
          },
        }));
    },
    './node_modules/recharts/es6/state/layoutSlice.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        B_: () => setMargin,
        JK: () => setLayout,
        Vp: () => chartLayoutReducer,
        gX: () => setChartSize,
        hF: () => setScale,
      });
      var chartLayoutSlice = (0,
        __webpack_require__('./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs').Z0)({
          name: 'chartLayout',
          initialState: {
            layoutType: 'horizontal',
            width: 0,
            height: 0,
            margin: { top: 5, right: 5, bottom: 5, left: 5 },
            scale: 1,
          },
          reducers: {
            setLayout(state, action) {
              state.layoutType = action.payload;
            },
            setChartSize(state, action) {
              ((state.width = action.payload.width), (state.height = action.payload.height));
            },
            setMargin(state, action) {
              var _action$payload$top,
                _action$payload$right,
                _action$payload$botto,
                _action$payload$left;
              ((state.margin.top =
                null !== (_action$payload$top = action.payload.top) &&
                void 0 !== _action$payload$top
                  ? _action$payload$top
                  : 0),
                (state.margin.right =
                  null !== (_action$payload$right = action.payload.right) &&
                  void 0 !== _action$payload$right
                    ? _action$payload$right
                    : 0),
                (state.margin.bottom =
                  null !== (_action$payload$botto = action.payload.bottom) &&
                  void 0 !== _action$payload$botto
                    ? _action$payload$botto
                    : 0),
                (state.margin.left =
                  null !== (_action$payload$left = action.payload.left) &&
                  void 0 !== _action$payload$left
                    ? _action$payload$left
                    : 0));
            },
            setScale(state, action) {
              state.scale = action.payload;
            },
          },
        }),
        { setMargin, setLayout, setChartSize, setScale } = chartLayoutSlice.actions,
        chartLayoutReducer = chartLayoutSlice.reducer;
    },
    './node_modules/recharts/es6/state/legendSlice.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        CU: () => legendReducer,
        Lx: () => addLegendPayload,
        c5: () => replaceLegendPayload,
        u3: () => removeLegendPayload,
      });
      var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs'
        ),
        immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/immer/dist/immer.mjs'
        ),
        legendSlice = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Z0)({
          name: 'legend',
          initialState: {
            settings: {
              layout: 'horizontal',
              align: 'center',
              verticalAlign: 'middle',
              itemSorter: 'value',
            },
            size: { width: 0, height: 0 },
            payload: [],
          },
          reducers: {
            setLegendSize(state, action) {
              ((state.size.width = action.payload.width),
                (state.size.height = action.payload.height));
            },
            setLegendSettings(state, action) {
              ((state.settings.align = action.payload.align),
                (state.settings.layout = action.payload.layout),
                (state.settings.verticalAlign = action.payload.verticalAlign),
                (state.settings.itemSorter = action.payload.itemSorter));
            },
            addLegendPayload: {
              reducer(state, action) {
                state.payload.push((0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(action.payload));
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            replaceLegendPayload: {
              reducer(state, action) {
                var { prev, next } = action.payload,
                  index = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.ss)(
                    state
                  ).payload.indexOf((0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(prev));
                index > -1 &&
                  (state.payload[index] = (0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(next));
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            removeLegendPayload: {
              reducer(state, action) {
                var index = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.ss)(
                  state
                ).payload.indexOf((0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(action.payload));
                index > -1 && state.payload.splice(index, 1);
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
          },
        }),
        {
          setLegendSize,
          setLegendSettings,
          addLegendPayload,
          replaceLegendPayload,
          removeLegendPayload,
        } = legendSlice.actions,
        legendReducer = legendSlice.reducer;
    },
    './node_modules/recharts/es6/state/mouseEventsMiddleware.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        YF: () => mouseClickMiddleware,
        dj: () => mouseMoveAction,
        fP: () => mouseMoveMiddleware,
        ky: () => mouseClickAction,
      });
      var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        _tooltipSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/tooltipSlice.js'
        ),
        _selectors_selectActivePropsFromChartPointer__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            './node_modules/recharts/es6/state/selectors/selectActivePropsFromChartPointer.js'
          ),
        _selectors_selectTooltipEventType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipEventType.js'
        ),
        _util_getChartPointer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/util/getChartPointer.js'
        ),
        mouseClickAction = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.VP)('mouseClick'),
        mouseClickMiddleware = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Nc)();
      mouseClickMiddleware.startListening({
        actionCreator: mouseClickAction,
        effect: (action, listenerApi) => {
          var mousePointer = action.payload,
            activeProps = (0,
            _selectors_selectActivePropsFromChartPointer__WEBPACK_IMPORTED_MODULE_2__.g)(
              listenerApi.getState(),
              (0, _util_getChartPointer__WEBPACK_IMPORTED_MODULE_4__.w)(mousePointer)
            );
          null != (null == activeProps ? void 0 : activeProps.activeIndex) &&
            listenerApi.dispatch(
              (0, _tooltipSlice__WEBPACK_IMPORTED_MODULE_1__.jF)({
                activeIndex: activeProps.activeIndex,
                activeDataKey: void 0,
                activeCoordinate: activeProps.activeCoordinate,
              })
            );
        },
      });
      var mouseMoveAction = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.VP)('mouseMove'),
        mouseMoveMiddleware = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Nc)(),
        rafId = null;
      mouseMoveMiddleware.startListening({
        actionCreator: mouseMoveAction,
        effect: (action, listenerApi) => {
          var mousePointer = action.payload;
          null !== rafId && cancelAnimationFrame(rafId);
          var chartPointer = (0, _util_getChartPointer__WEBPACK_IMPORTED_MODULE_4__.w)(
            mousePointer
          );
          rafId = requestAnimationFrame(() => {
            var state = listenerApi.getState();
            if (
              'axis' ===
              (0, _selectors_selectTooltipEventType__WEBPACK_IMPORTED_MODULE_3__.au)(
                state,
                state.tooltip.settings.shared
              )
            ) {
              var activeProps = (0,
              _selectors_selectActivePropsFromChartPointer__WEBPACK_IMPORTED_MODULE_2__.g)(
                state,
                chartPointer
              );
              null != (null == activeProps ? void 0 : activeProps.activeIndex)
                ? listenerApi.dispatch(
                    (0, _tooltipSlice__WEBPACK_IMPORTED_MODULE_1__.Nt)({
                      activeIndex: activeProps.activeIndex,
                      activeDataKey: void 0,
                      activeCoordinate: activeProps.activeCoordinate,
                    })
                  )
                : listenerApi.dispatch((0, _tooltipSlice__WEBPACK_IMPORTED_MODULE_1__.xS)());
            }
            rafId = null;
          });
        },
      });
    },
    './node_modules/recharts/es6/state/optionsSlice.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        dl: () => createEventEmitter,
        lJ: () => optionsReducer,
        uN: () => arrayTooltipSearcher,
      });
      var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        _util_DataUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        );
      function arrayTooltipSearcher(data, strIndex) {
        if (strIndex) {
          var numIndex = Number.parseInt(strIndex, 10);
          if (!(0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_1__.M8)(numIndex))
            return null == data ? void 0 : data[numIndex];
        }
      }
      var initialState = {
          chartName: '',
          tooltipPayloadSearcher: void 0,
          eventEmitter: void 0,
          defaultTooltipEventType: 'axis',
        },
        optionsSlice = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Z0)({
          name: 'options',
          initialState,
          reducers: {
            createEventEmitter: (state) => {
              null == state.eventEmitter && (state.eventEmitter = Symbol('rechartsEventEmitter'));
            },
          },
        }),
        optionsReducer = optionsSlice.reducer,
        { createEventEmitter } = optionsSlice.actions;
    },
    './node_modules/recharts/es6/state/polarOptionsSlice.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        J: () => polarOptionsReducer,
        U: () => updatePolarOptions,
      });
      var polarOptionsSlice = (0,
        __webpack_require__('./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs').Z0)({
          name: 'polarOptions',
          initialState: null,
          reducers: { updatePolarOptions: (_state, action) => action.payload },
        }),
        { updatePolarOptions } = polarOptionsSlice.actions,
        polarOptionsReducer = polarOptionsSlice.reducer;
    },
    './node_modules/recharts/es6/state/rootPropsSlice.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        mZ: () => updateOptions,
        vE: () => rootPropsReducer,
      });
      var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        initialState = {
          accessibilityLayer: !0,
          barCategoryGap: '10%',
          barGap: 4,
          barSize: void 0,
          className: void 0,
          maxBarSize: void 0,
          stackOffset: 'none',
          syncId: void 0,
          syncMethod: 'index',
          baseValue: void 0,
          reverseStackOrder: !1,
        },
        rootPropsSlice = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Z0)({
          name: 'rootProps',
          initialState,
          reducers: {
            updateOptions: (state, action) => {
              var _action$payload$barGa;
              ((state.accessibilityLayer = action.payload.accessibilityLayer),
                (state.barCategoryGap = action.payload.barCategoryGap),
                (state.barGap =
                  null !== (_action$payload$barGa = action.payload.barGap) &&
                  void 0 !== _action$payload$barGa
                    ? _action$payload$barGa
                    : initialState.barGap),
                (state.barSize = action.payload.barSize),
                (state.maxBarSize = action.payload.maxBarSize),
                (state.stackOffset = action.payload.stackOffset),
                (state.syncId = action.payload.syncId),
                (state.syncMethod = action.payload.syncMethod),
                (state.className = action.payload.className),
                (state.baseValue = action.payload.baseValue),
                (state.reverseStackOrder = action.payload.reverseStackOrder));
            },
          },
        }),
        rootPropsReducer = rootPropsSlice.reducer,
        { updateOptions } = rootPropsSlice.actions;
    },
    './node_modules/recharts/es6/state/selectors/arrayEqualityCheck.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      function emptyArraysAreEqualCheck(a, b) {
        return (
          !(!Array.isArray(a) || !Array.isArray(b) || 0 !== a.length || 0 !== b.length) || a === b
        );
      }
      function arrayContentsAreEqualCheck(a, b) {
        if (a.length === b.length) {
          for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
          return !0;
        }
        return !1;
      }
      __webpack_require__.d(__webpack_exports__, {
        O: () => emptyArraysAreEqualCheck,
        W: () => arrayContentsAreEqualCheck,
      });
    },
    './node_modules/recharts/es6/state/selectors/axisSelectors.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        fb: () => combineAppliedValues,
        q: () => combineAreasDomain,
        tP: () => combineAxisDomain,
        g1: () => combineAxisDomainWithNiceTicks,
        iv: () => combineCategoricalDomain,
        Nk: () => combineDisplayedData,
        EZ: () => combineDomainOfAllAppliedNumericalValuesIncludingErrorValues,
        pM: () => combineDomainOfStackGroups,
        Oz: () => combineDotsDomain,
        tF: () => combineDuplicateDomain,
        rj: () => combineGraphicalItemsData,
        ec: () => combineGraphicalItemsSettings,
        bb: () => combineLinesDomain,
        xp: () => combineNiceTicks,
        wL: () => combineNumericalDomain,
        sr: () => combineRealScaleType,
        Qn: () => combineScaleFunction,
        MK: () => combineStackGroups,
        IO: () => filterGraphicalNotStackedItems,
        P9: () => filterReferenceElements,
        S5: () => getDomainDefinition,
        PU: () => implicitXAxis,
        cd: () => implicitYAxis,
        eo: () => itemAxisPredicate,
        yi: () => mergeDomains,
        CH: () => selectAllErrorBarSettings,
        D5: () => selectAxisRange,
        Gx: () => selectAxisWithScale,
        DP: () => selectBaseAxis,
        BQ: () => selectCartesianAxisSize,
        _y: () => selectChartDirection,
        AV: () => selectDomainDefinition,
        Lu: () => selectDomainFromUserPreference,
        um: () => selectHasBar,
        xM: () => selectRealScaleType,
        gT: () => selectReferenceAreas,
        Kr: () => selectReferenceDots,
        $X: () => selectReferenceLines,
        TC: () => selectStackGroups,
        Zi: () => selectTicksOfAxis,
        CR: () => selectTicksOfGraphicalItem,
        Dn: () => selectTooltipAxis,
        K6: () => selectTooltipAxisDataKey,
        ld: () => selectUnfilteredCartesianItems,
        L$: () => selectXAxisPosition,
        Rl: () => selectXAxisSettings,
        y7: () => selectXAxisSettingsNoDefaults,
        Lw: () => selectXAxisSize,
        KR: () => selectYAxisPosition,
        sf: () => selectYAxisSettings,
        hc: () => selectYAxisSettingsNoDefaults,
        wP: () => selectYAxisSize,
      });
      var d3_scale_namespaceObject = {};
      (__webpack_require__.r(d3_scale_namespaceObject),
        __webpack_require__.d(d3_scale_namespaceObject, {
          scaleBand: () => band,
          scaleDiverging: () => diverging,
          scaleDivergingLog: () => divergingLog,
          scaleDivergingPow: () => divergingPow,
          scaleDivergingSqrt: () => divergingSqrt,
          scaleDivergingSymlog: () => divergingSymlog,
          scaleIdentity: () => identity_identity,
          scaleImplicit: () => implicit,
          scaleLinear: () => linear_linear,
          scaleLog: () => log,
          scaleOrdinal: () => ordinal,
          scalePoint: () => point,
          scalePow: () => pow,
          scaleQuantile: () => quantile_quantile,
          scaleQuantize: () => quantize,
          scaleRadial: () => radial,
          scaleSequential: () => sequential,
          scaleSequentialLog: () => sequentialLog,
          scaleSequentialPow: () => sequentialPow,
          scaleSequentialQuantile: () => sequentialQuantile,
          scaleSequentialSqrt: () => sequentialSqrt,
          scaleSequentialSymlog: () => sequentialSymlog,
          scaleSqrt: () => sqrt,
          scaleSymlog: () => symlog,
          scaleThreshold: () => threshold,
          scaleTime: () => time,
          scaleUtc: () => utcTime,
          tickFormat: () => tickFormat,
        }));
      var reselect = __webpack_require__('./node_modules/reselect/dist/reselect.mjs'),
        range = __webpack_require__('./node_modules/es-toolkit/compat/range.js'),
        range_default = __webpack_require__.n(range);
      function initRange(domain, range) {
        switch (arguments.length) {
          case 0:
            break;
          case 1:
            this.range(domain);
            break;
          default:
            this.range(range).domain(domain);
        }
        return this;
      }
      function initInterpolator(domain, interpolator) {
        switch (arguments.length) {
          case 0:
            break;
          case 1:
            'function' == typeof domain ? this.interpolator(domain) : this.range(domain);
            break;
          default:
            (this.domain(domain),
              'function' == typeof interpolator
                ? this.interpolator(interpolator)
                : this.range(interpolator));
        }
        return this;
      }
      class InternMap extends Map {
        constructor(entries, key = keyof) {
          if (
            (super(),
            Object.defineProperties(this, { _intern: { value: new Map() }, _key: { value: key } }),
            null != entries)
          )
            for (const [key, value] of entries) this.set(key, value);
        }
        get(key) {
          return super.get(intern_get(this, key));
        }
        has(key) {
          return super.has(intern_get(this, key));
        }
        set(key, value) {
          return super.set(intern_set(this, key), value);
        }
        delete(key) {
          return super.delete(intern_delete(this, key));
        }
      }
      Set;
      function intern_get({ _intern, _key }, value) {
        const key = _key(value);
        return _intern.has(key) ? _intern.get(key) : value;
      }
      function intern_set({ _intern, _key }, value) {
        const key = _key(value);
        return _intern.has(key) ? _intern.get(key) : (_intern.set(key, value), value);
      }
      function intern_delete({ _intern, _key }, value) {
        const key = _key(value);
        return (_intern.has(key) && ((value = _intern.get(key)), _intern.delete(key)), value);
      }
      function keyof(value) {
        return null !== value && 'object' == typeof value ? value.valueOf() : value;
      }
      const implicit = Symbol('implicit');
      function ordinal() {
        var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;
        function scale(d) {
          let i = index.get(d);
          if (void 0 === i) {
            if (unknown !== implicit) return unknown;
            index.set(d, (i = domain.push(d) - 1));
          }
          return range[i % range.length];
        }
        return (
          (scale.domain = function (_) {
            if (!arguments.length) return domain.slice();
            ((domain = []), (index = new InternMap()));
            for (const value of _) index.has(value) || index.set(value, domain.push(value) - 1);
            return scale;
          }),
          (scale.range = function (_) {
            return arguments.length ? ((range = Array.from(_)), scale) : range.slice();
          }),
          (scale.unknown = function (_) {
            return arguments.length ? ((unknown = _), scale) : unknown;
          }),
          (scale.copy = function () {
            return ordinal(domain, range).unknown(unknown);
          }),
          initRange.apply(scale, arguments),
          scale
        );
      }
      function band() {
        var step,
          bandwidth,
          scale = ordinal().unknown(void 0),
          domain = scale.domain,
          ordinalRange = scale.range,
          r0 = 0,
          r1 = 1,
          round = !1,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;
        function rescale() {
          var n = domain().length,
            reverse = r1 < r0,
            start = reverse ? r1 : r0,
            stop = reverse ? r0 : r1;
          ((step = (stop - start) / Math.max(1, n - paddingInner + 2 * paddingOuter)),
            round && (step = Math.floor(step)),
            (start += (stop - start - step * (n - paddingInner)) * align),
            (bandwidth = step * (1 - paddingInner)),
            round && ((start = Math.round(start)), (bandwidth = Math.round(bandwidth))));
          var values = (function range_range(start, stop, step) {
            ((start = +start),
              (stop = +stop),
              (step =
                (n = arguments.length) < 2 ? ((stop = start), (start = 0), 1) : n < 3 ? 1 : +step));
            for (
              var i = -1,
                n = 0 | Math.max(0, Math.ceil((stop - start) / step)),
                range = new Array(n);
              ++i < n;
            )
              range[i] = start + i * step;
            return range;
          })(n).map(function (i) {
            return start + step * i;
          });
          return ordinalRange(reverse ? values.reverse() : values);
        }
        return (
          delete scale.unknown,
          (scale.domain = function (_) {
            return arguments.length ? (domain(_), rescale()) : domain();
          }),
          (scale.range = function (_) {
            return arguments.length
              ? (([r0, r1] = _), (r0 = +r0), (r1 = +r1), rescale())
              : [r0, r1];
          }),
          (scale.rangeRound = function (_) {
            return (([r0, r1] = _), (r0 = +r0), (r1 = +r1), (round = !0), rescale());
          }),
          (scale.bandwidth = function () {
            return bandwidth;
          }),
          (scale.step = function () {
            return step;
          }),
          (scale.round = function (_) {
            return arguments.length ? ((round = !!_), rescale()) : round;
          }),
          (scale.padding = function (_) {
            return arguments.length
              ? ((paddingInner = Math.min(1, (paddingOuter = +_))), rescale())
              : paddingInner;
          }),
          (scale.paddingInner = function (_) {
            return arguments.length ? ((paddingInner = Math.min(1, _)), rescale()) : paddingInner;
          }),
          (scale.paddingOuter = function (_) {
            return arguments.length ? ((paddingOuter = +_), rescale()) : paddingOuter;
          }),
          (scale.align = function (_) {
            return arguments.length ? ((align = Math.max(0, Math.min(1, _))), rescale()) : align;
          }),
          (scale.copy = function () {
            return band(domain(), [r0, r1])
              .round(round)
              .paddingInner(paddingInner)
              .paddingOuter(paddingOuter)
              .align(align);
          }),
          initRange.apply(rescale(), arguments)
        );
      }
      function pointish(scale) {
        var copy = scale.copy;
        return (
          (scale.padding = scale.paddingOuter),
          delete scale.paddingInner,
          delete scale.paddingOuter,
          (scale.copy = function () {
            return pointish(copy());
          }),
          scale
        );
      }
      function point() {
        return pointish(band.apply(null, arguments).paddingInner(1));
      }
      const e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);
      function tickSpec(start, stop, count) {
        const step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log10(step)),
          error = step / Math.pow(10, power),
          factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
        let i1, i2, inc;
        return (
          power < 0
            ? ((inc = Math.pow(10, -power) / factor),
              (i1 = Math.round(start * inc)),
              (i2 = Math.round(stop * inc)),
              i1 / inc < start && ++i1,
              i2 / inc > stop && --i2,
              (inc = -inc))
            : ((inc = Math.pow(10, power) * factor),
              (i1 = Math.round(start / inc)),
              (i2 = Math.round(stop / inc)),
              i1 * inc < start && ++i1,
              i2 * inc > stop && --i2),
          i2 < i1 && 0.5 <= count && count < 2 ? tickSpec(start, stop, 2 * count) : [i1, i2, inc]
        );
      }
      function ticks(start, stop, count) {
        if (!((count = +count) > 0)) return [];
        if ((start = +start) === (stop = +stop)) return [start];
        const reverse = stop < start,
          [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
        if (!(i2 >= i1)) return [];
        const n = i2 - i1 + 1,
          ticks = new Array(n);
        if (reverse)
          if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
          else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
        else if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
        else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
        return ticks;
      }
      function tickIncrement(start, stop, count) {
        return tickSpec((start = +start), (stop = +stop), (count = +count))[2];
      }
      function tickStep(start, stop, count) {
        count = +count;
        const reverse = (stop = +stop) < (start = +start),
          inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
        return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
      }
      function ascending(a, b) {
        return null == a || null == b ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      function descending(a, b) {
        return null == a || null == b ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      }
      function bisector(f) {
        let compare1, compare2, delta;
        function left(a, x, lo = 0, hi = a.length) {
          if (lo < hi) {
            if (0 !== compare1(x, x)) return hi;
            do {
              const mid = (lo + hi) >>> 1;
              compare2(a[mid], x) < 0 ? (lo = mid + 1) : (hi = mid);
            } while (lo < hi);
          }
          return lo;
        }
        return (
          2 !== f.length
            ? ((compare1 = ascending),
              (compare2 = (d, x) => ascending(f(d), x)),
              (delta = (d, x) => f(d) - x))
            : ((compare1 = f === ascending || f === descending ? f : zero),
              (compare2 = f),
              (delta = f)),
          {
            left,
            center: function center(a, x, lo = 0, hi = a.length) {
              const i = left(a, x, lo, hi - 1);
              return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
            },
            right: function right(a, x, lo = 0, hi = a.length) {
              if (lo < hi) {
                if (0 !== compare1(x, x)) return hi;
                do {
                  const mid = (lo + hi) >>> 1;
                  compare2(a[mid], x) <= 0 ? (lo = mid + 1) : (hi = mid);
                } while (lo < hi);
              }
              return lo;
            },
          }
        );
      }
      function zero() {
        return 0;
      }
      function number_number(x) {
        return null === x ? NaN : +x;
      }
      const ascendingBisect = bisector(ascending),
        bisectRight = ascendingBisect.right,
        bisect = (ascendingBisect.left, bisector(number_number).center, bisectRight);
      function src_define(constructor, factory, prototype) {
        ((constructor.prototype = factory.prototype = prototype),
          (prototype.constructor = constructor));
      }
      function extend(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition) prototype[key] = definition[key];
        return prototype;
      }
      function Color() {}
      var brighter = 1 / 0.7,
        reI = '\\s*([+-]?\\d+)\\s*',
        reN = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*',
        reP = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*',
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
        reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
        reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
        reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
        reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
        reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`),
        named = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        };
      function color_formatHex() {
        return this.rgb().formatHex();
      }
      function color_formatRgb() {
        return this.rgb().formatRgb();
      }
      function color(format) {
        var m, l;
        return (
          (format = (format + '').trim().toLowerCase()),
          (m = reHex.exec(format))
            ? ((l = m[1].length),
              (m = parseInt(m[1], 16)),
              6 === l
                ? rgbn(m)
                : 3 === l
                  ? new Rgb(
                      ((m >> 8) & 15) | ((m >> 4) & 240),
                      ((m >> 4) & 15) | (240 & m),
                      ((15 & m) << 4) | (15 & m),
                      1
                    )
                  : 8 === l
                    ? rgba((m >> 24) & 255, (m >> 16) & 255, (m >> 8) & 255, (255 & m) / 255)
                    : 4 === l
                      ? rgba(
                          ((m >> 12) & 15) | ((m >> 8) & 240),
                          ((m >> 8) & 15) | ((m >> 4) & 240),
                          ((m >> 4) & 15) | (240 & m),
                          (((15 & m) << 4) | (15 & m)) / 255
                        )
                      : null)
            : (m = reRgbInteger.exec(format))
              ? new Rgb(m[1], m[2], m[3], 1)
              : (m = reRgbPercent.exec(format))
                ? new Rgb((255 * m[1]) / 100, (255 * m[2]) / 100, (255 * m[3]) / 100, 1)
                : (m = reRgbaInteger.exec(format))
                  ? rgba(m[1], m[2], m[3], m[4])
                  : (m = reRgbaPercent.exec(format))
                    ? rgba((255 * m[1]) / 100, (255 * m[2]) / 100, (255 * m[3]) / 100, m[4])
                    : (m = reHslPercent.exec(format))
                      ? hsla(m[1], m[2] / 100, m[3] / 100, 1)
                      : (m = reHslaPercent.exec(format))
                        ? hsla(m[1], m[2] / 100, m[3] / 100, m[4])
                        : named.hasOwnProperty(format)
                          ? rgbn(named[format])
                          : 'transparent' === format
                            ? new Rgb(NaN, NaN, NaN, 0)
                            : null
        );
      }
      function rgbn(n) {
        return new Rgb((n >> 16) & 255, (n >> 8) & 255, 255 & n, 1);
      }
      function rgba(r, g, b, a) {
        return (a <= 0 && (r = g = b = NaN), new Rgb(r, g, b, a));
      }
      function color_rgb(r, g, b, opacity) {
        return 1 === arguments.length
          ? (function rgbConvert(o) {
              return (
                o instanceof Color || (o = color(o)),
                o ? new Rgb((o = o.rgb()).r, o.g, o.b, o.opacity) : new Rgb()
              );
            })(r)
          : new Rgb(r, g, b, null == opacity ? 1 : opacity);
      }
      function Rgb(r, g, b, opacity) {
        ((this.r = +r), (this.g = +g), (this.b = +b), (this.opacity = +opacity));
      }
      function rgb_formatHex() {
        return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
      }
      function rgb_formatRgb() {
        const a = clampa(this.opacity);
        return `${1 === a ? 'rgb(' : 'rgba('}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${1 === a ? ')' : `, ${a})`}`;
      }
      function clampa(opacity) {
        return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
      }
      function clampi(value) {
        return Math.max(0, Math.min(255, Math.round(value) || 0));
      }
      function hex(value) {
        return ((value = clampi(value)) < 16 ? '0' : '') + value.toString(16);
      }
      function hsla(h, s, l, a) {
        return (
          a <= 0 ? (h = s = l = NaN) : l <= 0 || l >= 1 ? (h = s = NaN) : s <= 0 && (h = NaN),
          new Hsl(h, s, l, a)
        );
      }
      function hslConvert(o) {
        if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
        if ((o instanceof Color || (o = color(o)), !o)) return new Hsl();
        if (o instanceof Hsl) return o;
        var r = (o = o.rgb()).r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
        return (
          s
            ? ((h =
                r === max
                  ? (g - b) / s + 6 * (g < b)
                  : g === max
                    ? (b - r) / s + 2
                    : (r - g) / s + 4),
              (s /= l < 0.5 ? max + min : 2 - max - min),
              (h *= 60))
            : (s = l > 0 && l < 1 ? 0 : h),
          new Hsl(h, s, l, o.opacity)
        );
      }
      function Hsl(h, s, l, opacity) {
        ((this.h = +h), (this.s = +s), (this.l = +l), (this.opacity = +opacity));
      }
      function clamph(value) {
        return (value = (value || 0) % 360) < 0 ? value + 360 : value;
      }
      function clampt(value) {
        return Math.max(0, Math.min(1, value || 0));
      }
      function hsl2rgb(h, m1, m2) {
        return (
          255 *
          (h < 60
            ? m1 + ((m2 - m1) * h) / 60
            : h < 180
              ? m2
              : h < 240
                ? m1 + ((m2 - m1) * (240 - h)) / 60
                : m1)
        );
      }
      function basis(t1, v0, v1, v2, v3) {
        var t2 = t1 * t1,
          t3 = t2 * t1;
        return (
          ((1 - 3 * t1 + 3 * t2 - t3) * v0 +
            (4 - 6 * t2 + 3 * t3) * v1 +
            (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 +
            t3 * v3) /
          6
        );
      }
      (src_define(Color, color, {
        copy(channels) {
          return Object.assign(new this.constructor(), this, channels);
        },
        displayable() {
          return this.rgb().displayable();
        },
        hex: color_formatHex,
        formatHex: color_formatHex,
        formatHex8: function color_formatHex8() {
          return this.rgb().formatHex8();
        },
        formatHsl: function color_formatHsl() {
          return hslConvert(this).formatHsl();
        },
        formatRgb: color_formatRgb,
        toString: color_formatRgb,
      }),
        src_define(
          Rgb,
          color_rgb,
          extend(Color, {
            brighter(k) {
              return (
                (k = null == k ? brighter : Math.pow(brighter, k)),
                new Rgb(this.r * k, this.g * k, this.b * k, this.opacity)
              );
            },
            darker(k) {
              return (
                (k = null == k ? 0.7 : Math.pow(0.7, k)),
                new Rgb(this.r * k, this.g * k, this.b * k, this.opacity)
              );
            },
            rgb() {
              return this;
            },
            clamp() {
              return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
            },
            displayable() {
              return (
                -0.5 <= this.r &&
                this.r < 255.5 &&
                -0.5 <= this.g &&
                this.g < 255.5 &&
                -0.5 <= this.b &&
                this.b < 255.5 &&
                0 <= this.opacity &&
                this.opacity <= 1
              );
            },
            hex: rgb_formatHex,
            formatHex: rgb_formatHex,
            formatHex8: function rgb_formatHex8() {
              return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex(255 * (isNaN(this.opacity) ? 1 : this.opacity))}`;
            },
            formatRgb: rgb_formatRgb,
            toString: rgb_formatRgb,
          })
        ),
        src_define(
          Hsl,
          function hsl(h, s, l, opacity) {
            return 1 === arguments.length
              ? hslConvert(h)
              : new Hsl(h, s, l, null == opacity ? 1 : opacity);
          },
          extend(Color, {
            brighter(k) {
              return (
                (k = null == k ? brighter : Math.pow(brighter, k)),
                new Hsl(this.h, this.s, this.l * k, this.opacity)
              );
            },
            darker(k) {
              return (
                (k = null == k ? 0.7 : Math.pow(0.7, k)),
                new Hsl(this.h, this.s, this.l * k, this.opacity)
              );
            },
            rgb() {
              var h = (this.h % 360) + 360 * (this.h < 0),
                s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
                l = this.l,
                m2 = l + (l < 0.5 ? l : 1 - l) * s,
                m1 = 2 * l - m2;
              return new Rgb(
                hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
                hsl2rgb(h, m1, m2),
                hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
                this.opacity
              );
            },
            clamp() {
              return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
            },
            displayable() {
              return (
                ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
                0 <= this.l &&
                this.l <= 1 &&
                0 <= this.opacity &&
                this.opacity <= 1
              );
            },
            formatHsl() {
              const a = clampa(this.opacity);
              return `${1 === a ? 'hsl(' : 'hsla('}${clamph(this.h)}, ${100 * clampt(this.s)}%, ${100 * clampt(this.l)}%${1 === a ? ')' : `, ${a})`}`;
            },
          })
        ));
      const src_constant = (x) => () => x;
      function linear(a, d) {
        return function (t) {
          return a + t * d;
        };
      }
      function gamma(y) {
        return 1 === (y = +y)
          ? nogamma
          : function (a, b) {
              return b - a
                ? (function exponential(a, b, y) {
                    return (
                      (a = Math.pow(a, y)),
                      (b = Math.pow(b, y) - a),
                      (y = 1 / y),
                      function (t) {
                        return Math.pow(a + t * b, y);
                      }
                    );
                  })(a, b, y)
                : src_constant(isNaN(a) ? b : a);
            };
      }
      function nogamma(a, b) {
        var d = b - a;
        return d ? linear(a, d) : src_constant(isNaN(a) ? b : a);
      }
      const rgb = (function rgbGamma(y) {
        var color = gamma(y);
        function rgb(start, end) {
          var r = color((start = color_rgb(start)).r, (end = color_rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
          return function (t) {
            return (
              (start.r = r(t)),
              (start.g = g(t)),
              (start.b = b(t)),
              (start.opacity = opacity(t)),
              start + ''
            );
          };
        }
        return ((rgb.gamma = rgbGamma), rgb);
      })(1);
      function rgbSpline(spline) {
        return function (colors) {
          var i,
            color,
            n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n);
          for (i = 0; i < n; ++i)
            ((color = color_rgb(colors[i])),
              (r[i] = color.r || 0),
              (g[i] = color.g || 0),
              (b[i] = color.b || 0));
          return (
            (r = spline(r)),
            (g = spline(g)),
            (b = spline(b)),
            (color.opacity = 1),
            function (t) {
              return ((color.r = r(t)), (color.g = g(t)), (color.b = b(t)), color + '');
            }
          );
        };
      }
      (rgbSpline(function src_basis(values) {
        var n = values.length - 1;
        return function (t) {
          var i = t <= 0 ? (t = 0) : t >= 1 ? ((t = 1), n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
          return basis((t - i / n) * n, v0, v1, v2, v3);
        };
      }),
        rgbSpline(function basisClosed(values) {
          var n = values.length;
          return function (t) {
            var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
              v0 = values[(i + n - 1) % n],
              v1 = values[i % n],
              v2 = values[(i + 1) % n],
              v3 = values[(i + 2) % n];
            return basis((t - i / n) * n, v0, v1, v2, v3);
          };
        }));
      function genericArray(a, b) {
        var i,
          nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb);
        for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
        for (; i < nb; ++i) c[i] = b[i];
        return function (t) {
          for (i = 0; i < na; ++i) c[i] = x[i](t);
          return c;
        };
      }
      function date(a, b) {
        var d = new Date();
        return (
          (a = +a),
          (b = +b),
          function (t) {
            return (d.setTime(a * (1 - t) + b * t), d);
          }
        );
      }
      function src_number(a, b) {
        return (
          (a = +a),
          (b = +b),
          function (t) {
            return a * (1 - t) + b * t;
          }
        );
      }
      function object(a, b) {
        var k,
          i = {},
          c = {};
        for (k in ((null !== a && 'object' == typeof a) || (a = {}),
        (null !== b && 'object' == typeof b) || (b = {}),
        b))
          k in a ? (i[k] = value(a[k], b[k])) : (c[k] = b[k]);
        return function (t) {
          for (k in i) c[k] = i[k](t);
          return c;
        };
      }
      var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, 'g');
      function string(a, b) {
        var am,
          bm,
          bs,
          bi = (reA.lastIndex = reB.lastIndex = 0),
          i = -1,
          s = [],
          q = [];
        for (a += '', b += ''; (am = reA.exec(a)) && (bm = reB.exec(b)); )
          ((bs = bm.index) > bi && ((bs = b.slice(bi, bs)), s[i] ? (s[i] += bs) : (s[++i] = bs)),
            (am = am[0]) === (bm = bm[0])
              ? s[i]
                ? (s[i] += bm)
                : (s[++i] = bm)
              : ((s[++i] = null), q.push({ i, x: src_number(am, bm) })),
            (bi = reB.lastIndex));
        return (
          bi < b.length && ((bs = b.slice(bi)), s[i] ? (s[i] += bs) : (s[++i] = bs)),
          s.length < 2
            ? q[0]
              ? (function one(b) {
                  return function (t) {
                    return b(t) + '';
                  };
                })(q[0].x)
              : (function string_zero(b) {
                  return function () {
                    return b;
                  };
                })(b)
            : ((b = q.length),
              function (t) {
                for (var o, i = 0; i < b; ++i) s[(o = q[i]).i] = o.x(t);
                return s.join('');
              })
        );
      }
      function src_numberArray(a, b) {
        b || (b = []);
        var i,
          n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice();
        return function (t) {
          for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
          return c;
        };
      }
      function value(a, b) {
        var c,
          t = typeof b;
        return null == b || 'boolean' === t
          ? src_constant(b)
          : ('number' === t
              ? src_number
              : 'string' === t
                ? (c = color(b))
                  ? ((b = c), rgb)
                  : string
                : b instanceof color
                  ? rgb
                  : b instanceof Date
                    ? date
                    : (function numberArray_isNumberArray(x) {
                          return ArrayBuffer.isView(x) && !(x instanceof DataView);
                        })(b)
                      ? src_numberArray
                      : Array.isArray(b)
                        ? genericArray
                        : ('function' != typeof b.valueOf && 'function' != typeof b.toString) ||
                            isNaN(b)
                          ? object
                          : src_number)(a, b);
      }
      function round(a, b) {
        return (
          (a = +a),
          (b = +b),
          function (t) {
            return Math.round(a * (1 - t) + b * t);
          }
        );
      }
      function src_number_number(x) {
        return +x;
      }
      var unit = [0, 1];
      function identity(x) {
        return x;
      }
      function normalize(a, b) {
        return (b -= a = +a)
          ? function (x) {
              return (x - a) / b;
            }
          : (function constants(x) {
              return function () {
                return x;
              };
            })(isNaN(b) ? NaN : 0.5);
      }
      function bimap(domain, range, interpolate) {
        var d0 = domain[0],
          d1 = domain[1],
          r0 = range[0],
          r1 = range[1];
        return (
          d1 < d0
            ? ((d0 = normalize(d1, d0)), (r0 = interpolate(r1, r0)))
            : ((d0 = normalize(d0, d1)), (r0 = interpolate(r0, r1))),
          function (x) {
            return r0(d0(x));
          }
        );
      }
      function polymap(domain, range, interpolate) {
        var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;
        for (
          domain[j] < domain[0] &&
          ((domain = domain.slice().reverse()), (range = range.slice().reverse()));
          ++i < j;
        )
          ((d[i] = normalize(domain[i], domain[i + 1])),
            (r[i] = interpolate(range[i], range[i + 1])));
        return function (x) {
          var i = bisect(domain, x, 1, j) - 1;
          return r[i](d[i](x));
        };
      }
      function copy(source, target) {
        return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
      }
      function transformer() {
        var transform,
          untransform,
          unknown,
          piecewise,
          output,
          input,
          domain = unit,
          range = unit,
          interpolate = value,
          clamp = identity;
        function rescale() {
          var n = Math.min(domain.length, range.length);
          return (
            clamp !== identity &&
              (clamp = (function clamper(a, b) {
                var t;
                return (
                  a > b && ((t = a), (a = b), (b = t)),
                  function (x) {
                    return Math.max(a, Math.min(b, x));
                  }
                );
              })(domain[0], domain[n - 1])),
            (piecewise = n > 2 ? polymap : bimap),
            (output = input = null),
            scale
          );
        }
        function scale(x) {
          return null == x || isNaN((x = +x))
            ? unknown
            : (output || (output = piecewise(domain.map(transform), range, interpolate)))(
                transform(clamp(x))
              );
        }
        return (
          (scale.invert = function (y) {
            return clamp(
              untransform(
                (input || (input = piecewise(range, domain.map(transform), src_number)))(y)
              )
            );
          }),
          (scale.domain = function (_) {
            return arguments.length
              ? ((domain = Array.from(_, src_number_number)), rescale())
              : domain.slice();
          }),
          (scale.range = function (_) {
            return arguments.length ? ((range = Array.from(_)), rescale()) : range.slice();
          }),
          (scale.rangeRound = function (_) {
            return ((range = Array.from(_)), (interpolate = round), rescale());
          }),
          (scale.clamp = function (_) {
            return arguments.length ? ((clamp = !!_ || identity), rescale()) : clamp !== identity;
          }),
          (scale.interpolate = function (_) {
            return arguments.length ? ((interpolate = _), rescale()) : interpolate;
          }),
          (scale.unknown = function (_) {
            return arguments.length ? ((unknown = _), scale) : unknown;
          }),
          function (t, u) {
            return ((transform = t), (untransform = u), rescale());
          }
        );
      }
      function continuous() {
        return transformer()(identity, identity);
      }
      var prefixExponent,
        re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
      function formatSpecifier(specifier) {
        if (!(match = re.exec(specifier))) throw new Error('invalid format: ' + specifier);
        var match;
        return new FormatSpecifier({
          fill: match[1],
          align: match[2],
          sign: match[3],
          symbol: match[4],
          zero: match[5],
          width: match[6],
          comma: match[7],
          precision: match[8] && match[8].slice(1),
          trim: match[9],
          type: match[10],
        });
      }
      function FormatSpecifier(specifier) {
        ((this.fill = void 0 === specifier.fill ? ' ' : specifier.fill + ''),
          (this.align = void 0 === specifier.align ? '>' : specifier.align + ''),
          (this.sign = void 0 === specifier.sign ? '-' : specifier.sign + ''),
          (this.symbol = void 0 === specifier.symbol ? '' : specifier.symbol + ''),
          (this.zero = !!specifier.zero),
          (this.width = void 0 === specifier.width ? void 0 : +specifier.width),
          (this.comma = !!specifier.comma),
          (this.precision = void 0 === specifier.precision ? void 0 : +specifier.precision),
          (this.trim = !!specifier.trim),
          (this.type = void 0 === specifier.type ? '' : specifier.type + ''));
      }
      function formatDecimalParts(x, p) {
        if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf('e')) < 0)
          return null;
        var i,
          coefficient = x.slice(0, i);
        return [
          coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
          +x.slice(i + 1),
        ];
      }
      function exponent(x) {
        return (x = formatDecimalParts(Math.abs(x))) ? x[1] : NaN;
      }
      function formatRounded(x, p) {
        var d = formatDecimalParts(x, p);
        if (!d) return x + '';
        var coefficient = d[0],
          exponent = d[1];
        return exponent < 0
          ? '0.' + new Array(-exponent).join('0') + coefficient
          : coefficient.length > exponent + 1
            ? coefficient.slice(0, exponent + 1) + '.' + coefficient.slice(exponent + 1)
            : coefficient + new Array(exponent - coefficient.length + 2).join('0');
      }
      ((formatSpecifier.prototype = FormatSpecifier.prototype),
        (FormatSpecifier.prototype.toString = function () {
          return (
            this.fill +
            this.align +
            this.sign +
            this.symbol +
            (this.zero ? '0' : '') +
            (void 0 === this.width ? '' : Math.max(1, 0 | this.width)) +
            (this.comma ? ',' : '') +
            (void 0 === this.precision ? '' : '.' + Math.max(0, 0 | this.precision)) +
            (this.trim ? '~' : '') +
            this.type
          );
        }));
      const formatTypes = {
        '%': (x, p) => (100 * x).toFixed(p),
        b: (x) => Math.round(x).toString(2),
        c: (x) => x + '',
        d: function formatDecimal(x) {
          return Math.abs((x = Math.round(x))) >= 1e21
            ? x.toLocaleString('en').replace(/,/g, '')
            : x.toString(10);
        },
        e: (x, p) => x.toExponential(p),
        f: (x, p) => x.toFixed(p),
        g: (x, p) => x.toPrecision(p),
        o: (x) => Math.round(x).toString(8),
        p: (x, p) => formatRounded(100 * x, p),
        r: formatRounded,
        s: function formatPrefixAuto(x, p) {
          var d = formatDecimalParts(x, p);
          if (!d) return x + '';
          var coefficient = d[0],
            exponent = d[1],
            i =
              exponent -
              (prefixExponent = 3 * Math.max(-8, Math.min(8, Math.floor(exponent / 3)))) +
              1,
            n = coefficient.length;
          return i === n
            ? coefficient
            : i > n
              ? coefficient + new Array(i - n + 1).join('0')
              : i > 0
                ? coefficient.slice(0, i) + '.' + coefficient.slice(i)
                : '0.' +
                  new Array(1 - i).join('0') +
                  formatDecimalParts(x, Math.max(0, p + i - 1))[0];
        },
        X: (x) => Math.round(x).toString(16).toUpperCase(),
        x: (x) => Math.round(x).toString(16),
      };
      function src_identity(x) {
        return x;
      }
      var defaultLocale_locale,
        format,
        formatPrefix,
        map = Array.prototype.map,
        prefixes = [
          'y',
          'z',
          'a',
          'f',
          'p',
          'n',
          '',
          'm',
          '',
          'k',
          'M',
          'G',
          'T',
          'P',
          'E',
          'Z',
          'Y',
        ];
      function locale(locale) {
        var group =
            void 0 === locale.grouping || void 0 === locale.thousands
              ? src_identity
              : (function formatGroup(grouping, thousands) {
                  return function (value, width) {
                    for (
                      var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
                      i > 0 &&
                      g > 0 &&
                      (length + g + 1 > width && (g = Math.max(1, width - length)),
                      t.push(value.substring((i -= g), i + g)),
                      !((length += g + 1) > width));
                    )
                      g = grouping[(j = (j + 1) % grouping.length)];
                    return t.reverse().join(thousands);
                  };
                })(map.call(locale.grouping, Number), locale.thousands + ''),
          currencyPrefix = void 0 === locale.currency ? '' : locale.currency[0] + '',
          currencySuffix = void 0 === locale.currency ? '' : locale.currency[1] + '',
          decimal = void 0 === locale.decimal ? '.' : locale.decimal + '',
          numerals =
            void 0 === locale.numerals
              ? src_identity
              : (function formatNumerals(numerals) {
                  return function (value) {
                    return value.replace(/[0-9]/g, function (i) {
                      return numerals[+i];
                    });
                  };
                })(map.call(locale.numerals, String)),
          percent = void 0 === locale.percent ? '%' : locale.percent + '',
          minus = void 0 === locale.minus ? '' : locale.minus + '',
          nan = void 0 === locale.nan ? 'NaN' : locale.nan + '';
        function newFormat(specifier) {
          var fill = (specifier = formatSpecifier(specifier)).fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;
          ('n' === type
            ? ((comma = !0), (type = 'g'))
            : formatTypes[type] ||
              (void 0 === precision && (precision = 12), (trim = !0), (type = 'g')),
            (zero || ('0' === fill && '=' === align)) &&
              ((zero = !0), (fill = '0'), (align = '=')));
          var prefix =
              '$' === symbol
                ? currencyPrefix
                : '#' === symbol && /[boxX]/.test(type)
                  ? '0' + type.toLowerCase()
                  : '',
            suffix = '$' === symbol ? currencySuffix : /[%p]/.test(type) ? percent : '',
            formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);
          function format(value) {
            var i,
              n,
              c,
              valuePrefix = prefix,
              valueSuffix = suffix;
            if ('c' === type) ((valueSuffix = formatType(value) + valueSuffix), (value = ''));
            else {
              var valueNegative = (value = +value) < 0 || 1 / value < 0;
              if (
                ((value = isNaN(value) ? nan : formatType(Math.abs(value), precision)),
                trim &&
                  (value = (function formatTrim(s) {
                    out: for (var i1, n = s.length, i = 1, i0 = -1; i < n; ++i)
                      switch (s[i]) {
                        case '.':
                          i0 = i1 = i;
                          break;
                        case '0':
                          (0 === i0 && (i0 = i), (i1 = i));
                          break;
                        default:
                          if (!+s[i]) break out;
                          i0 > 0 && (i0 = 0);
                      }
                    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
                  })(value)),
                valueNegative && 0 === +value && '+' !== sign && (valueNegative = !1),
                (valuePrefix =
                  (valueNegative
                    ? '(' === sign
                      ? sign
                      : minus
                    : '-' === sign || '(' === sign
                      ? ''
                      : sign) + valuePrefix),
                (valueSuffix =
                  ('s' === type ? prefixes[8 + prefixExponent / 3] : '') +
                  valueSuffix +
                  (valueNegative && '(' === sign ? ')' : '')),
                maybeSuffix)
              )
                for (i = -1, n = value.length; ++i < n; )
                  if (48 > (c = value.charCodeAt(i)) || c > 57) {
                    ((valueSuffix =
                      (46 === c ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix),
                      (value = value.slice(0, i)));
                    break;
                  }
            }
            comma && !zero && (value = group(value, 1 / 0));
            var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : '';
            switch (
              (comma &&
                zero &&
                ((value = group(
                  padding + value,
                  padding.length ? width - valueSuffix.length : 1 / 0
                )),
                (padding = '')),
              align)
            ) {
              case '<':
                value = valuePrefix + value + valueSuffix + padding;
                break;
              case '=':
                value = valuePrefix + padding + value + valueSuffix;
                break;
              case '^':
                value =
                  padding.slice(0, (length = padding.length >> 1)) +
                  valuePrefix +
                  value +
                  valueSuffix +
                  padding.slice(length);
                break;
              default:
                value = padding + valuePrefix + value + valueSuffix;
            }
            return numerals(value);
          }
          return (
            (precision =
              void 0 === precision
                ? 6
                : /[gprs]/.test(type)
                  ? Math.max(1, Math.min(21, precision))
                  : Math.max(0, Math.min(20, precision))),
            (format.toString = function () {
              return specifier + '';
            }),
            format
          );
        }
        return {
          format: newFormat,
          formatPrefix: function formatPrefix(specifier, value) {
            var f = newFormat((((specifier = formatSpecifier(specifier)).type = 'f'), specifier)),
              e = 3 * Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))),
              k = Math.pow(10, -e),
              prefix = prefixes[8 + e / 3];
            return function (value) {
              return f(k * value) + prefix;
            };
          },
        };
      }
      function tickFormat(start, stop, count, specifier) {
        var precision,
          step = tickStep(start, stop, count);
        switch ((specifier = formatSpecifier(null == specifier ? ',f' : specifier)).type) {
          case 's':
            var value = Math.max(Math.abs(start), Math.abs(stop));
            return (
              null != specifier.precision ||
                isNaN(
                  (precision = (function precisionPrefix(step, value) {
                    return Math.max(
                      0,
                      3 * Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) -
                        exponent(Math.abs(step))
                    );
                  })(step, value))
                ) ||
                (specifier.precision = precision),
              formatPrefix(specifier, value)
            );
          case '':
          case 'e':
          case 'g':
          case 'p':
          case 'r':
            null != specifier.precision ||
              isNaN(
                (precision = (function precisionRound(step, max) {
                  return (
                    (step = Math.abs(step)),
                    (max = Math.abs(max) - step),
                    Math.max(0, exponent(max) - exponent(step)) + 1
                  );
                })(step, Math.max(Math.abs(start), Math.abs(stop))))
              ) ||
              (specifier.precision = precision - ('e' === specifier.type));
            break;
          case 'f':
          case '%':
            null != specifier.precision ||
              isNaN(
                (precision = (function precisionFixed(step) {
                  return Math.max(0, -exponent(Math.abs(step)));
                })(step))
              ) ||
              (specifier.precision = precision - 2 * ('%' === specifier.type));
        }
        return format(specifier);
      }
      function linearish(scale) {
        var domain = scale.domain;
        return (
          (scale.ticks = function (count) {
            var d = domain();
            return ticks(d[0], d[d.length - 1], null == count ? 10 : count);
          }),
          (scale.tickFormat = function (count, specifier) {
            var d = domain();
            return tickFormat(d[0], d[d.length - 1], null == count ? 10 : count, specifier);
          }),
          (scale.nice = function (count) {
            null == count && (count = 10);
            var prestep,
              step,
              d = domain(),
              i0 = 0,
              i1 = d.length - 1,
              start = d[i0],
              stop = d[i1],
              maxIter = 10;
            for (
              stop < start &&
              ((step = start), (start = stop), (stop = step), (step = i0), (i0 = i1), (i1 = step));
              maxIter-- > 0;
            ) {
              if ((step = tickIncrement(start, stop, count)) === prestep)
                return ((d[i0] = start), (d[i1] = stop), domain(d));
              if (step > 0)
                ((start = Math.floor(start / step) * step), (stop = Math.ceil(stop / step) * step));
              else {
                if (!(step < 0)) break;
                ((start = Math.ceil(start * step) / step), (stop = Math.floor(stop * step) / step));
              }
              prestep = step;
            }
            return scale;
          }),
          scale
        );
      }
      function linear_linear() {
        var scale = continuous();
        return (
          (scale.copy = function () {
            return copy(scale, linear_linear());
          }),
          initRange.apply(scale, arguments),
          linearish(scale)
        );
      }
      function identity_identity(domain) {
        var unknown;
        function scale(x) {
          return null == x || isNaN((x = +x)) ? unknown : x;
        }
        return (
          (scale.invert = scale),
          (scale.domain = scale.range =
            function (_) {
              return arguments.length
                ? ((domain = Array.from(_, src_number_number)), scale)
                : domain.slice();
            }),
          (scale.unknown = function (_) {
            return arguments.length ? ((unknown = _), scale) : unknown;
          }),
          (scale.copy = function () {
            return identity_identity(domain).unknown(unknown);
          }),
          (domain = arguments.length ? Array.from(domain, src_number_number) : [0, 1]),
          linearish(scale)
        );
      }
      function nice(domain, interval) {
        var t,
          i0 = 0,
          i1 = (domain = domain.slice()).length - 1,
          x0 = domain[i0],
          x1 = domain[i1];
        return (
          x1 < x0 && ((t = i0), (i0 = i1), (i1 = t), (t = x0), (x0 = x1), (x1 = t)),
          (domain[i0] = interval.floor(x0)),
          (domain[i1] = interval.ceil(x1)),
          domain
        );
      }
      function transformLog(x) {
        return Math.log(x);
      }
      function transformExp(x) {
        return Math.exp(x);
      }
      function transformLogn(x) {
        return -Math.log(-x);
      }
      function transformExpn(x) {
        return -Math.exp(-x);
      }
      function pow10(x) {
        return isFinite(x) ? +('1e' + x) : x < 0 ? 0 : x;
      }
      function reflect(f) {
        return (x, k) => -f(-x, k);
      }
      function loggish(transform) {
        const scale = transform(transformLog, transformExp),
          domain = scale.domain;
        let logs,
          pows,
          base = 10;
        function rescale() {
          return (
            (logs = (function logp(base) {
              return base === Math.E
                ? Math.log
                : (10 === base && Math.log10) ||
                    (2 === base && Math.log2) ||
                    ((base = Math.log(base)), (x) => Math.log(x) / base);
            })(base)),
            (pows = (function powp(base) {
              return 10 === base ? pow10 : base === Math.E ? Math.exp : (x) => Math.pow(base, x);
            })(base)),
            domain()[0] < 0
              ? ((logs = reflect(logs)),
                (pows = reflect(pows)),
                transform(transformLogn, transformExpn))
              : transform(transformLog, transformExp),
            scale
          );
        }
        return (
          (scale.base = function (_) {
            return arguments.length ? ((base = +_), rescale()) : base;
          }),
          (scale.domain = function (_) {
            return arguments.length ? (domain(_), rescale()) : domain();
          }),
          (scale.ticks = (count) => {
            const d = domain();
            let u = d[0],
              v = d[d.length - 1];
            const r = v < u;
            r && ([u, v] = [v, u]);
            let k,
              t,
              i = logs(u),
              j = logs(v);
            const n = null == count ? 10 : +count;
            let z = [];
            if (!(base % 1) && j - i < n) {
              if (((i = Math.floor(i)), (j = Math.ceil(j)), u > 0)) {
                for (; i <= j; ++i)
                  for (k = 1; k < base; ++k)
                    if (((t = i < 0 ? k / pows(-i) : k * pows(i)), !(t < u))) {
                      if (t > v) break;
                      z.push(t);
                    }
              } else
                for (; i <= j; ++i)
                  for (k = base - 1; k >= 1; --k)
                    if (((t = i > 0 ? k / pows(-i) : k * pows(i)), !(t < u))) {
                      if (t > v) break;
                      z.push(t);
                    }
              2 * z.length < n && (z = ticks(u, v, n));
            } else z = ticks(i, j, Math.min(j - i, n)).map(pows);
            return r ? z.reverse() : z;
          }),
          (scale.tickFormat = (count, specifier) => {
            if (
              (null == count && (count = 10),
              null == specifier && (specifier = 10 === base ? 's' : ','),
              'function' != typeof specifier &&
                (base % 1 ||
                  null != (specifier = formatSpecifier(specifier)).precision ||
                  (specifier.trim = !0),
                (specifier = format(specifier))),
              count === 1 / 0)
            )
              return specifier;
            const k = Math.max(1, (base * count) / scale.ticks().length);
            return (d) => {
              let i = d / pows(Math.round(logs(d)));
              return (i * base < base - 0.5 && (i *= base), i <= k ? specifier(d) : '');
            };
          }),
          (scale.nice = () =>
            domain(
              nice(domain(), {
                floor: (x) => pows(Math.floor(logs(x))),
                ceil: (x) => pows(Math.ceil(logs(x))),
              })
            )),
          scale
        );
      }
      function log() {
        const scale = loggish(transformer()).domain([1, 10]);
        return (
          (scale.copy = () => copy(scale, log()).base(scale.base())),
          initRange.apply(scale, arguments),
          scale
        );
      }
      function transformSymlog(c) {
        return function (x) {
          return Math.sign(x) * Math.log1p(Math.abs(x / c));
        };
      }
      function transformSymexp(c) {
        return function (x) {
          return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
        };
      }
      function symlogish(transform) {
        var c = 1,
          scale = transform(transformSymlog(c), transformSymexp(c));
        return (
          (scale.constant = function (_) {
            return arguments.length ? transform(transformSymlog((c = +_)), transformSymexp(c)) : c;
          }),
          linearish(scale)
        );
      }
      function symlog() {
        var scale = symlogish(transformer());
        return (
          (scale.copy = function () {
            return copy(scale, symlog()).constant(scale.constant());
          }),
          initRange.apply(scale, arguments)
        );
      }
      function transformPow(exponent) {
        return function (x) {
          return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
        };
      }
      function transformSqrt(x) {
        return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
      }
      function transformSquare(x) {
        return x < 0 ? -x * x : x * x;
      }
      function powish(transform) {
        var scale = transform(identity, identity),
          exponent = 1;
        return (
          (scale.exponent = function (_) {
            return arguments.length
              ? ((exponent = +_),
                (function rescale() {
                  return 1 === exponent
                    ? transform(identity, identity)
                    : 0.5 === exponent
                      ? transform(transformSqrt, transformSquare)
                      : transform(transformPow(exponent), transformPow(1 / exponent));
                })())
              : exponent;
          }),
          linearish(scale)
        );
      }
      function pow() {
        var scale = powish(transformer());
        return (
          (scale.copy = function () {
            return copy(scale, pow()).exponent(scale.exponent());
          }),
          initRange.apply(scale, arguments),
          scale
        );
      }
      function sqrt() {
        return pow.apply(null, arguments).exponent(0.5);
      }
      function square(x) {
        return Math.sign(x) * x * x;
      }
      function radial() {
        var unknown,
          squared = continuous(),
          range = [0, 1],
          round = !1;
        function scale(x) {
          var y = (function unsquare(x) {
            return Math.sign(x) * Math.sqrt(Math.abs(x));
          })(squared(x));
          return isNaN(y) ? unknown : round ? Math.round(y) : y;
        }
        return (
          (scale.invert = function (y) {
            return squared.invert(square(y));
          }),
          (scale.domain = function (_) {
            return arguments.length ? (squared.domain(_), scale) : squared.domain();
          }),
          (scale.range = function (_) {
            return arguments.length
              ? (squared.range((range = Array.from(_, src_number_number)).map(square)), scale)
              : range.slice();
          }),
          (scale.rangeRound = function (_) {
            return scale.range(_).round(!0);
          }),
          (scale.round = function (_) {
            return arguments.length ? ((round = !!_), scale) : round;
          }),
          (scale.clamp = function (_) {
            return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
          }),
          (scale.unknown = function (_) {
            return arguments.length ? ((unknown = _), scale) : unknown;
          }),
          (scale.copy = function () {
            return radial(squared.domain(), range)
              .round(round)
              .clamp(squared.clamp())
              .unknown(unknown);
          }),
          initRange.apply(scale, arguments),
          linearish(scale)
        );
      }
      function max(values, valueof) {
        let max;
        if (void 0 === valueof)
          for (const value of values)
            null != value && (max < value || (void 0 === max && value >= value)) && (max = value);
        else {
          let index = -1;
          for (let value of values)
            null != (value = valueof(value, ++index, values)) &&
              (max < value || (void 0 === max && value >= value)) &&
              (max = value);
        }
        return max;
      }
      function min(values, valueof) {
        let min;
        if (void 0 === valueof)
          for (const value of values)
            null != value && (min > value || (void 0 === min && value >= value)) && (min = value);
        else {
          let index = -1;
          for (let value of values)
            null != (value = valueof(value, ++index, values)) &&
              (min > value || (void 0 === min && value >= value)) &&
              (min = value);
        }
        return min;
      }
      function compareDefined(compare = ascending) {
        if (compare === ascending) return sort_ascendingDefined;
        if ('function' != typeof compare) throw new TypeError('compare is not a function');
        return (a, b) => {
          const x = compare(a, b);
          return x || 0 === x ? x : (0 === compare(b, b)) - (0 === compare(a, a));
        };
      }
      function sort_ascendingDefined(a, b) {
        return (null == a || !(a >= a)) - (null == b || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
      }
      function quickselect_quickselect(array, k, left = 0, right = 1 / 0, compare) {
        if (
          ((k = Math.floor(k)),
          (left = Math.floor(Math.max(0, left))),
          (right = Math.floor(Math.min(array.length - 1, right))),
          !(left <= k && k <= right))
        )
          return array;
        for (
          compare = void 0 === compare ? sort_ascendingDefined : compareDefined(compare);
          right > left;
        ) {
          if (right - left > 600) {
            const n = right - left + 1,
              m = k - left + 1,
              z = Math.log(n),
              s = 0.5 * Math.exp((2 * z) / 3),
              sd = 0.5 * Math.sqrt((z * s * (n - s)) / n) * (m - n / 2 < 0 ? -1 : 1);
            quickselect_quickselect(
              array,
              k,
              Math.max(left, Math.floor(k - (m * s) / n + sd)),
              Math.min(right, Math.floor(k + ((n - m) * s) / n + sd)),
              compare
            );
          }
          const t = array[k];
          let i = left,
            j = right;
          for (
            swap(array, left, k), compare(array[right], t) > 0 && swap(array, left, right);
            i < j;
          ) {
            for (swap(array, i, j), ++i, --j; compare(array[i], t) < 0; ) ++i;
            for (; compare(array[j], t) > 0; ) --j;
          }
          (0 === compare(array[left], t) ? swap(array, left, j) : (++j, swap(array, j, right)),
            j <= k && (left = j + 1),
            k <= j && (right = j - 1));
        }
        return array;
      }
      function swap(array, i, j) {
        const t = array[i];
        ((array[i] = array[j]), (array[j] = t));
      }
      function quantile(values, p, valueof) {
        if (
          ((values = Float64Array.from(
            (function* numbers(values, valueof) {
              if (void 0 === valueof)
                for (let value of values)
                  null != value && (value = +value) >= value && (yield value);
              else {
                let index = -1;
                for (let value of values)
                  null != (value = valueof(value, ++index, values)) &&
                    (value = +value) >= value &&
                    (yield value);
              }
            })(values, valueof)
          )),
          (n = values.length) && !isNaN((p = +p)))
        ) {
          if (p <= 0 || n < 2) return min(values);
          if (p >= 1) return max(values);
          var n,
            i = (n - 1) * p,
            i0 = Math.floor(i),
            value0 = max(quickselect_quickselect(values, i0).subarray(0, i0 + 1));
          return value0 + (min(values.subarray(i0 + 1)) - value0) * (i - i0);
        }
      }
      function quantileSorted(values, p, valueof = number_number) {
        if ((n = values.length) && !isNaN((p = +p))) {
          if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
          if (p >= 1) return +valueof(values[n - 1], n - 1, values);
          var n,
            i = (n - 1) * p,
            i0 = Math.floor(i),
            value0 = +valueof(values[i0], i0, values);
          return value0 + (+valueof(values[i0 + 1], i0 + 1, values) - value0) * (i - i0);
        }
      }
      function quantile_quantile() {
        var unknown,
          domain = [],
          range = [],
          thresholds = [];
        function rescale() {
          var i = 0,
            n = Math.max(1, range.length);
          for (thresholds = new Array(n - 1); ++i < n; )
            thresholds[i - 1] = quantileSorted(domain, i / n);
          return scale;
        }
        function scale(x) {
          return null == x || isNaN((x = +x)) ? unknown : range[bisect(thresholds, x)];
        }
        return (
          (scale.invertExtent = function (y) {
            var i = range.indexOf(y);
            return i < 0
              ? [NaN, NaN]
              : [
                  i > 0 ? thresholds[i - 1] : domain[0],
                  i < thresholds.length ? thresholds[i] : domain[domain.length - 1],
                ];
          }),
          (scale.domain = function (_) {
            if (!arguments.length) return domain.slice();
            domain = [];
            for (let d of _) null == d || isNaN((d = +d)) || domain.push(d);
            return (domain.sort(ascending), rescale());
          }),
          (scale.range = function (_) {
            return arguments.length ? ((range = Array.from(_)), rescale()) : range.slice();
          }),
          (scale.unknown = function (_) {
            return arguments.length ? ((unknown = _), scale) : unknown;
          }),
          (scale.quantiles = function () {
            return thresholds.slice();
          }),
          (scale.copy = function () {
            return quantile_quantile().domain(domain).range(range).unknown(unknown);
          }),
          initRange.apply(scale, arguments)
        );
      }
      function quantize() {
        var unknown,
          x0 = 0,
          x1 = 1,
          n = 1,
          domain = [0.5],
          range = [0, 1];
        function scale(x) {
          return null != x && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
        }
        function rescale() {
          var i = -1;
          for (domain = new Array(n); ++i < n; )
            domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
          return scale;
        }
        return (
          (scale.domain = function (_) {
            return arguments.length
              ? (([x0, x1] = _), (x0 = +x0), (x1 = +x1), rescale())
              : [x0, x1];
          }),
          (scale.range = function (_) {
            return arguments.length
              ? ((n = (range = Array.from(_)).length - 1), rescale())
              : range.slice();
          }),
          (scale.invertExtent = function (y) {
            var i = range.indexOf(y);
            return i < 0
              ? [NaN, NaN]
              : i < 1
                ? [x0, domain[0]]
                : i >= n
                  ? [domain[n - 1], x1]
                  : [domain[i - 1], domain[i]];
          }),
          (scale.unknown = function (_) {
            return arguments.length ? ((unknown = _), scale) : scale;
          }),
          (scale.thresholds = function () {
            return domain.slice();
          }),
          (scale.copy = function () {
            return quantize().domain([x0, x1]).range(range).unknown(unknown);
          }),
          initRange.apply(linearish(scale), arguments)
        );
      }
      function threshold() {
        var unknown,
          domain = [0.5],
          range = [0, 1],
          n = 1;
        function scale(x) {
          return null != x && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
        }
        return (
          (scale.domain = function (_) {
            return arguments.length
              ? ((domain = Array.from(_)), (n = Math.min(domain.length, range.length - 1)), scale)
              : domain.slice();
          }),
          (scale.range = function (_) {
            return arguments.length
              ? ((range = Array.from(_)), (n = Math.min(domain.length, range.length - 1)), scale)
              : range.slice();
          }),
          (scale.invertExtent = function (y) {
            var i = range.indexOf(y);
            return [domain[i - 1], domain[i]];
          }),
          (scale.unknown = function (_) {
            return arguments.length ? ((unknown = _), scale) : unknown;
          }),
          (scale.copy = function () {
            return threshold().domain(domain).range(range).unknown(unknown);
          }),
          initRange.apply(scale, arguments)
        );
      }
      !(function defaultLocale(definition) {
        return (
          (defaultLocale_locale = locale(definition)),
          (format = defaultLocale_locale.format),
          (formatPrefix = defaultLocale_locale.formatPrefix),
          defaultLocale_locale
        );
      })({ thousands: ',', grouping: [3], currency: ['$', ''] });
      const t0 = new Date(),
        t1 = new Date();
      function timeInterval(floori, offseti, count, field) {
        function interval(date) {
          return (floori((date = 0 === arguments.length ? new Date() : new Date(+date))), date);
        }
        return (
          (interval.floor = (date) => (floori((date = new Date(+date))), date)),
          (interval.ceil = (date) => (
            floori((date = new Date(date - 1))),
            offseti(date, 1),
            floori(date),
            date
          )),
          (interval.round = (date) => {
            const d0 = interval(date),
              d1 = interval.ceil(date);
            return date - d0 < d1 - date ? d0 : d1;
          }),
          (interval.offset = (date, step) => (
            offseti((date = new Date(+date)), null == step ? 1 : Math.floor(step)),
            date
          )),
          (interval.range = (start, stop, step) => {
            const range = [];
            if (
              ((start = interval.ceil(start)),
              (step = null == step ? 1 : Math.floor(step)),
              !(start < stop && step > 0))
            )
              return range;
            let previous;
            do {
              (range.push((previous = new Date(+start))), offseti(start, step), floori(start));
            } while (previous < start && start < stop);
            return range;
          }),
          (interval.filter = (test) =>
            timeInterval(
              (date) => {
                if (date >= date) for (; floori(date), !test(date); ) date.setTime(date - 1);
              },
              (date, step) => {
                if (date >= date)
                  if (step < 0) for (; ++step <= 0; ) for (; offseti(date, -1), !test(date); );
                  else for (; --step >= 0; ) for (; offseti(date, 1), !test(date); );
              }
            )),
          count &&
            ((interval.count = (start, end) => (
              t0.setTime(+start),
              t1.setTime(+end),
              floori(t0),
              floori(t1),
              Math.floor(count(t0, t1))
            )),
            (interval.every = (step) => (
              (step = Math.floor(step)),
              isFinite(step) && step > 0
                ? step > 1
                  ? interval.filter(
                      field
                        ? (d) => field(d) % step === 0
                        : (d) => interval.count(0, d) % step === 0
                    )
                  : interval
                : null
            ))),
          interval
        );
      }
      const millisecond = timeInterval(
        () => {},
        (date, step) => {
          date.setTime(+date + step);
        },
        (start, end) => end - start
      );
      millisecond.every = (k) => (
        (k = Math.floor(k)),
        isFinite(k) && k > 0
          ? k > 1
            ? timeInterval(
                (date) => {
                  date.setTime(Math.floor(date / k) * k);
                },
                (date, step) => {
                  date.setTime(+date + step * k);
                },
                (start, end) => (end - start) / k
              )
            : millisecond
          : null
      );
      millisecond.range;
      const second = timeInterval(
          (date) => {
            date.setTime(date - date.getMilliseconds());
          },
          (date, step) => {
            date.setTime(+date + 1e3 * step);
          },
          (start, end) => (end - start) / 1e3,
          (date) => date.getUTCSeconds()
        ),
        timeMinute =
          (second.range,
          timeInterval(
            (date) => {
              date.setTime(date - date.getMilliseconds() - 1e3 * date.getSeconds());
            },
            (date, step) => {
              date.setTime(+date + 6e4 * step);
            },
            (start, end) => (end - start) / 6e4,
            (date) => date.getMinutes()
          )),
        utcMinute =
          (timeMinute.range,
          timeInterval(
            (date) => {
              date.setUTCSeconds(0, 0);
            },
            (date, step) => {
              date.setTime(+date + 6e4 * step);
            },
            (start, end) => (end - start) / 6e4,
            (date) => date.getUTCMinutes()
          )),
        timeHour =
          (utcMinute.range,
          timeInterval(
            (date) => {
              date.setTime(
                date - date.getMilliseconds() - 1e3 * date.getSeconds() - 6e4 * date.getMinutes()
              );
            },
            (date, step) => {
              date.setTime(+date + 36e5 * step);
            },
            (start, end) => (end - start) / 36e5,
            (date) => date.getHours()
          )),
        utcHour =
          (timeHour.range,
          timeInterval(
            (date) => {
              date.setUTCMinutes(0, 0, 0);
            },
            (date, step) => {
              date.setTime(+date + 36e5 * step);
            },
            (start, end) => (end - start) / 36e5,
            (date) => date.getUTCHours()
          )),
        timeDay =
          (utcHour.range,
          timeInterval(
            (date) => date.setHours(0, 0, 0, 0),
            (date, step) => date.setDate(date.getDate() + step),
            (start, end) =>
              (end - start - 6e4 * (end.getTimezoneOffset() - start.getTimezoneOffset())) / 864e5,
            (date) => date.getDate() - 1
          )),
        utcDay =
          (timeDay.range,
          timeInterval(
            (date) => {
              date.setUTCHours(0, 0, 0, 0);
            },
            (date, step) => {
              date.setUTCDate(date.getUTCDate() + step);
            },
            (start, end) => (end - start) / 864e5,
            (date) => date.getUTCDate() - 1
          )),
        unixDay =
          (utcDay.range,
          timeInterval(
            (date) => {
              date.setUTCHours(0, 0, 0, 0);
            },
            (date, step) => {
              date.setUTCDate(date.getUTCDate() + step);
            },
            (start, end) => (end - start) / 864e5,
            (date) => Math.floor(date / 864e5)
          ));
      unixDay.range;
      function timeWeekday(i) {
        return timeInterval(
          (date) => {
            (date.setDate(date.getDate() - ((date.getDay() + 7 - i) % 7)),
              date.setHours(0, 0, 0, 0));
          },
          (date, step) => {
            date.setDate(date.getDate() + 7 * step);
          },
          (start, end) =>
            (end - start - 6e4 * (end.getTimezoneOffset() - start.getTimezoneOffset())) / 6048e5
        );
      }
      const timeSunday = timeWeekday(0),
        timeMonday = timeWeekday(1),
        timeTuesday = timeWeekday(2),
        timeWednesday = timeWeekday(3),
        timeThursday = timeWeekday(4),
        timeFriday = timeWeekday(5),
        timeSaturday = timeWeekday(6);
      (timeSunday.range,
        timeMonday.range,
        timeTuesday.range,
        timeWednesday.range,
        timeThursday.range,
        timeFriday.range,
        timeSaturday.range);
      function utcWeekday(i) {
        return timeInterval(
          (date) => {
            (date.setUTCDate(date.getUTCDate() - ((date.getUTCDay() + 7 - i) % 7)),
              date.setUTCHours(0, 0, 0, 0));
          },
          (date, step) => {
            date.setUTCDate(date.getUTCDate() + 7 * step);
          },
          (start, end) => (end - start) / 6048e5
        );
      }
      const utcSunday = utcWeekday(0),
        utcMonday = utcWeekday(1),
        utcTuesday = utcWeekday(2),
        utcWednesday = utcWeekday(3),
        utcThursday = utcWeekday(4),
        utcFriday = utcWeekday(5),
        utcSaturday = utcWeekday(6),
        timeMonth =
          (utcSunday.range,
          utcMonday.range,
          utcTuesday.range,
          utcWednesday.range,
          utcThursday.range,
          utcFriday.range,
          utcSaturday.range,
          timeInterval(
            (date) => {
              (date.setDate(1), date.setHours(0, 0, 0, 0));
            },
            (date, step) => {
              date.setMonth(date.getMonth() + step);
            },
            (start, end) =>
              end.getMonth() - start.getMonth() + 12 * (end.getFullYear() - start.getFullYear()),
            (date) => date.getMonth()
          )),
        utcMonth =
          (timeMonth.range,
          timeInterval(
            (date) => {
              (date.setUTCDate(1), date.setUTCHours(0, 0, 0, 0));
            },
            (date, step) => {
              date.setUTCMonth(date.getUTCMonth() + step);
            },
            (start, end) =>
              end.getUTCMonth() -
              start.getUTCMonth() +
              12 * (end.getUTCFullYear() - start.getUTCFullYear()),
            (date) => date.getUTCMonth()
          )),
        timeYear =
          (utcMonth.range,
          timeInterval(
            (date) => {
              (date.setMonth(0, 1), date.setHours(0, 0, 0, 0));
            },
            (date, step) => {
              date.setFullYear(date.getFullYear() + step);
            },
            (start, end) => end.getFullYear() - start.getFullYear(),
            (date) => date.getFullYear()
          ));
      timeYear.every = (k) =>
        isFinite((k = Math.floor(k))) && k > 0
          ? timeInterval(
              (date) => {
                (date.setFullYear(Math.floor(date.getFullYear() / k) * k),
                  date.setMonth(0, 1),
                  date.setHours(0, 0, 0, 0));
              },
              (date, step) => {
                date.setFullYear(date.getFullYear() + step * k);
              }
            )
          : null;
      timeYear.range;
      const utcYear = timeInterval(
        (date) => {
          (date.setUTCMonth(0, 1), date.setUTCHours(0, 0, 0, 0));
        },
        (date, step) => {
          date.setUTCFullYear(date.getUTCFullYear() + step);
        },
        (start, end) => end.getUTCFullYear() - start.getUTCFullYear(),
        (date) => date.getUTCFullYear()
      );
      utcYear.every = (k) =>
        isFinite((k = Math.floor(k))) && k > 0
          ? timeInterval(
              (date) => {
                (date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k),
                  date.setUTCMonth(0, 1),
                  date.setUTCHours(0, 0, 0, 0));
              },
              (date, step) => {
                date.setUTCFullYear(date.getUTCFullYear() + step * k);
              }
            )
          : null;
      utcYear.range;
      function ticker(year, month, week, day, hour, minute) {
        const tickIntervals = [
          [second, 1, 1e3],
          [second, 5, 5e3],
          [second, 15, 15e3],
          [second, 30, 3e4],
          [minute, 1, 6e4],
          [minute, 5, 3e5],
          [minute, 15, 9e5],
          [minute, 30, 18e5],
          [hour, 1, 36e5],
          [hour, 3, 108e5],
          [hour, 6, 216e5],
          [hour, 12, 432e5],
          [day, 1, 864e5],
          [day, 2, 1728e5],
          [week, 1, 6048e5],
          [month, 1, 2592e6],
          [month, 3, 7776e6],
          [year, 1, 31536e6],
        ];
        function tickInterval(start, stop, count) {
          const target = Math.abs(stop - start) / count,
            i = bisector(([, , step]) => step).right(tickIntervals, target);
          if (i === tickIntervals.length)
            return year.every(tickStep(start / 31536e6, stop / 31536e6, count));
          if (0 === i) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
          const [t, step] =
            tickIntervals[
              target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i
            ];
          return t.every(step);
        }
        return [
          function ticks(start, stop, count) {
            const reverse = stop < start;
            reverse && ([start, stop] = [stop, start]);
            const interval =
                count && 'function' == typeof count.range
                  ? count
                  : tickInterval(start, stop, count),
              ticks = interval ? interval.range(start, +stop + 1) : [];
            return reverse ? ticks.reverse() : ticks;
          },
          tickInterval,
        ];
      }
      const [utcTicks, utcTickInterval] = ticker(
          utcYear,
          utcMonth,
          utcSunday,
          unixDay,
          utcHour,
          utcMinute
        ),
        [timeTicks, timeTickInterval] = ticker(
          timeYear,
          timeMonth,
          timeSunday,
          timeDay,
          timeHour,
          timeMinute
        );
      function localDate(d) {
        if (0 <= d.y && d.y < 100) {
          var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
          return (date.setFullYear(d.y), date);
        }
        return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
      }
      function utcDate(d) {
        if (0 <= d.y && d.y < 100) {
          var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
          return (date.setUTCFullYear(d.y), date);
        }
        return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
      }
      function newDate(y, m, d) {
        return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
      }
      var src_defaultLocale_locale,
        timeFormat,
        utcFormat,
        pads = { '-': '', _: ' ', 0: '0' },
        numberRe = /^\s*\d+/,
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;
      function pad(value, fill, width) {
        var sign = value < 0 ? '-' : '',
          string = (sign ? -value : value) + '',
          length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
      }
      function requote(s) {
        return s.replace(requoteRe, '\\$&');
      }
      function formatRe(names) {
        return new RegExp('^(?:' + names.map(requote).join('|') + ')', 'i');
      }
      function formatLookup(names) {
        return new Map(names.map((name, i) => [name.toLowerCase(), i]));
      }
      function parseWeekdayNumberSunday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 1));
        return n ? ((d.w = +n[0]), i + n[0].length) : -1;
      }
      function parseWeekdayNumberMonday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 1));
        return n ? ((d.u = +n[0]), i + n[0].length) : -1;
      }
      function parseWeekNumberSunday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? ((d.U = +n[0]), i + n[0].length) : -1;
      }
      function parseWeekNumberISO(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? ((d.V = +n[0]), i + n[0].length) : -1;
      }
      function parseWeekNumberMonday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? ((d.W = +n[0]), i + n[0].length) : -1;
      }
      function parseFullYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 4));
        return n ? ((d.y = +n[0]), i + n[0].length) : -1;
      }
      function parseYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? ((d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3)), i + n[0].length) : -1;
      }
      function parseZone(d, string, i) {
        var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
        return n ? ((d.Z = n[1] ? 0 : -(n[2] + (n[3] || '00'))), i + n[0].length) : -1;
      }
      function parseQuarter(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 1));
        return n ? ((d.q = 3 * n[0] - 3), i + n[0].length) : -1;
      }
      function parseMonthNumber(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? ((d.m = n[0] - 1), i + n[0].length) : -1;
      }
      function parseDayOfMonth(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? ((d.d = +n[0]), i + n[0].length) : -1;
      }
      function parseDayOfYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 3));
        return n ? ((d.m = 0), (d.d = +n[0]), i + n[0].length) : -1;
      }
      function parseHour24(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? ((d.H = +n[0]), i + n[0].length) : -1;
      }
      function parseMinutes(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? ((d.M = +n[0]), i + n[0].length) : -1;
      }
      function parseSeconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? ((d.S = +n[0]), i + n[0].length) : -1;
      }
      function parseMilliseconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 3));
        return n ? ((d.L = +n[0]), i + n[0].length) : -1;
      }
      function parseMicroseconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 6));
        return n ? ((d.L = Math.floor(n[0] / 1e3)), i + n[0].length) : -1;
      }
      function parseLiteralPercent(d, string, i) {
        var n = percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
      }
      function parseUnixTimestamp(d, string, i) {
        var n = numberRe.exec(string.slice(i));
        return n ? ((d.Q = +n[0]), i + n[0].length) : -1;
      }
      function parseUnixTimestampSeconds(d, string, i) {
        var n = numberRe.exec(string.slice(i));
        return n ? ((d.s = +n[0]), i + n[0].length) : -1;
      }
      function formatDayOfMonth(d, p) {
        return pad(d.getDate(), p, 2);
      }
      function formatHour24(d, p) {
        return pad(d.getHours(), p, 2);
      }
      function formatHour12(d, p) {
        return pad(d.getHours() % 12 || 12, p, 2);
      }
      function formatDayOfYear(d, p) {
        return pad(1 + timeDay.count(timeYear(d), d), p, 3);
      }
      function formatMilliseconds(d, p) {
        return pad(d.getMilliseconds(), p, 3);
      }
      function formatMicroseconds(d, p) {
        return formatMilliseconds(d, p) + '000';
      }
      function formatMonthNumber(d, p) {
        return pad(d.getMonth() + 1, p, 2);
      }
      function formatMinutes(d, p) {
        return pad(d.getMinutes(), p, 2);
      }
      function formatSeconds(d, p) {
        return pad(d.getSeconds(), p, 2);
      }
      function formatWeekdayNumberMonday(d) {
        var day = d.getDay();
        return 0 === day ? 7 : day;
      }
      function formatWeekNumberSunday(d, p) {
        return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
      }
      function dISO(d) {
        var day = d.getDay();
        return day >= 4 || 0 === day ? timeThursday(d) : timeThursday.ceil(d);
      }
      function formatWeekNumberISO(d, p) {
        return (
          (d = dISO(d)),
          pad(timeThursday.count(timeYear(d), d) + (4 === timeYear(d).getDay()), p, 2)
        );
      }
      function formatWeekdayNumberSunday(d) {
        return d.getDay();
      }
      function formatWeekNumberMonday(d, p) {
        return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
      }
      function formatYear(d, p) {
        return pad(d.getFullYear() % 100, p, 2);
      }
      function formatYearISO(d, p) {
        return pad((d = dISO(d)).getFullYear() % 100, p, 2);
      }
      function formatFullYear(d, p) {
        return pad(d.getFullYear() % 1e4, p, 4);
      }
      function formatFullYearISO(d, p) {
        var day = d.getDay();
        return pad(
          (d = day >= 4 || 0 === day ? timeThursday(d) : timeThursday.ceil(d)).getFullYear() % 1e4,
          p,
          4
        );
      }
      function formatZone(d) {
        var z = d.getTimezoneOffset();
        return (z > 0 ? '-' : ((z *= -1), '+')) + pad((z / 60) | 0, '0', 2) + pad(z % 60, '0', 2);
      }
      function formatUTCDayOfMonth(d, p) {
        return pad(d.getUTCDate(), p, 2);
      }
      function formatUTCHour24(d, p) {
        return pad(d.getUTCHours(), p, 2);
      }
      function formatUTCHour12(d, p) {
        return pad(d.getUTCHours() % 12 || 12, p, 2);
      }
      function formatUTCDayOfYear(d, p) {
        return pad(1 + utcDay.count(utcYear(d), d), p, 3);
      }
      function formatUTCMilliseconds(d, p) {
        return pad(d.getUTCMilliseconds(), p, 3);
      }
      function formatUTCMicroseconds(d, p) {
        return formatUTCMilliseconds(d, p) + '000';
      }
      function formatUTCMonthNumber(d, p) {
        return pad(d.getUTCMonth() + 1, p, 2);
      }
      function formatUTCMinutes(d, p) {
        return pad(d.getUTCMinutes(), p, 2);
      }
      function formatUTCSeconds(d, p) {
        return pad(d.getUTCSeconds(), p, 2);
      }
      function formatUTCWeekdayNumberMonday(d) {
        var dow = d.getUTCDay();
        return 0 === dow ? 7 : dow;
      }
      function formatUTCWeekNumberSunday(d, p) {
        return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
      }
      function UTCdISO(d) {
        var day = d.getUTCDay();
        return day >= 4 || 0 === day ? utcThursday(d) : utcThursday.ceil(d);
      }
      function formatUTCWeekNumberISO(d, p) {
        return (
          (d = UTCdISO(d)),
          pad(utcThursday.count(utcYear(d), d) + (4 === utcYear(d).getUTCDay()), p, 2)
        );
      }
      function formatUTCWeekdayNumberSunday(d) {
        return d.getUTCDay();
      }
      function formatUTCWeekNumberMonday(d, p) {
        return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
      }
      function formatUTCYear(d, p) {
        return pad(d.getUTCFullYear() % 100, p, 2);
      }
      function formatUTCYearISO(d, p) {
        return pad((d = UTCdISO(d)).getUTCFullYear() % 100, p, 2);
      }
      function formatUTCFullYear(d, p) {
        return pad(d.getUTCFullYear() % 1e4, p, 4);
      }
      function formatUTCFullYearISO(d, p) {
        var day = d.getUTCDay();
        return pad(
          (d = day >= 4 || 0 === day ? utcThursday(d) : utcThursday.ceil(d)).getUTCFullYear() % 1e4,
          p,
          4
        );
      }
      function formatUTCZone() {
        return '+0000';
      }
      function formatLiteralPercent() {
        return '%';
      }
      function formatUnixTimestamp(d) {
        return +d;
      }
      function formatUnixTimestampSeconds(d) {
        return Math.floor(+d / 1e3);
      }
      function time_date(t) {
        return new Date(t);
      }
      function time_number(t) {
        return t instanceof Date ? +t : +new Date(+t);
      }
      function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
        var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain,
          formatMillisecond = format('.%L'),
          formatSecond = format(':%S'),
          formatMinute = format('%I:%M'),
          formatHour = format('%I %p'),
          formatDay = format('%a %d'),
          formatWeek = format('%b %d'),
          formatMonth = format('%B'),
          formatYear = format('%Y');
        function tickFormat(date) {
          return (
            second(date) < date
              ? formatMillisecond
              : minute(date) < date
                ? formatSecond
                : hour(date) < date
                  ? formatMinute
                  : day(date) < date
                    ? formatHour
                    : month(date) < date
                      ? week(date) < date
                        ? formatDay
                        : formatWeek
                      : year(date) < date
                        ? formatMonth
                        : formatYear
          )(date);
        }
        return (
          (scale.invert = function (y) {
            return new Date(invert(y));
          }),
          (scale.domain = function (_) {
            return arguments.length ? domain(Array.from(_, time_number)) : domain().map(time_date);
          }),
          (scale.ticks = function (interval) {
            var d = domain();
            return ticks(d[0], d[d.length - 1], null == interval ? 10 : interval);
          }),
          (scale.tickFormat = function (count, specifier) {
            return null == specifier ? tickFormat : format(specifier);
          }),
          (scale.nice = function (interval) {
            var d = domain();
            return (
              (interval && 'function' == typeof interval.range) ||
                (interval = tickInterval(d[0], d[d.length - 1], null == interval ? 10 : interval)),
              interval ? domain(nice(d, interval)) : scale
            );
          }),
          (scale.copy = function () {
            return copy(
              scale,
              calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format)
            );
          }),
          scale
        );
      }
      function time() {
        return initRange.apply(
          calendar(
            timeTicks,
            timeTickInterval,
            timeYear,
            timeMonth,
            timeSunday,
            timeDay,
            timeHour,
            timeMinute,
            second,
            timeFormat
          ).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]),
          arguments
        );
      }
      function utcTime() {
        return initRange.apply(
          calendar(
            utcTicks,
            utcTickInterval,
            utcYear,
            utcMonth,
            utcSunday,
            utcDay,
            utcHour,
            utcMinute,
            second,
            utcFormat
          ).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]),
          arguments
        );
      }
      function sequential_transformer() {
        var t0,
          t1,
          k10,
          transform,
          unknown,
          x0 = 0,
          x1 = 1,
          interpolator = identity,
          clamp = !1;
        function scale(x) {
          return null == x || isNaN((x = +x))
            ? unknown
            : interpolator(
                0 === k10
                  ? 0.5
                  : ((x = (transform(x) - t0) * k10), clamp ? Math.max(0, Math.min(1, x)) : x)
              );
        }
        function range(interpolate) {
          return function (_) {
            var r0, r1;
            return arguments.length
              ? (([r0, r1] = _), (interpolator = interpolate(r0, r1)), scale)
              : [interpolator(0), interpolator(1)];
          };
        }
        return (
          (scale.domain = function (_) {
            return arguments.length
              ? (([x0, x1] = _),
                (t0 = transform((x0 = +x0))),
                (t1 = transform((x1 = +x1))),
                (k10 = t0 === t1 ? 0 : 1 / (t1 - t0)),
                scale)
              : [x0, x1];
          }),
          (scale.clamp = function (_) {
            return arguments.length ? ((clamp = !!_), scale) : clamp;
          }),
          (scale.interpolator = function (_) {
            return arguments.length ? ((interpolator = _), scale) : interpolator;
          }),
          (scale.range = range(value)),
          (scale.rangeRound = range(round)),
          (scale.unknown = function (_) {
            return arguments.length ? ((unknown = _), scale) : unknown;
          }),
          function (t) {
            return (
              (transform = t),
              (t0 = t(x0)),
              (t1 = t(x1)),
              (k10 = t0 === t1 ? 0 : 1 / (t1 - t0)),
              scale
            );
          }
        );
      }
      function sequential_copy(source, target) {
        return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
      }
      function sequential() {
        var scale = linearish(sequential_transformer()(identity));
        return (
          (scale.copy = function () {
            return sequential_copy(scale, sequential());
          }),
          initInterpolator.apply(scale, arguments)
        );
      }
      function sequentialLog() {
        var scale = loggish(sequential_transformer()).domain([1, 10]);
        return (
          (scale.copy = function () {
            return sequential_copy(scale, sequentialLog()).base(scale.base());
          }),
          initInterpolator.apply(scale, arguments)
        );
      }
      function sequentialSymlog() {
        var scale = symlogish(sequential_transformer());
        return (
          (scale.copy = function () {
            return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());
          }),
          initInterpolator.apply(scale, arguments)
        );
      }
      function sequentialPow() {
        var scale = powish(sequential_transformer());
        return (
          (scale.copy = function () {
            return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());
          }),
          initInterpolator.apply(scale, arguments)
        );
      }
      function sequentialSqrt() {
        return sequentialPow.apply(null, arguments).exponent(0.5);
      }
      function sequentialQuantile() {
        var domain = [],
          interpolator = identity;
        function scale(x) {
          if (null != x && !isNaN((x = +x)))
            return interpolator((bisect(domain, x, 1) - 1) / (domain.length - 1));
        }
        return (
          (scale.domain = function (_) {
            if (!arguments.length) return domain.slice();
            domain = [];
            for (let d of _) null == d || isNaN((d = +d)) || domain.push(d);
            return (domain.sort(ascending), scale);
          }),
          (scale.interpolator = function (_) {
            return arguments.length ? ((interpolator = _), scale) : interpolator;
          }),
          (scale.range = function () {
            return domain.map((d, i) => interpolator(i / (domain.length - 1)));
          }),
          (scale.quantiles = function (n) {
            return Array.from({ length: n + 1 }, (_, i) => quantile(domain, i / n));
          }),
          (scale.copy = function () {
            return sequentialQuantile(interpolator).domain(domain);
          }),
          initInterpolator.apply(scale, arguments)
        );
      }
      function diverging_transformer() {
        var t0,
          t1,
          t2,
          k10,
          k21,
          transform,
          unknown,
          x0 = 0,
          x1 = 0.5,
          x2 = 1,
          s = 1,
          interpolator = identity,
          clamp = !1;
        function scale(x) {
          return isNaN((x = +x))
            ? unknown
            : ((x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21)),
              interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
        }
        function range(interpolate) {
          return function (_) {
            var r0, r1, r2;
            return arguments.length
              ? (([r0, r1, r2] = _),
                (interpolator = (function piecewise(interpolate, values) {
                  void 0 === values && ((values = interpolate), (interpolate = value));
                  for (
                    var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
                    i < n;
                  )
                    I[i] = interpolate(v, (v = values[++i]));
                  return function (t) {
                    var i = Math.max(0, Math.min(n - 1, Math.floor((t *= n))));
                    return I[i](t - i);
                  };
                })(interpolate, [r0, r1, r2])),
                scale)
              : [interpolator(0), interpolator(0.5), interpolator(1)];
          };
        }
        return (
          (scale.domain = function (_) {
            return arguments.length
              ? (([x0, x1, x2] = _),
                (t0 = transform((x0 = +x0))),
                (t1 = transform((x1 = +x1))),
                (t2 = transform((x2 = +x2))),
                (k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0)),
                (k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1)),
                (s = t1 < t0 ? -1 : 1),
                scale)
              : [x0, x1, x2];
          }),
          (scale.clamp = function (_) {
            return arguments.length ? ((clamp = !!_), scale) : clamp;
          }),
          (scale.interpolator = function (_) {
            return arguments.length ? ((interpolator = _), scale) : interpolator;
          }),
          (scale.range = range(value)),
          (scale.rangeRound = range(round)),
          (scale.unknown = function (_) {
            return arguments.length ? ((unknown = _), scale) : unknown;
          }),
          function (t) {
            return (
              (transform = t),
              (t0 = t(x0)),
              (t1 = t(x1)),
              (t2 = t(x2)),
              (k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0)),
              (k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1)),
              (s = t1 < t0 ? -1 : 1),
              scale
            );
          }
        );
      }
      function diverging() {
        var scale = linearish(diverging_transformer()(identity));
        return (
          (scale.copy = function () {
            return sequential_copy(scale, diverging());
          }),
          initInterpolator.apply(scale, arguments)
        );
      }
      function divergingLog() {
        var scale = loggish(diverging_transformer()).domain([0.1, 1, 10]);
        return (
          (scale.copy = function () {
            return sequential_copy(scale, divergingLog()).base(scale.base());
          }),
          initInterpolator.apply(scale, arguments)
        );
      }
      function divergingSymlog() {
        var scale = symlogish(diverging_transformer());
        return (
          (scale.copy = function () {
            return sequential_copy(scale, divergingSymlog()).constant(scale.constant());
          }),
          initInterpolator.apply(scale, arguments)
        );
      }
      function divergingPow() {
        var scale = powish(diverging_transformer());
        return (
          (scale.copy = function () {
            return sequential_copy(scale, divergingPow()).exponent(scale.exponent());
          }),
          initInterpolator.apply(scale, arguments)
        );
      }
      function divergingSqrt() {
        return divergingPow.apply(null, arguments).exponent(0.5);
      }
      !(function defaultLocale_defaultLocale(definition) {
        return (
          (src_defaultLocale_locale = (function formatLocale(locale) {
            var locale_dateTime = locale.dateTime,
              locale_date = locale.date,
              locale_time = locale.time,
              locale_periods = locale.periods,
              locale_weekdays = locale.days,
              locale_shortWeekdays = locale.shortDays,
              locale_months = locale.months,
              locale_shortMonths = locale.shortMonths,
              periodRe = formatRe(locale_periods),
              periodLookup = formatLookup(locale_periods),
              weekdayRe = formatRe(locale_weekdays),
              weekdayLookup = formatLookup(locale_weekdays),
              shortWeekdayRe = formatRe(locale_shortWeekdays),
              shortWeekdayLookup = formatLookup(locale_shortWeekdays),
              monthRe = formatRe(locale_months),
              monthLookup = formatLookup(locale_months),
              shortMonthRe = formatRe(locale_shortMonths),
              shortMonthLookup = formatLookup(locale_shortMonths),
              formats = {
                a: function formatShortWeekday(d) {
                  return locale_shortWeekdays[d.getDay()];
                },
                A: function formatWeekday(d) {
                  return locale_weekdays[d.getDay()];
                },
                b: function formatShortMonth(d) {
                  return locale_shortMonths[d.getMonth()];
                },
                B: function formatMonth(d) {
                  return locale_months[d.getMonth()];
                },
                c: null,
                d: formatDayOfMonth,
                e: formatDayOfMonth,
                f: formatMicroseconds,
                g: formatYearISO,
                G: formatFullYearISO,
                H: formatHour24,
                I: formatHour12,
                j: formatDayOfYear,
                L: formatMilliseconds,
                m: formatMonthNumber,
                M: formatMinutes,
                p: function formatPeriod(d) {
                  return locale_periods[+(d.getHours() >= 12)];
                },
                q: function formatQuarter(d) {
                  return 1 + ~~(d.getMonth() / 3);
                },
                Q: formatUnixTimestamp,
                s: formatUnixTimestampSeconds,
                S: formatSeconds,
                u: formatWeekdayNumberMonday,
                U: formatWeekNumberSunday,
                V: formatWeekNumberISO,
                w: formatWeekdayNumberSunday,
                W: formatWeekNumberMonday,
                x: null,
                X: null,
                y: formatYear,
                Y: formatFullYear,
                Z: formatZone,
                '%': formatLiteralPercent,
              },
              utcFormats = {
                a: function formatUTCShortWeekday(d) {
                  return locale_shortWeekdays[d.getUTCDay()];
                },
                A: function formatUTCWeekday(d) {
                  return locale_weekdays[d.getUTCDay()];
                },
                b: function formatUTCShortMonth(d) {
                  return locale_shortMonths[d.getUTCMonth()];
                },
                B: function formatUTCMonth(d) {
                  return locale_months[d.getUTCMonth()];
                },
                c: null,
                d: formatUTCDayOfMonth,
                e: formatUTCDayOfMonth,
                f: formatUTCMicroseconds,
                g: formatUTCYearISO,
                G: formatUTCFullYearISO,
                H: formatUTCHour24,
                I: formatUTCHour12,
                j: formatUTCDayOfYear,
                L: formatUTCMilliseconds,
                m: formatUTCMonthNumber,
                M: formatUTCMinutes,
                p: function formatUTCPeriod(d) {
                  return locale_periods[+(d.getUTCHours() >= 12)];
                },
                q: function formatUTCQuarter(d) {
                  return 1 + ~~(d.getUTCMonth() / 3);
                },
                Q: formatUnixTimestamp,
                s: formatUnixTimestampSeconds,
                S: formatUTCSeconds,
                u: formatUTCWeekdayNumberMonday,
                U: formatUTCWeekNumberSunday,
                V: formatUTCWeekNumberISO,
                w: formatUTCWeekdayNumberSunday,
                W: formatUTCWeekNumberMonday,
                x: null,
                X: null,
                y: formatUTCYear,
                Y: formatUTCFullYear,
                Z: formatUTCZone,
                '%': formatLiteralPercent,
              },
              parses = {
                a: function parseShortWeekday(d, string, i) {
                  var n = shortWeekdayRe.exec(string.slice(i));
                  return n
                    ? ((d.w = shortWeekdayLookup.get(n[0].toLowerCase())), i + n[0].length)
                    : -1;
                },
                A: function parseWeekday(d, string, i) {
                  var n = weekdayRe.exec(string.slice(i));
                  return n ? ((d.w = weekdayLookup.get(n[0].toLowerCase())), i + n[0].length) : -1;
                },
                b: function parseShortMonth(d, string, i) {
                  var n = shortMonthRe.exec(string.slice(i));
                  return n
                    ? ((d.m = shortMonthLookup.get(n[0].toLowerCase())), i + n[0].length)
                    : -1;
                },
                B: function parseMonth(d, string, i) {
                  var n = monthRe.exec(string.slice(i));
                  return n ? ((d.m = monthLookup.get(n[0].toLowerCase())), i + n[0].length) : -1;
                },
                c: function parseLocaleDateTime(d, string, i) {
                  return parseSpecifier(d, locale_dateTime, string, i);
                },
                d: parseDayOfMonth,
                e: parseDayOfMonth,
                f: parseMicroseconds,
                g: parseYear,
                G: parseFullYear,
                H: parseHour24,
                I: parseHour24,
                j: parseDayOfYear,
                L: parseMilliseconds,
                m: parseMonthNumber,
                M: parseMinutes,
                p: function parsePeriod(d, string, i) {
                  var n = periodRe.exec(string.slice(i));
                  return n ? ((d.p = periodLookup.get(n[0].toLowerCase())), i + n[0].length) : -1;
                },
                q: parseQuarter,
                Q: parseUnixTimestamp,
                s: parseUnixTimestampSeconds,
                S: parseSeconds,
                u: parseWeekdayNumberMonday,
                U: parseWeekNumberSunday,
                V: parseWeekNumberISO,
                w: parseWeekdayNumberSunday,
                W: parseWeekNumberMonday,
                x: function parseLocaleDate(d, string, i) {
                  return parseSpecifier(d, locale_date, string, i);
                },
                X: function parseLocaleTime(d, string, i) {
                  return parseSpecifier(d, locale_time, string, i);
                },
                y: parseYear,
                Y: parseFullYear,
                Z: parseZone,
                '%': parseLiteralPercent,
              };
            function newFormat(specifier, formats) {
              return function (date) {
                var c,
                  pad,
                  format,
                  string = [],
                  i = -1,
                  j = 0,
                  n = specifier.length;
                for (date instanceof Date || (date = new Date(+date)); ++i < n; )
                  37 === specifier.charCodeAt(i) &&
                    (string.push(specifier.slice(j, i)),
                    null != (pad = pads[(c = specifier.charAt(++i))])
                      ? (c = specifier.charAt(++i))
                      : (pad = 'e' === c ? ' ' : '0'),
                    (format = formats[c]) && (c = format(date, pad)),
                    string.push(c),
                    (j = i + 1));
                return (string.push(specifier.slice(j, i)), string.join(''));
              };
            }
            function newParse(specifier, Z) {
              return function (string) {
                var week,
                  day,
                  d = newDate(1900, void 0, 1);
                if (parseSpecifier(d, specifier, (string += ''), 0) != string.length) return null;
                if ('Q' in d) return new Date(d.Q);
                if ('s' in d) return new Date(1e3 * d.s + ('L' in d ? d.L : 0));
                if (
                  (Z && !('Z' in d) && (d.Z = 0),
                  'p' in d && (d.H = (d.H % 12) + 12 * d.p),
                  void 0 === d.m && (d.m = 'q' in d ? d.q : 0),
                  'V' in d)
                ) {
                  if (d.V < 1 || d.V > 53) return null;
                  ('w' in d || (d.w = 1),
                    'Z' in d
                      ? ((day = (week = utcDate(newDate(d.y, 0, 1))).getUTCDay()),
                        (week = day > 4 || 0 === day ? utcMonday.ceil(week) : utcMonday(week)),
                        (week = utcDay.offset(week, 7 * (d.V - 1))),
                        (d.y = week.getUTCFullYear()),
                        (d.m = week.getUTCMonth()),
                        (d.d = week.getUTCDate() + ((d.w + 6) % 7)))
                      : ((day = (week = localDate(newDate(d.y, 0, 1))).getDay()),
                        (week = day > 4 || 0 === day ? timeMonday.ceil(week) : timeMonday(week)),
                        (week = timeDay.offset(week, 7 * (d.V - 1))),
                        (d.y = week.getFullYear()),
                        (d.m = week.getMonth()),
                        (d.d = week.getDate() + ((d.w + 6) % 7))));
                } else
                  ('W' in d || 'U' in d) &&
                    ('w' in d || (d.w = 'u' in d ? d.u % 7 : 'W' in d ? 1 : 0),
                    (day =
                      'Z' in d
                        ? utcDate(newDate(d.y, 0, 1)).getUTCDay()
                        : localDate(newDate(d.y, 0, 1)).getDay()),
                    (d.m = 0),
                    (d.d =
                      'W' in d
                        ? ((d.w + 6) % 7) + 7 * d.W - ((day + 5) % 7)
                        : d.w + 7 * d.U - ((day + 6) % 7)));
                return 'Z' in d
                  ? ((d.H += (d.Z / 100) | 0), (d.M += d.Z % 100), utcDate(d))
                  : localDate(d);
              };
            }
            function parseSpecifier(d, specifier, string, j) {
              for (var c, parse, i = 0, n = specifier.length, m = string.length; i < n; ) {
                if (j >= m) return -1;
                if (37 === (c = specifier.charCodeAt(i++))) {
                  if (
                    ((c = specifier.charAt(i++)),
                    !(parse = parses[c in pads ? specifier.charAt(i++) : c]) ||
                      (j = parse(d, string, j)) < 0)
                  )
                    return -1;
                } else if (c != string.charCodeAt(j++)) return -1;
              }
              return j;
            }
            return (
              (formats.x = newFormat(locale_date, formats)),
              (formats.X = newFormat(locale_time, formats)),
              (formats.c = newFormat(locale_dateTime, formats)),
              (utcFormats.x = newFormat(locale_date, utcFormats)),
              (utcFormats.X = newFormat(locale_time, utcFormats)),
              (utcFormats.c = newFormat(locale_dateTime, utcFormats)),
              {
                format: function (specifier) {
                  var f = newFormat((specifier += ''), formats);
                  return (
                    (f.toString = function () {
                      return specifier;
                    }),
                    f
                  );
                },
                parse: function (specifier) {
                  var p = newParse((specifier += ''), !1);
                  return (
                    (p.toString = function () {
                      return specifier;
                    }),
                    p
                  );
                },
                utcFormat: function (specifier) {
                  var f = newFormat((specifier += ''), utcFormats);
                  return (
                    (f.toString = function () {
                      return specifier;
                    }),
                    f
                  );
                },
                utcParse: function (specifier) {
                  var p = newParse((specifier += ''), !0);
                  return (
                    (p.toString = function () {
                      return specifier;
                    }),
                    p
                  );
                },
              }
            );
          })(definition)),
          (timeFormat = src_defaultLocale_locale.format),
          src_defaultLocale_locale.parse,
          (utcFormat = src_defaultLocale_locale.utcFormat),
          src_defaultLocale_locale.utcParse,
          src_defaultLocale_locale
        );
      })({
        dateTime: '%x, %X',
        date: '%-m/%-d/%Y',
        time: '%-I:%M:%S %p',
        periods: ['AM', 'PM'],
        days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        months: [
          'January',
          'February',
          'March',
          'April',
          'May',
          'June',
          'July',
          'August',
          'September',
          'October',
          'November',
          'December',
        ],
        shortMonths: [
          'Jan',
          'Feb',
          'Mar',
          'Apr',
          'May',
          'Jun',
          'Jul',
          'Aug',
          'Sep',
          'Oct',
          'Nov',
          'Dec',
        ],
      });
      var fn,
        chartLayoutContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        ChartUtils = __webpack_require__('./node_modules/recharts/es6/util/ChartUtils.js'),
        dataSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/dataSelectors.js'
        ),
        isDomainSpecifiedByUser = __webpack_require__(
          './node_modules/recharts/es6/util/isDomainSpecifiedByUser.js'
        ),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        isWellBehavedNumber = __webpack_require__(
          './node_modules/recharts/es6/util/isWellBehavedNumber.js'
        ),
        decimal = __webpack_require__('./node_modules/decimal.js-light/decimal.js'),
        decimal_default = __webpack_require__.n(decimal),
        utils_identity = (i) => i,
        PLACE_HOLDER = { '@@functional/placeholder': !0 },
        isPlaceHolder = (val) => val === PLACE_HOLDER,
        curry0 = (fn) =>
          function _curried() {
            return 0 === arguments.length ||
              (1 === arguments.length &&
                isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0]))
              ? _curried
              : fn(...arguments);
          },
        curryN = (n, fn) =>
          1 === n
            ? fn
            : curry0(function () {
                for (
                  var _len = arguments.length, args = new Array(_len), _key = 0;
                  _key < _len;
                  _key++
                )
                  args[_key] = arguments[_key];
                var argsLength = args.filter((arg) => arg !== PLACE_HOLDER).length;
                return argsLength >= n
                  ? fn(...args)
                  : curryN(
                      n - argsLength,
                      curry0(function () {
                        for (
                          var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0;
                          _key2 < _len2;
                          _key2++
                        )
                          restArgs[_key2] = arguments[_key2];
                        var newArgs = args.map((arg) =>
                          isPlaceHolder(arg) ? restArgs.shift() : arg
                        );
                        return fn(...newArgs, ...restArgs);
                      })
                    );
              }),
        utils_range = (begin, end) => {
          for (var arr = [], i = begin; i < end; ++i) arr[i - begin] = i;
          return arr;
        },
        utils_map = curryN(
          (fn = (fn, arr) =>
            Array.isArray(arr)
              ? arr.map(fn)
              : Object.keys(arr)
                  .map((key) => arr[key])
                  .map(fn)).length,
          fn
        );
      function getDigitCount(value) {
        return 0 === value
          ? 1
          : Math.floor(new (decimal_default())(value).abs().log(10).toNumber()) + 1;
      }
      function rangeStep(start, end, step) {
        for (var num = new (decimal_default())(start), i = 0, result = []; num.lt(end) && i < 1e5; )
          (result.push(num.toNumber()), (num = num.add(step)), i++);
        return result;
      }
      var getValidInterval = (_ref) => {
          var [min, max] = _ref,
            [validMin, validMax] = [min, max];
          return (min > max && ([validMin, validMax] = [max, min]), [validMin, validMax]);
        },
        getFormatStep = (roughStep, allowDecimals, correctionFactor) => {
          if (roughStep.lte(0)) return new (decimal_default())(0);
          var digitCount = getDigitCount(roughStep.toNumber()),
            digitCountValue = new (decimal_default())(10).pow(digitCount),
            stepRatio = roughStep.div(digitCountValue),
            stepRatioScale = 1 !== digitCount ? 0.05 : 0.1,
            formatStep = new (decimal_default())(
              Math.ceil(stepRatio.div(stepRatioScale).toNumber())
            )
              .add(correctionFactor)
              .mul(stepRatioScale)
              .mul(digitCountValue);
          return allowDecimals
            ? new (decimal_default())(formatStep.toNumber())
            : new (decimal_default())(Math.ceil(formatStep.toNumber()));
        },
        getTickOfSingleValue = (value, tickCount, allowDecimals) => {
          var step = new (decimal_default())(1),
            middle = new (decimal_default())(value);
          if (!middle.isint() && allowDecimals) {
            var absVal = Math.abs(value);
            absVal < 1
              ? ((step = new (decimal_default())(10).pow(getDigitCount(value) - 1)),
                (middle = new (decimal_default())(Math.floor(middle.div(step).toNumber())).mul(
                  step
                )))
              : absVal > 1 && (middle = new (decimal_default())(Math.floor(value)));
          } else
            0 === value
              ? (middle = new (decimal_default())(Math.floor((tickCount - 1) / 2)))
              : allowDecimals || (middle = new (decimal_default())(Math.floor(value)));
          var middleIndex = Math.floor((tickCount - 1) / 2),
            fn = (function compose() {
              for (
                var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;
                _key3 < _len3;
                _key3++
              )
                args[_key3] = arguments[_key3];
              if (!args.length) return utils_identity;
              var fns = args.reverse(),
                firstFn = fns[0],
                tailsFn = fns.slice(1);
              return function () {
                return tailsFn.reduce((res, fn) => fn(res), firstFn(...arguments));
              };
            })(
              utils_map((n) =>
                middle.add(new (decimal_default())(n - middleIndex).mul(step)).toNumber()
              ),
              utils_range
            );
          return fn(0, tickCount);
        },
        _calculateStep = function calculateStep(min, max, tickCount, allowDecimals) {
          var correctionFactor = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
          if (!Number.isFinite((max - min) / (tickCount - 1)))
            return {
              step: new (decimal_default())(0),
              tickMin: new (decimal_default())(0),
              tickMax: new (decimal_default())(0),
            };
          var middle,
            step = getFormatStep(
              new (decimal_default())(max).sub(min).div(tickCount - 1),
              allowDecimals,
              correctionFactor
            );
          middle =
            min <= 0 && max >= 0
              ? new (decimal_default())(0)
              : (middle = new (decimal_default())(min).add(max).div(2)).sub(
                  new (decimal_default())(middle).mod(step)
                );
          var belowCount = Math.ceil(middle.sub(min).div(step).toNumber()),
            upCount = Math.ceil(new (decimal_default())(max).sub(middle).div(step).toNumber()),
            scaleCount = belowCount + upCount + 1;
          return scaleCount > tickCount
            ? _calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1)
            : (scaleCount < tickCount &&
                ((upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount),
                (belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount))),
              {
                step,
                tickMin: middle.sub(new (decimal_default())(belowCount).mul(step)),
                tickMax: middle.add(new (decimal_default())(upCount).mul(step)),
              });
        },
        containerSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/containerSelectors.js'
        ),
        selectAllAxes = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectAllAxes.js'
        ),
        selectChartOffsetInternal = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
        ),
        brushSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/brushSelectors.js'
        ),
        rootPropsSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/rootPropsSelectors.js'
        ),
        polarAxisSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/polarAxisSelectors.js'
        ),
        pickAxisType = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/pickAxisType.js'
        ),
        pickAxisId = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/pickAxisId.js'
        ),
        combineAxisRangeWithReverse = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineAxisRangeWithReverse.js'
        ),
        Constants = __webpack_require__('./node_modules/recharts/es6/util/Constants.js'),
        getStackSeriesIdentifier = __webpack_require__(
          './node_modules/recharts/es6/util/stacks/getStackSeriesIdentifier.js'
        ),
        combineDisplayedStackedData = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineDisplayedStackedData.js'
        ),
        StackedGraphicalItem = __webpack_require__(
          './node_modules/recharts/es6/state/types/StackedGraphicalItem.js'
        ),
        numberDomainEqualityCheck = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/numberDomainEqualityCheck.js'
        ),
        arrayEqualityCheck = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/arrayEqualityCheck.js'
        ),
        selectTooltipAxisType = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipAxisType.js'
        ),
        selectTooltipAxisId = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipAxisId.js'
        );
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var defaultNumericDomain = [0, 'auto'],
        implicitXAxis = {
          allowDataOverflow: !1,
          allowDecimals: !0,
          allowDuplicatedCategory: !0,
          angle: 0,
          dataKey: void 0,
          domain: void 0,
          height: 30,
          hide: !0,
          id: 0,
          includeHidden: !1,
          interval: 'preserveEnd',
          minTickGap: 5,
          mirror: !1,
          name: void 0,
          orientation: 'bottom',
          padding: { left: 0, right: 0 },
          reversed: !1,
          scale: 'auto',
          tick: !0,
          tickCount: 5,
          tickFormatter: void 0,
          ticks: void 0,
          type: 'category',
          unit: void 0,
        },
        selectXAxisSettingsNoDefaults = (state, axisId) => state.cartesianAxis.xAxis[axisId],
        selectXAxisSettings = (state, axisId) => {
          var axis = selectXAxisSettingsNoDefaults(state, axisId);
          return null == axis ? implicitXAxis : axis;
        },
        implicitYAxis = {
          allowDataOverflow: !1,
          allowDecimals: !0,
          allowDuplicatedCategory: !0,
          angle: 0,
          dataKey: void 0,
          domain: defaultNumericDomain,
          hide: !0,
          id: 0,
          includeHidden: !1,
          interval: 'preserveEnd',
          minTickGap: 5,
          mirror: !1,
          name: void 0,
          orientation: 'left',
          padding: { top: 0, bottom: 0 },
          reversed: !1,
          scale: 'auto',
          tick: !0,
          tickCount: 5,
          tickFormatter: void 0,
          ticks: void 0,
          type: 'number',
          unit: void 0,
          width: Constants.tQ,
        },
        selectYAxisSettingsNoDefaults = (state, axisId) => state.cartesianAxis.yAxis[axisId],
        selectYAxisSettings = (state, axisId) => {
          var axis = selectYAxisSettingsNoDefaults(state, axisId);
          return null == axis ? implicitYAxis : axis;
        },
        implicitZAxis = {
          domain: [0, 'auto'],
          includeHidden: !1,
          reversed: !1,
          allowDataOverflow: !1,
          allowDuplicatedCategory: !1,
          dataKey: void 0,
          id: 0,
          name: '',
          range: [64, 64],
          scale: 'auto',
          type: 'number',
          unit: '',
        },
        selectZAxisSettings = (state, axisId) => {
          var axis = state.cartesianAxis.zAxis[axisId];
          return null == axis ? implicitZAxis : axis;
        },
        selectBaseAxis = (state, axisType, axisId) => {
          switch (axisType) {
            case 'xAxis':
              return selectXAxisSettings(state, axisId);
            case 'yAxis':
              return selectYAxisSettings(state, axisId);
            case 'zAxis':
              return selectZAxisSettings(state, axisId);
            case 'angleAxis':
              return (0, polarAxisSelectors.Be)(state, axisId);
            case 'radiusAxis':
              return (0, polarAxisSelectors.Gl)(state, axisId);
            default:
              throw new Error('Unexpected axis type: '.concat(axisType));
          }
        },
        selectAxisSettings = (state, axisType, axisId) => {
          switch (axisType) {
            case 'xAxis':
              return selectXAxisSettings(state, axisId);
            case 'yAxis':
              return selectYAxisSettings(state, axisId);
            case 'angleAxis':
              return (0, polarAxisSelectors.Be)(state, axisId);
            case 'radiusAxis':
              return (0, polarAxisSelectors.Gl)(state, axisId);
            default:
              throw new Error('Unexpected axis type: '.concat(axisType));
          }
        },
        selectHasBar = (state) =>
          state.graphicalItems.cartesianItems.some((item) => 'bar' === item.type) ||
          state.graphicalItems.polarItems.some((item) => 'radialBar' === item.type);
      function itemAxisPredicate(axisType, axisId) {
        return (item) => {
          switch (axisType) {
            case 'xAxis':
              return 'xAxisId' in item && item.xAxisId === axisId;
            case 'yAxis':
              return 'yAxisId' in item && item.yAxisId === axisId;
            case 'zAxis':
              return 'zAxisId' in item && item.zAxisId === axisId;
            case 'angleAxis':
              return 'angleAxisId' in item && item.angleAxisId === axisId;
            case 'radiusAxis':
              return 'radiusAxisId' in item && item.radiusAxisId === axisId;
            default:
              return !1;
          }
        };
      }
      var selectUnfilteredCartesianItems = (state) => state.graphicalItems.cartesianItems,
        selectAxisPredicate = (0, reselect.Mz)([pickAxisType.N, pickAxisId.E], itemAxisPredicate),
        combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) =>
          graphicalItems
            .filter(axisPredicate)
            .filter(
              (item) =>
                !0 === (null == axisSettings ? void 0 : axisSettings.includeHidden) || !item.hide
            ),
        selectCartesianItemsSettings = (0, reselect.Mz)(
          [selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate],
          combineGraphicalItemsSettings,
          { memoizeOptions: { resultEqualityCheck: arrayEqualityCheck.O } }
        ),
        selectStackedCartesianItemsSettings = (0, reselect.Mz)(
          [selectCartesianItemsSettings],
          (cartesianItems) =>
            cartesianItems
              .filter((item) => 'area' === item.type || 'bar' === item.type)
              .filter(StackedGraphicalItem.g)
        ),
        filterGraphicalNotStackedItems = (cartesianItems) =>
          cartesianItems.filter((item) => !('stackId' in item) || void 0 === item.stackId),
        selectCartesianItemsSettingsExceptStacked = (0, reselect.Mz)(
          [selectCartesianItemsSettings],
          filterGraphicalNotStackedItems
        ),
        combineGraphicalItemsData = (cartesianItems) =>
          cartesianItems
            .map((item) => item.data)
            .filter(Boolean)
            .flat(1),
        selectCartesianGraphicalItemsData = (0, reselect.Mz)(
          [selectCartesianItemsSettings],
          combineGraphicalItemsData,
          { memoizeOptions: { resultEqualityCheck: arrayEqualityCheck.O } }
        ),
        combineDisplayedData = (graphicalItemsData, _ref) => {
          var { chartData = [], dataStartIndex, dataEndIndex } = _ref;
          return graphicalItemsData.length > 0
            ? graphicalItemsData
            : chartData.slice(dataStartIndex, dataEndIndex + 1);
        },
        selectDisplayedData = (0, reselect.Mz)(
          [selectCartesianGraphicalItemsData, dataSelectors.k$],
          combineDisplayedData
        ),
        combineAppliedValues = (data, axisSettings, items) =>
          null != (null == axisSettings ? void 0 : axisSettings.dataKey)
            ? data.map((item) => ({ value: (0, ChartUtils.kr)(item, axisSettings.dataKey) }))
            : items.length > 0
              ? items
                  .map((item) => item.dataKey)
                  .flatMap((dataKey) =>
                    data.map((entry) => ({ value: (0, ChartUtils.kr)(entry, dataKey) }))
                  )
              : data.map((entry) => ({ value: entry })),
        selectAllAppliedValues = (0, reselect.Mz)(
          [selectDisplayedData, selectBaseAxis, selectCartesianItemsSettings],
          combineAppliedValues
        );
      function isErrorBarRelevantForAxisType(axisType, errorBar) {
        switch (axisType) {
          case 'xAxis':
            return 'x' === errorBar.direction;
          case 'yAxis':
            return 'y' === errorBar.direction;
          default:
            return !1;
        }
      }
      function makeNumber(val) {
        if ((0, DataUtils.vh)(val) || val instanceof Date) {
          var n = Number(val);
          if ((0, isWellBehavedNumber.H)(n)) return n;
        }
      }
      function makeDomain(val) {
        if (Array.isArray(val)) {
          var attempt = [makeNumber(val[0]), makeNumber(val[1])];
          return (0, isDomainSpecifiedByUser.JH)(attempt) ? attempt : void 0;
        }
        var n = makeNumber(val);
        if (null != n) return [n, n];
      }
      function onlyAllowNumbers(data) {
        return data.map(makeNumber).filter(DataUtils.n9);
      }
      var selectTooltipAxis = (state) => {
          var axisType = (0, selectTooltipAxisType.R)(state),
            axisId = (0, selectTooltipAxisId.M)(state);
          return selectAxisSettings(state, axisType, axisId);
        },
        selectTooltipAxisDataKey = (0, reselect.Mz)([selectTooltipAxis], (axis) =>
          null == axis ? void 0 : axis.dataKey
        ),
        selectDisplayedStackedData = (0, reselect.Mz)(
          [selectStackedCartesianItemsSettings, dataSelectors.k$, selectTooltipAxis],
          combineDisplayedStackedData.A
        ),
        combineStackGroups = (displayedData, items, stackOffsetType, reverseStackOrder) => {
          var itemsGroup = items.reduce((acc, item) => {
            if (null == item.stackId) return acc;
            var stack = acc[item.stackId];
            return (
              null == stack && (stack = []),
              stack.push(item),
              (acc[item.stackId] = stack),
              acc
            );
          }, {});
          return Object.fromEntries(
            Object.entries(itemsGroup).map((_ref2) => {
              var [stackId, graphicalItems] = _ref2,
                orderedGraphicalItems = reverseStackOrder
                  ? [...graphicalItems].reverse()
                  : graphicalItems,
                dataKeys = orderedGraphicalItems.map(getStackSeriesIdentifier.x);
              return [
                stackId,
                {
                  stackedData: (0, ChartUtils.yy)(displayedData, dataKeys, stackOffsetType),
                  graphicalItems: orderedGraphicalItems,
                },
              ];
            })
          );
        },
        selectStackGroups = (0, reselect.Mz)(
          [
            selectDisplayedStackedData,
            selectStackedCartesianItemsSettings,
            rootPropsSelectors.eC,
            rootPropsSelectors.Lb,
          ],
          combineStackGroups
        ),
        combineDomainOfStackGroups = (stackGroups, _ref3, axisType, domainFromUserPreference) => {
          var { dataStartIndex, dataEndIndex } = _ref3;
          if (null == domainFromUserPreference && 'zAxis' !== axisType) {
            var domainOfStackGroups = (0, ChartUtils.Mk)(stackGroups, dataStartIndex, dataEndIndex);
            if (
              null == domainOfStackGroups ||
              0 !== domainOfStackGroups[0] ||
              0 !== domainOfStackGroups[1]
            )
              return domainOfStackGroups;
          }
        },
        selectAllowsDataOverflow = (0, reselect.Mz)(
          [selectBaseAxis],
          (axisSettings) => axisSettings.allowDataOverflow
        ),
        getDomainDefinition = (axisSettings) => {
          var _axisSettings$domain;
          if (null == axisSettings || !('domain' in axisSettings)) return defaultNumericDomain;
          if (null != axisSettings.domain) return axisSettings.domain;
          if ('ticks' in axisSettings && null != axisSettings.ticks) {
            if ('number' === axisSettings.type) {
              var allValues = onlyAllowNumbers(axisSettings.ticks);
              return [Math.min(...allValues), Math.max(...allValues)];
            }
            if ('category' === axisSettings.type) return axisSettings.ticks.map(String);
          }
          return null !==
            (_axisSettings$domain = null == axisSettings ? void 0 : axisSettings.domain) &&
            void 0 !== _axisSettings$domain
            ? _axisSettings$domain
            : defaultNumericDomain;
        },
        selectDomainDefinition = (0, reselect.Mz)([selectBaseAxis], getDomainDefinition),
        selectDomainFromUserPreference = (0, reselect.Mz)(
          [selectDomainDefinition, selectAllowsDataOverflow],
          isDomainSpecifiedByUser.f5
        ),
        selectDomainOfStackGroups = (0, reselect.Mz)(
          [selectStackGroups, dataSelectors.LF, pickAxisType.N, selectDomainFromUserPreference],
          combineDomainOfStackGroups,
          { memoizeOptions: { resultEqualityCheck: numberDomainEqualityCheck.o } }
        ),
        selectAllErrorBarSettings = (state) => state.errorBars,
        mergeDomains = function mergeDomains() {
          for (
            var _len = arguments.length, domains = new Array(_len), _key = 0;
            _key < _len;
            _key++
          )
            domains[_key] = arguments[_key];
          var allDomains = domains.filter(Boolean);
          if (0 !== allDomains.length) {
            var allValues = allDomains.flat();
            return [Math.min(...allValues), Math.max(...allValues)];
          }
        },
        combineDomainOfAllAppliedNumericalValuesIncludingErrorValues = (
          data,
          axisSettings,
          items,
          errorBars,
          axisType
        ) => {
          var lowerEnd, upperEnd;
          if (
            (items.length > 0 &&
              data.forEach((entry) => {
                items.forEach((item) => {
                  var _errorBars$item$id,
                    _axisSettings$dataKey,
                    relevantErrorBars =
                      null === (_errorBars$item$id = errorBars[item.id]) ||
                      void 0 === _errorBars$item$id
                        ? void 0
                        : _errorBars$item$id.filter((errorBar) =>
                            isErrorBarRelevantForAxisType(axisType, errorBar)
                          ),
                    valueByDataKey = (0, ChartUtils.kr)(
                      entry,
                      null !== (_axisSettings$dataKey = axisSettings.dataKey) &&
                        void 0 !== _axisSettings$dataKey
                        ? _axisSettings$dataKey
                        : item.dataKey
                    ),
                    errorDomain = (function getErrorDomainByDataKey(
                      entry,
                      appliedValue,
                      relevantErrorBars
                    ) {
                      return !relevantErrorBars ||
                        'number' != typeof appliedValue ||
                        (0, DataUtils.M8)(appliedValue)
                        ? []
                        : relevantErrorBars.length
                          ? onlyAllowNumbers(
                              relevantErrorBars.flatMap((eb) => {
                                var lowBound,
                                  highBound,
                                  errorValue = (0, ChartUtils.kr)(entry, eb.dataKey);
                                if (
                                  (Array.isArray(errorValue)
                                    ? ([lowBound, highBound] = errorValue)
                                    : (lowBound = highBound = errorValue),
                                  (0, isWellBehavedNumber.H)(lowBound) &&
                                    (0, isWellBehavedNumber.H)(highBound))
                                )
                                  return [appliedValue - lowBound, appliedValue + highBound];
                              })
                            )
                          : [];
                    })(entry, valueByDataKey, relevantErrorBars);
                  if (errorDomain.length >= 2) {
                    var localLower = Math.min(...errorDomain),
                      localUpper = Math.max(...errorDomain);
                    ((null == lowerEnd || localLower < lowerEnd) && (lowerEnd = localLower),
                      (null == upperEnd || localUpper > upperEnd) && (upperEnd = localUpper));
                  }
                  var dataValueDomain = makeDomain(valueByDataKey);
                  null != dataValueDomain &&
                    ((lowerEnd =
                      null == lowerEnd
                        ? dataValueDomain[0]
                        : Math.min(lowerEnd, dataValueDomain[0])),
                    (upperEnd =
                      null == upperEnd
                        ? dataValueDomain[1]
                        : Math.max(upperEnd, dataValueDomain[1])));
                });
              }),
            null != (null == axisSettings ? void 0 : axisSettings.dataKey) &&
              data.forEach((item) => {
                var dataValueDomain = makeDomain((0, ChartUtils.kr)(item, axisSettings.dataKey));
                null != dataValueDomain &&
                  ((lowerEnd =
                    null == lowerEnd ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0])),
                  (upperEnd =
                    null == upperEnd
                      ? dataValueDomain[1]
                      : Math.max(upperEnd, dataValueDomain[1])));
              }),
            (0, isWellBehavedNumber.H)(lowerEnd) && (0, isWellBehavedNumber.H)(upperEnd))
          )
            return [lowerEnd, upperEnd];
        },
        selectDomainOfAllAppliedNumericalValuesIncludingErrorValues = (0, reselect.Mz)(
          [
            selectDisplayedData,
            selectBaseAxis,
            selectCartesianItemsSettingsExceptStacked,
            selectAllErrorBarSettings,
            pickAxisType.N,
          ],
          combineDomainOfAllAppliedNumericalValuesIncludingErrorValues,
          { memoizeOptions: { resultEqualityCheck: numberDomainEqualityCheck.o } }
        );
      function onlyAllowNumbersAndStringsAndDates(item) {
        var { value } = item;
        if ((0, DataUtils.vh)(value) || value instanceof Date) return value;
      }
      var selectReferenceDots = (state) => state.referenceElements.dots,
        filterReferenceElements = (elements, axisType, axisId) =>
          elements
            .filter((el) => 'extendDomain' === el.ifOverflow)
            .filter((el) => ('xAxis' === axisType ? el.xAxisId === axisId : el.yAxisId === axisId)),
        selectReferenceDotsByAxis = (0, reselect.Mz)(
          [selectReferenceDots, pickAxisType.N, pickAxisId.E],
          filterReferenceElements
        ),
        selectReferenceAreas = (state) => state.referenceElements.areas,
        selectReferenceAreasByAxis = (0, reselect.Mz)(
          [selectReferenceAreas, pickAxisType.N, pickAxisId.E],
          filterReferenceElements
        ),
        selectReferenceLines = (state) => state.referenceElements.lines,
        selectReferenceLinesByAxis = (0, reselect.Mz)(
          [selectReferenceLines, pickAxisType.N, pickAxisId.E],
          filterReferenceElements
        ),
        combineDotsDomain = (dots, axisType) => {
          if (null != dots) {
            var allCoords = onlyAllowNumbers(
              dots.map((dot) => ('xAxis' === axisType ? dot.x : dot.y))
            );
            if (0 !== allCoords.length) return [Math.min(...allCoords), Math.max(...allCoords)];
          }
        },
        selectReferenceDotsDomain = (0, reselect.Mz)(
          selectReferenceDotsByAxis,
          pickAxisType.N,
          combineDotsDomain
        ),
        combineAreasDomain = (areas, axisType) => {
          if (null != areas) {
            var allCoords = onlyAllowNumbers(
              areas.flatMap((area) => [
                'xAxis' === axisType ? area.x1 : area.y1,
                'xAxis' === axisType ? area.x2 : area.y2,
              ])
            );
            if (0 !== allCoords.length) return [Math.min(...allCoords), Math.max(...allCoords)];
          }
        },
        selectReferenceAreasDomain = (0, reselect.Mz)(
          [selectReferenceAreasByAxis, pickAxisType.N],
          combineAreasDomain
        );
      var combineLinesDomain = (lines, axisType) => {
          if (null != lines) {
            var allCoords = lines.flatMap((line) =>
              'xAxis' === axisType
                ? (function extractXCoordinates(line) {
                    var _line$segment;
                    if (null != line.x) return onlyAllowNumbers([line.x]);
                    var segmentCoordinates =
                      null === (_line$segment = line.segment) || void 0 === _line$segment
                        ? void 0
                        : _line$segment.map((s) => s.x);
                    return null == segmentCoordinates || 0 === segmentCoordinates.length
                      ? []
                      : onlyAllowNumbers(segmentCoordinates);
                  })(line)
                : (function extractYCoordinates(line) {
                    var _line$segment2;
                    if (null != line.y) return onlyAllowNumbers([line.y]);
                    var segmentCoordinates =
                      null === (_line$segment2 = line.segment) || void 0 === _line$segment2
                        ? void 0
                        : _line$segment2.map((s) => s.y);
                    return null == segmentCoordinates || 0 === segmentCoordinates.length
                      ? []
                      : onlyAllowNumbers(segmentCoordinates);
                  })(line)
            );
            if (0 !== allCoords.length) return [Math.min(...allCoords), Math.max(...allCoords)];
          }
        },
        selectReferenceLinesDomain = (0, reselect.Mz)(
          [selectReferenceLinesByAxis, pickAxisType.N],
          combineLinesDomain
        ),
        selectReferenceElementsDomain = (0, reselect.Mz)(
          selectReferenceDotsDomain,
          selectReferenceLinesDomain,
          selectReferenceAreasDomain,
          (dotsDomain, linesDomain, areasDomain) =>
            mergeDomains(dotsDomain, areasDomain, linesDomain)
        ),
        combineNumericalDomain = (
          axisSettings,
          domainDefinition,
          domainFromUserPreference,
          domainOfStackGroups,
          dataAndErrorBarsDomain,
          referenceElementsDomain,
          layout,
          axisType
        ) => {
          if (null != domainFromUserPreference) return domainFromUserPreference;
          var mergedDomains =
            ('vertical' === layout && 'xAxis' === axisType) ||
            ('horizontal' === layout && 'yAxis' === axisType)
              ? mergeDomains(domainOfStackGroups, referenceElementsDomain, dataAndErrorBarsDomain)
              : mergeDomains(referenceElementsDomain, dataAndErrorBarsDomain);
          return (0, isDomainSpecifiedByUser.v1)(
            domainDefinition,
            mergedDomains,
            axisSettings.allowDataOverflow
          );
        },
        selectNumericalDomain = (0, reselect.Mz)(
          [
            selectBaseAxis,
            selectDomainDefinition,
            selectDomainFromUserPreference,
            selectDomainOfStackGroups,
            selectDomainOfAllAppliedNumericalValuesIncludingErrorValues,
            selectReferenceElementsDomain,
            chartLayoutContext.fz,
            pickAxisType.N,
          ],
          combineNumericalDomain,
          { memoizeOptions: { resultEqualityCheck: numberDomainEqualityCheck.o } }
        ),
        expandDomain = [0, 1],
        combineAxisDomain = (
          axisSettings,
          layout,
          displayedData,
          allAppliedValues,
          stackOffsetType,
          axisType,
          numericalDomain
        ) => {
          if (
            (null != axisSettings && null != displayedData && 0 !== displayedData.length) ||
            void 0 !== numericalDomain
          ) {
            var _displayedData$length,
              { dataKey, type } = axisSettings,
              isCategorical = (0, ChartUtils._L)(layout, axisType);
            return isCategorical && null == dataKey
              ? range_default()(
                  0,
                  null !==
                    (_displayedData$length =
                      null == displayedData ? void 0 : displayedData.length) &&
                    void 0 !== _displayedData$length
                    ? _displayedData$length
                    : 0
                )
              : 'category' === type
                ? ((allDataSquished, axisSettings, isCategorical) => {
                    var categoricalDomain = allDataSquished
                      .map(onlyAllowNumbersAndStringsAndDates)
                      .filter((v) => null != v);
                    return isCategorical &&
                      (null == axisSettings.dataKey ||
                        (axisSettings.allowDuplicatedCategory &&
                          (0, DataUtils.CG)(categoricalDomain)))
                      ? range_default()(0, allDataSquished.length)
                      : axisSettings.allowDuplicatedCategory
                        ? categoricalDomain
                        : Array.from(new Set(categoricalDomain));
                  })(allAppliedValues, axisSettings, isCategorical)
                : 'expand' === stackOffsetType
                  ? expandDomain
                  : numericalDomain;
          }
        },
        selectAxisDomain = (0, reselect.Mz)(
          [
            selectBaseAxis,
            chartLayoutContext.fz,
            selectDisplayedData,
            selectAllAppliedValues,
            rootPropsSelectors.eC,
            pickAxisType.N,
            selectNumericalDomain,
          ],
          combineAxisDomain
        ),
        combineRealScaleType = (axisConfig, layout, hasBar, chartType, axisType) => {
          if (null != axisConfig) {
            var { scale, type } = axisConfig;
            if ('auto' === scale)
              return 'radial' === layout && 'radiusAxis' === axisType
                ? 'band'
                : 'radial' === layout && 'angleAxis' === axisType
                  ? 'linear'
                  : 'category' === type &&
                      chartType &&
                      (chartType.indexOf('LineChart') >= 0 ||
                        chartType.indexOf('AreaChart') >= 0 ||
                        (chartType.indexOf('ComposedChart') >= 0 && !hasBar))
                    ? 'point'
                    : 'category' === type
                      ? 'band'
                      : 'linear';
            if ('string' == typeof scale) {
              var name = 'scale'.concat((0, DataUtils.Zb)(scale));
              return name in d3_scale_namespaceObject ? name : 'point';
            }
          }
        },
        selectRealScaleType = (0, reselect.Mz)(
          [
            selectBaseAxis,
            chartLayoutContext.fz,
            selectHasBar,
            rootPropsSelectors.iO,
            pickAxisType.N,
          ],
          combineRealScaleType
        );
      function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {
        if (null != axisDomain && null != axisRange) {
          if ('function' == typeof axis.scale)
            return axis.scale.copy().domain(axisDomain).range(axisRange);
          var d3ScaleFunction = (function getD3ScaleFromType(realScaleType) {
            if (null != realScaleType) {
              if (realScaleType in d3_scale_namespaceObject)
                return d3_scale_namespaceObject[realScaleType]();
              var name = 'scale'.concat((0, DataUtils.Zb)(realScaleType));
              return name in d3_scale_namespaceObject ? d3_scale_namespaceObject[name]() : void 0;
            }
          })(realScaleType);
          if (null != d3ScaleFunction) {
            var scale = d3ScaleFunction.domain(axisDomain).range(axisRange);
            return ((0, ChartUtils.YB)(scale), scale);
          }
        }
      }
      var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {
          var domainDefinition = getDomainDefinition(axisSettings);
          if ('auto' === realScaleType || 'linear' === realScaleType)
            return null != axisSettings &&
              axisSettings.tickCount &&
              Array.isArray(domainDefinition) &&
              ('auto' === domainDefinition[0] || 'auto' === domainDefinition[1]) &&
              (0, isDomainSpecifiedByUser.JH)(axisDomain)
              ? (function getNiceTickValues(_ref2) {
                  var [min, max] = _ref2,
                    tickCount = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 6,
                    allowDecimals =
                      !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                    count = Math.max(tickCount, 2),
                    [cormin, cormax] = getValidInterval([min, max]);
                  if (cormin === -1 / 0 || cormax === 1 / 0) {
                    var _values =
                      cormax === 1 / 0
                        ? [cormin, ...utils_range(0, tickCount - 1).map(() => 1 / 0)]
                        : [...utils_range(0, tickCount - 1).map(() => -1 / 0), cormax];
                    return min > max ? _values.reverse() : _values;
                  }
                  if (cormin === cormax)
                    return getTickOfSingleValue(cormin, tickCount, allowDecimals);
                  var { step, tickMin, tickMax } = _calculateStep(
                      cormin,
                      cormax,
                      count,
                      allowDecimals,
                      0
                    ),
                    values = rangeStep(
                      tickMin,
                      tickMax.add(new (decimal_default())(0.1).mul(step)),
                      step
                    );
                  return min > max ? values.reverse() : values;
                })(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals)
              : null != axisSettings &&
                  axisSettings.tickCount &&
                  'number' === axisSettings.type &&
                  (0, isDomainSpecifiedByUser.JH)(axisDomain)
                ? (function getTickValuesFixedDomain(_ref3, tickCount) {
                    var [min, max] = _ref3,
                      allowDecimals =
                        !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                      [cormin, cormax] = getValidInterval([min, max]);
                    if (cormin === -1 / 0 || cormax === 1 / 0) return [min, max];
                    if (cormin === cormax) return [cormin];
                    var count = Math.max(tickCount, 2),
                      step = getFormatStep(
                        new (decimal_default())(cormax).sub(cormin).div(count - 1),
                        allowDecimals,
                        0
                      ),
                      values = [
                        ...rangeStep(
                          new (decimal_default())(cormin),
                          new (decimal_default())(cormax),
                          step
                        ),
                        cormax,
                      ];
                    return (
                      !1 === allowDecimals && (values = values.map((value) => Math.round(value))),
                      min > max ? values.reverse() : values
                    );
                  })(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals)
                : void 0;
        },
        selectNiceTicks = (0, reselect.Mz)(
          [selectAxisDomain, selectAxisSettings, selectRealScaleType],
          combineNiceTicks
        ),
        combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {
          if (
            'angleAxis' !== axisType &&
            'number' === (null == axisSettings ? void 0 : axisSettings.type) &&
            (0, isDomainSpecifiedByUser.JH)(domain) &&
            Array.isArray(niceTicks) &&
            niceTicks.length > 0
          ) {
            var minFromDomain = domain[0],
              minFromTicks = niceTicks[0],
              maxFromDomain = domain[1],
              maxFromTicks = niceTicks[niceTicks.length - 1];
            return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];
          }
          return domain;
        },
        selectAxisDomainIncludingNiceTicks = (0, reselect.Mz)(
          [selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType.N],
          combineAxisDomainWithNiceTicks
        ),
        selectSmallestDistanceBetweenValues = (0, reselect.Mz)(
          selectAllAppliedValues,
          selectBaseAxis,
          (allDataSquished, axisSettings) => {
            if (axisSettings && 'number' === axisSettings.type) {
              var smallestDistanceBetweenValues = 1 / 0,
                sortedValues = Array.from(
                  onlyAllowNumbers(allDataSquished.map((d) => d.value))
                ).sort((a, b) => a - b),
                first = sortedValues[0],
                last = sortedValues[sortedValues.length - 1];
              if (null == first || null == last) return 1 / 0;
              var diff = last - first;
              if (0 === diff) return 1 / 0;
              for (var i = 0; i < sortedValues.length - 1; i++) {
                var curr = sortedValues[i],
                  next = sortedValues[i + 1];
                if (null != curr && null != next) {
                  var distance = next - curr;
                  smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);
                }
              }
              return smallestDistanceBetweenValues / diff;
            }
          }
        ),
        selectCalculatedPadding = (0, reselect.Mz)(
          selectSmallestDistanceBetweenValues,
          chartLayoutContext.fz,
          rootPropsSelectors.gY,
          selectChartOffsetInternal.HZ,
          (_1, _2, _3, _4, padding) => padding,
          (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {
            if (!(0, isWellBehavedNumber.H)(smallestDistanceInPercent)) return 0;
            var rangeWidth = 'vertical' === layout ? offset.height : offset.width;
            if ('gap' === padding) return (smallestDistanceInPercent * rangeWidth) / 2;
            if ('no-gap' === padding) {
              var gap = (0, DataUtils.F4)(barCategoryGap, smallestDistanceInPercent * rangeWidth),
                halfBand = (smallestDistanceInPercent * rangeWidth) / 2;
              return halfBand - gap - ((halfBand - gap) / rangeWidth) * gap;
            }
            return 0;
          }
        ),
        selectXAxisPadding = (0, reselect.Mz)(
          selectXAxisSettings,
          (state, axisId, isPanorama) => {
            var xAxisSettings = selectXAxisSettings(state, axisId);
            return null == xAxisSettings || 'string' != typeof xAxisSettings.padding
              ? 0
              : selectCalculatedPadding(state, 'xAxis', axisId, isPanorama, xAxisSettings.padding);
          },
          (xAxisSettings, calculated) => {
            var _padding$left, _padding$right;
            if (null == xAxisSettings) return { left: 0, right: 0 };
            var { padding } = xAxisSettings;
            return 'string' == typeof padding
              ? { left: calculated, right: calculated }
              : {
                  left:
                    (null !== (_padding$left = padding.left) && void 0 !== _padding$left
                      ? _padding$left
                      : 0) + calculated,
                  right:
                    (null !== (_padding$right = padding.right) && void 0 !== _padding$right
                      ? _padding$right
                      : 0) + calculated,
                };
          }
        ),
        selectYAxisPadding = (0, reselect.Mz)(
          selectYAxisSettings,
          (state, axisId, isPanorama) => {
            var yAxisSettings = selectYAxisSettings(state, axisId);
            return null == yAxisSettings || 'string' != typeof yAxisSettings.padding
              ? 0
              : selectCalculatedPadding(state, 'yAxis', axisId, isPanorama, yAxisSettings.padding);
          },
          (yAxisSettings, calculated) => {
            var _padding$top, _padding$bottom;
            if (null == yAxisSettings) return { top: 0, bottom: 0 };
            var { padding } = yAxisSettings;
            return 'string' == typeof padding
              ? { top: calculated, bottom: calculated }
              : {
                  top:
                    (null !== (_padding$top = padding.top) && void 0 !== _padding$top
                      ? _padding$top
                      : 0) + calculated,
                  bottom:
                    (null !== (_padding$bottom = padding.bottom) && void 0 !== _padding$bottom
                      ? _padding$bottom
                      : 0) + calculated,
                };
          }
        ),
        combineXAxisRange = (0, reselect.Mz)(
          [
            selectChartOffsetInternal.HZ,
            selectXAxisPadding,
            brushSelectors.U,
            brushSelectors.C,
            (_state, _axisId, isPanorama) => isPanorama,
          ],
          (offset, padding, brushDimensions, _ref4, isPanorama) => {
            var { padding: brushPadding } = _ref4;
            return isPanorama
              ? [brushPadding.left, brushDimensions.width - brushPadding.right]
              : [offset.left + padding.left, offset.left + offset.width - padding.right];
          }
        ),
        combineYAxisRange = (0, reselect.Mz)(
          [
            selectChartOffsetInternal.HZ,
            chartLayoutContext.fz,
            selectYAxisPadding,
            brushSelectors.U,
            brushSelectors.C,
            (_state, _axisId, isPanorama) => isPanorama,
          ],
          (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {
            var { padding: brushPadding } = _ref5;
            return isPanorama
              ? [brushDimensions.height - brushPadding.bottom, brushPadding.top]
              : 'horizontal' === layout
                ? [offset.top + offset.height - padding.bottom, offset.top + padding.top]
                : [offset.top + padding.top, offset.top + offset.height - padding.bottom];
          }
        ),
        selectAxisRange = (state, axisType, axisId, isPanorama) => {
          var _selectZAxisSettings;
          switch (axisType) {
            case 'xAxis':
              return combineXAxisRange(state, axisId, isPanorama);
            case 'yAxis':
              return combineYAxisRange(state, axisId, isPanorama);
            case 'zAxis':
              return null === (_selectZAxisSettings = selectZAxisSettings(state, axisId)) ||
                void 0 === _selectZAxisSettings
                ? void 0
                : _selectZAxisSettings.range;
            case 'angleAxis':
              return (0, polarAxisSelectors.Cv)(state);
            case 'radiusAxis':
              return (0, polarAxisSelectors.Dc)(state, axisId);
            default:
              return;
          }
        },
        selectAxisRangeWithReverse = (0, reselect.Mz)(
          [selectBaseAxis, selectAxisRange],
          combineAxisRangeWithReverse.I
        ),
        selectAxisScale = (0, reselect.Mz)(
          [
            selectBaseAxis,
            selectRealScaleType,
            selectAxisDomainIncludingNiceTicks,
            selectAxisRangeWithReverse,
          ],
          combineScaleFunction
        );
      (0, reselect.Mz)(
        [selectCartesianItemsSettings, selectAllErrorBarSettings, pickAxisType.N],
        (cartesianItemsSettings, allErrorBarSettings, axisType) =>
          cartesianItemsSettings
            .flatMap((item) => allErrorBarSettings[item.id])
            .filter(Boolean)
            .filter((e) => isErrorBarRelevantForAxisType(axisType, e))
      );
      function compareIds(a, b) {
        return a.id < b.id ? -1 : a.id > b.id ? 1 : 0;
      }
      var pickAxisOrientation = (_state, orientation) => orientation,
        pickMirror = (_state, _orientation, mirror) => mirror,
        selectAllXAxesWithOffsetType = (0, reselect.Mz)(
          selectAllAxes.h,
          pickAxisOrientation,
          pickMirror,
          (allAxes, orientation, mirror) =>
            allAxes
              .filter((axis) => axis.orientation === orientation)
              .filter((axis) => axis.mirror === mirror)
              .sort(compareIds)
        ),
        selectAllYAxesWithOffsetType = (0, reselect.Mz)(
          selectAllAxes.W,
          pickAxisOrientation,
          pickMirror,
          (allAxes, orientation, mirror) =>
            allAxes
              .filter((axis) => axis.orientation === orientation)
              .filter((axis) => axis.mirror === mirror)
              .sort(compareIds)
        ),
        getXAxisSize = (offset, axisSettings) => ({
          width: offset.width,
          height: axisSettings.height,
        }),
        selectXAxisSize = (0, reselect.Mz)(
          selectChartOffsetInternal.HZ,
          selectXAxisSettings,
          getXAxisSize
        ),
        selectAllXAxesOffsetSteps = (0, reselect.Mz)(
          containerSelectors.A$,
          selectChartOffsetInternal.HZ,
          selectAllXAxesWithOffsetType,
          pickAxisOrientation,
          pickMirror,
          (chartHeight, offset, allAxesWithSameOffsetType, orientation, mirror) => {
            var position,
              steps = {};
            return (
              allAxesWithSameOffsetType.forEach((axis) => {
                var axisSize = getXAxisSize(offset, axis);
                null == position &&
                  (position = ((offset, orientation, chartHeight) => {
                    switch (orientation) {
                      case 'top':
                        return offset.top;
                      case 'bottom':
                        return chartHeight - offset.bottom;
                      default:
                        return 0;
                    }
                  })(offset, orientation, chartHeight));
                var needSpace =
                  ('top' === orientation && !mirror) || ('bottom' === orientation && mirror);
                ((steps[axis.id] = position - Number(needSpace) * axisSize.height),
                  (position += (needSpace ? -1 : 1) * axisSize.height));
              }),
              steps
            );
          }
        ),
        selectAllYAxesOffsetSteps = (0, reselect.Mz)(
          containerSelectors.Lp,
          selectChartOffsetInternal.HZ,
          selectAllYAxesWithOffsetType,
          pickAxisOrientation,
          pickMirror,
          (chartWidth, offset, allAxesWithSameOffsetType, orientation, mirror) => {
            var position,
              steps = {};
            return (
              allAxesWithSameOffsetType.forEach((axis) => {
                var axisSize = ((offset, axisSettings) => ({
                  width: 'number' == typeof axisSettings.width ? axisSettings.width : Constants.tQ,
                  height: offset.height,
                }))(offset, axis);
                null == position &&
                  (position = ((offset, orientation, chartWidth) => {
                    switch (orientation) {
                      case 'left':
                        return offset.left;
                      case 'right':
                        return chartWidth - offset.right;
                      default:
                        return 0;
                    }
                  })(offset, orientation, chartWidth));
                var needSpace =
                  ('left' === orientation && !mirror) || ('right' === orientation && mirror);
                ((steps[axis.id] = position - Number(needSpace) * axisSize.width),
                  (position += (needSpace ? -1 : 1) * axisSize.width));
              }),
              steps
            );
          }
        ),
        selectXAxisPosition = (0, reselect.Mz)(
          [
            selectChartOffsetInternal.HZ,
            selectXAxisSettings,
            (state, axisId) => {
              var axisSettings = selectXAxisSettings(state, axisId);
              if (null != axisSettings)
                return selectAllXAxesOffsetSteps(
                  state,
                  axisSettings.orientation,
                  axisSettings.mirror
                );
            },
            (_, axisId) => axisId,
          ],
          (offset, axisSettings, allSteps, axisId) => {
            if (null != axisSettings) {
              var stepOfThisAxis = null == allSteps ? void 0 : allSteps[axisId];
              return null == stepOfThisAxis
                ? { x: offset.left, y: 0 }
                : { x: offset.left, y: stepOfThisAxis };
            }
          }
        ),
        selectYAxisPosition = (0, reselect.Mz)(
          [
            selectChartOffsetInternal.HZ,
            selectYAxisSettings,
            (state, axisId) => {
              var axisSettings = selectYAxisSettings(state, axisId);
              if (null != axisSettings)
                return selectAllYAxesOffsetSteps(
                  state,
                  axisSettings.orientation,
                  axisSettings.mirror
                );
            },
            (_, axisId) => axisId,
          ],
          (offset, axisSettings, allSteps, axisId) => {
            if (null != axisSettings) {
              var stepOfThisAxis = null == allSteps ? void 0 : allSteps[axisId];
              return null == stepOfThisAxis
                ? { x: 0, y: offset.top }
                : { x: stepOfThisAxis, y: offset.top };
            }
          }
        ),
        selectYAxisSize = (0, reselect.Mz)(
          selectChartOffsetInternal.HZ,
          selectYAxisSettings,
          (offset, axisSettings) => ({
            width: 'number' == typeof axisSettings.width ? axisSettings.width : Constants.tQ,
            height: offset.height,
          })
        ),
        selectCartesianAxisSize = (state, axisType, axisId) => {
          switch (axisType) {
            case 'xAxis':
              return selectXAxisSize(state, axisId).width;
            case 'yAxis':
              return selectYAxisSize(state, axisId).height;
            default:
              return;
          }
        },
        combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {
          if (null != axis) {
            var { allowDuplicatedCategory, type, dataKey } = axis,
              isCategorical = (0, ChartUtils._L)(chartLayout, axisType),
              allData = appliedValues.map((av) => av.value);
            return dataKey &&
              isCategorical &&
              'category' === type &&
              allowDuplicatedCategory &&
              (0, DataUtils.CG)(allData)
              ? allData
              : void 0;
          }
        },
        selectDuplicateDomain = (0, reselect.Mz)(
          [chartLayoutContext.fz, selectAllAppliedValues, selectBaseAxis, pickAxisType.N],
          combineDuplicateDomain
        ),
        combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {
          if (null != axis && null != axis.dataKey) {
            var { type, scale } = axis;
            return !(0, ChartUtils._L)(layout, axisType) || ('number' !== type && 'auto' === scale)
              ? void 0
              : appliedValues.map((d) => d.value);
          }
        },
        selectCategoricalDomain = (0, reselect.Mz)(
          [chartLayoutContext.fz, selectAllAppliedValues, selectAxisSettings, pickAxisType.N],
          combineCategoricalDomain
        ),
        selectTicksOfAxis =
          ((0, reselect.Mz)(
            [
              chartLayoutContext.fz,
              (state, axisType, axisId) => {
                switch (axisType) {
                  case 'xAxis':
                    return selectXAxisSettings(state, axisId);
                  case 'yAxis':
                    return selectYAxisSettings(state, axisId);
                  default:
                    throw new Error('Unexpected axis type: '.concat(axisType));
                }
              },
              selectRealScaleType,
              selectAxisScale,
              selectDuplicateDomain,
              selectCategoricalDomain,
              selectAxisRange,
              selectNiceTicks,
              pickAxisType.N,
            ],
            (
              layout,
              axis,
              realScaleType,
              scale,
              duplicateDomain,
              categoricalDomain,
              axisRange,
              niceTicks,
              axisType
            ) => {
              if (null != axis) {
                var isCategorical = (0, ChartUtils._L)(layout, axisType);
                return {
                  angle: axis.angle,
                  interval: axis.interval,
                  minTickGap: axis.minTickGap,
                  orientation: axis.orientation,
                  tick: axis.tick,
                  tickCount: axis.tickCount,
                  tickFormatter: axis.tickFormatter,
                  ticks: axis.ticks,
                  type: axis.type,
                  unit: axis.unit,
                  axisType,
                  categoricalDomain,
                  duplicateDomain,
                  isCategorical,
                  niceTicks,
                  range: axisRange,
                  realScaleType,
                  scale,
                };
              }
            }
          ),
          (0, reselect.Mz)(
            [
              chartLayoutContext.fz,
              selectAxisSettings,
              selectRealScaleType,
              selectAxisScale,
              selectNiceTicks,
              selectAxisRange,
              selectDuplicateDomain,
              selectCategoricalDomain,
              pickAxisType.N,
            ],
            (
              layout,
              axis,
              realScaleType,
              scale,
              niceTicks,
              axisRange,
              duplicateDomain,
              categoricalDomain,
              axisType
            ) => {
              if (null != axis && null != scale) {
                var isCategorical = (0, ChartUtils._L)(layout, axisType),
                  { type, ticks, tickCount } = axis,
                  offsetForBand =
                    'scaleBand' === realScaleType && 'function' == typeof scale.bandwidth
                      ? scale.bandwidth() / 2
                      : 2,
                  offset =
                    'category' === type && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
                offset =
                  'angleAxis' === axisType && null != axisRange && axisRange.length >= 2
                    ? 2 * (0, DataUtils.sA)(axisRange[0] - axisRange[1]) * offset
                    : offset;
                var ticksOrNiceTicks = ticks || niceTicks;
                return ticksOrNiceTicks
                  ? ticksOrNiceTicks
                      .map((entry, index) => {
                        var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
                        return {
                          index,
                          coordinate: scale(scaleContent) + offset,
                          value: entry,
                          offset,
                        };
                      })
                      .filter((row) => (0, isWellBehavedNumber.H)(row.coordinate))
                  : isCategorical && categoricalDomain
                    ? categoricalDomain
                        .map((entry, index) => ({
                          coordinate: scale(entry) + offset,
                          value: entry,
                          index,
                          offset,
                        }))
                        .filter((row) => (0, isWellBehavedNumber.H)(row.coordinate))
                    : scale.ticks
                      ? scale
                          .ticks(tickCount)
                          .map((entry) => ({
                            coordinate: scale(entry) + offset,
                            value: entry,
                            offset,
                          }))
                      : scale
                          .domain()
                          .map((entry, index) => ({
                            coordinate: scale(entry) + offset,
                            value: duplicateDomain ? duplicateDomain[entry] : entry,
                            index,
                            offset,
                          }));
              }
            }
          )),
        selectTicksOfGraphicalItem = (0, reselect.Mz)(
          [
            chartLayoutContext.fz,
            selectAxisSettings,
            selectAxisScale,
            selectAxisRange,
            selectDuplicateDomain,
            selectCategoricalDomain,
            pickAxisType.N,
          ],
          (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {
            if (
              null != axis &&
              null != scale &&
              null != axisRange &&
              axisRange[0] !== axisRange[1]
            ) {
              var isCategorical = (0, ChartUtils._L)(layout, axisType),
                { tickCount } = axis,
                offset = 0;
              return (
                (offset =
                  'angleAxis' === axisType && (null == axisRange ? void 0 : axisRange.length) >= 2
                    ? 2 * (0, DataUtils.sA)(axisRange[0] - axisRange[1]) * offset
                    : offset),
                isCategorical && categoricalDomain
                  ? categoricalDomain.map((entry, index) => ({
                      coordinate: scale(entry) + offset,
                      value: entry,
                      index,
                      offset,
                    }))
                  : scale.ticks
                    ? scale
                        .ticks(tickCount)
                        .map((entry) => ({
                          coordinate: scale(entry) + offset,
                          value: entry,
                          offset,
                        }))
                    : scale
                        .domain()
                        .map((entry, index) => ({
                          coordinate: scale(entry) + offset,
                          value: duplicateDomain ? duplicateDomain[entry] : entry,
                          index,
                          offset,
                        }))
              );
            }
          }
        ),
        selectAxisWithScale = (0, reselect.Mz)(selectBaseAxis, selectAxisScale, (axis, scale) => {
          if (null != axis && null != scale)
            return _objectSpread(_objectSpread({}, axis), {}, { scale });
        }),
        selectZAxisScale = (0, reselect.Mz)(
          [selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse],
          combineScaleFunction
        ),
        selectChartDirection =
          ((0, reselect.Mz)(
            (state, _axisType, axisId) => selectZAxisSettings(state, axisId),
            selectZAxisScale,
            (axis, scale) => {
              if (null != axis && null != scale)
                return _objectSpread(_objectSpread({}, axis), {}, { scale });
            }
          ),
          (0, reselect.Mz)(
            [chartLayoutContext.fz, selectAllAxes.h, selectAllAxes.W],
            (layout, allXAxes, allYAxes) => {
              switch (layout) {
                case 'horizontal':
                  return allXAxes.some((axis) => axis.reversed) ? 'right-to-left' : 'left-to-right';
                case 'vertical':
                  return allYAxes.some((axis) => axis.reversed) ? 'bottom-to-top' : 'top-to-bottom';
                case 'centric':
                case 'radial':
                  return 'left-to-right';
                default:
                  return;
              }
            }
          ));
    },
    './node_modules/recharts/es6/state/selectors/brushSelectors.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        C: () => selectBrushSettings,
        U: () => selectBrushDimensions,
      });
      var reselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/reselect/dist/reselect.mjs'
        ),
        _selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
        ),
        _containerSelectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/containerSelectors.js'
        ),
        _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        ),
        selectBrushSettings = (state) => state.brush,
        selectBrushDimensions = (0, reselect__WEBPACK_IMPORTED_MODULE_0__.Mz)(
          [
            selectBrushSettings,
            _selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_1__.HZ,
            _containerSelectors__WEBPACK_IMPORTED_MODULE_2__.HK,
          ],
          (brushSettings, offset, margin) => ({
            height: brushSettings.height,
            x: (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.Et)(brushSettings.x)
              ? brushSettings.x
              : offset.left,
            y: (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.Et)(brushSettings.y)
              ? brushSettings.y
              : offset.top +
                offset.height +
                offset.brushBottom -
                ((null == margin ? void 0 : margin.bottom) || 0),
            width: (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_3__.Et)(brushSettings.width)
              ? brushSettings.width
              : offset.width,
          })
        );
    },
    './node_modules/recharts/es6/state/selectors/combiners/combineActiveLabel.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { E: () => combineActiveLabel });
      var _util_DataUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        ),
        combineActiveLabel = (tooltipTicks, activeIndex) => {
          var _tooltipTicks$n,
            n = Number(activeIndex);
          if (!(0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_0__.M8)(n) && null != activeIndex)
            return n >= 0
              ? null == tooltipTicks ||
                null === (_tooltipTicks$n = tooltipTicks[n]) ||
                void 0 === _tooltipTicks$n
                ? void 0
                : _tooltipTicks$n.value
              : void 0;
        };
    },
    './node_modules/recharts/es6/state/selectors/combiners/combineActiveTooltipIndex.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { P: () => combineActiveTooltipIndex });
      var _util_isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/recharts/es6/util/isWellBehavedNumber.js'
        ),
        _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/util/ChartUtils.js'
        ),
        _util_isDomainSpecifiedByUser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/util/isDomainSpecifiedByUser.js'
        );
      function isValueWithinNumberDomain(value, domain) {
        var numericValue = (function toFiniteNumber(value) {
            if ('number' == typeof value) return Number.isFinite(value) ? value : void 0;
            if (value instanceof Date) {
              var numericValue = value.valueOf();
              return Number.isFinite(numericValue) ? numericValue : void 0;
            }
            var parsed = Number(value);
            return Number.isFinite(parsed) ? parsed : void 0;
          })(value),
          lowerBound = domain[0],
          upperBound = domain[1];
        if (void 0 === numericValue) return !1;
        var min = Math.min(lowerBound, upperBound),
          max = Math.max(lowerBound, upperBound);
        return numericValue >= min && numericValue <= max;
      }
      var combineActiveTooltipIndex = (tooltipInteraction, chartData, axisDataKey, domain) => {
        var desiredIndex = null == tooltipInteraction ? void 0 : tooltipInteraction.index;
        if (null == desiredIndex) return null;
        var indexAsNumber = Number(desiredIndex);
        if (!(0, _util_isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_0__.H)(indexAsNumber))
          return desiredIndex;
        var upperLimit = 1 / 0;
        chartData.length > 0 && (upperLimit = chartData.length - 1);
        var clampedIndex = Math.max(0, Math.min(indexAsNumber, upperLimit)),
          entry = chartData[clampedIndex];
        return null == entry ||
          (function isValueWithinDomain(entry, axisDataKey, domain) {
            if (null == domain || null == axisDataKey) return !0;
            var value = (0, _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__.kr)(entry, axisDataKey);
            return (
              null == value ||
              !(0, _util_isDomainSpecifiedByUser__WEBPACK_IMPORTED_MODULE_2__.JH)(domain) ||
              isValueWithinNumberDomain(value, domain)
            );
          })(entry, axisDataKey, domain)
          ? String(clampedIndex)
          : null;
      };
    },
    './node_modules/recharts/es6/state/selectors/combiners/combineAxisRangeWithReverse.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { I: () => combineAxisRangeWithReverse });
      var combineAxisRangeWithReverse = (axisSettings, axisRange) => {
        if (axisSettings && axisRange)
          return null != axisSettings && axisSettings.reversed
            ? [axisRange[1], axisRange[0]]
            : axisRange;
      };
    },
    './node_modules/recharts/es6/state/selectors/combiners/combineCoordinateForDefaultIndex.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { o: () => combineCoordinateForDefaultIndex });
      var combineCoordinateForDefaultIndex = (
        width,
        height,
        layout,
        offset,
        tooltipTicks,
        defaultIndex,
        tooltipConfigurations,
        tooltipPayloadSearcher
      ) => {
        if (null != defaultIndex && null != tooltipPayloadSearcher) {
          var firstConfiguration = tooltipConfigurations[0],
            maybePosition =
              null == firstConfiguration
                ? void 0
                : tooltipPayloadSearcher(firstConfiguration.positions, defaultIndex);
          if (null != maybePosition) return maybePosition;
          var tick = null == tooltipTicks ? void 0 : tooltipTicks[Number(defaultIndex)];
          if (tick)
            return 'horizontal' === layout
              ? { x: tick.coordinate, y: (offset.top + height) / 2 }
              : { x: (offset.left + width) / 2, y: tick.coordinate };
        }
      };
    },
    './node_modules/recharts/es6/state/selectors/combiners/combineDisplayedStackedData.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { A: () => combineDisplayedStackedData });
      var _util_stacks_getStackSeriesIdentifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/recharts/es6/util/stacks/getStackSeriesIdentifier.js'
        ),
        _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/util/ChartUtils.js'
        );
      function combineDisplayedStackedData(stackedGraphicalItems, _ref, tooltipAxisSettings) {
        var { chartData = [] } = _ref,
          { allowDuplicatedCategory, dataKey: tooltipDataKey } = tooltipAxisSettings,
          knownItemsByDataKey = new Map();
        return (
          stackedGraphicalItems.forEach((item) => {
            var _item$data,
              resolvedData =
                null !== (_item$data = item.data) && void 0 !== _item$data ? _item$data : chartData;
            if (null != resolvedData && 0 !== resolvedData.length) {
              var stackIdentifier = (0,
              _util_stacks_getStackSeriesIdentifier__WEBPACK_IMPORTED_MODULE_0__.x)(item);
              resolvedData.forEach((entry, index) => {
                var curr,
                  tooltipValue =
                    null == tooltipDataKey || allowDuplicatedCategory
                      ? index
                      : String(
                          (0, _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__.kr)(
                            entry,
                            tooltipDataKey,
                            null
                          )
                        ),
                  numericValue = (0, _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__.kr)(
                    entry,
                    item.dataKey,
                    0
                  );
                ((curr = knownItemsByDataKey.has(tooltipValue)
                  ? knownItemsByDataKey.get(tooltipValue)
                  : {}),
                  Object.assign(curr, { [stackIdentifier]: numericValue }),
                  knownItemsByDataKey.set(tooltipValue, curr));
              });
            }
          }),
          Array.from(knownItemsByDataKey.values())
        );
      }
    },
    './node_modules/recharts/es6/state/selectors/combiners/combineTooltipInteractionState.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { i: () => combineTooltipInteractionState });
      var _tooltipSlice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        './node_modules/recharts/es6/state/tooltipSlice.js'
      );
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var combineTooltipInteractionState = (
        tooltipState,
        tooltipEventType,
        trigger,
        defaultIndex
      ) => {
        if (null == tooltipEventType) return _tooltipSlice__WEBPACK_IMPORTED_MODULE_0__.k_;
        var appropriateMouseInteraction = (function chooseAppropriateMouseInteraction(
          tooltipState,
          tooltipEventType,
          trigger
        ) {
          return 'axis' === tooltipEventType
            ? 'click' === trigger
              ? tooltipState.axisInteraction.click
              : tooltipState.axisInteraction.hover
            : 'click' === trigger
              ? tooltipState.itemInteraction.click
              : tooltipState.itemInteraction.hover;
        })(tooltipState, tooltipEventType, trigger);
        if (null == appropriateMouseInteraction)
          return _tooltipSlice__WEBPACK_IMPORTED_MODULE_0__.k_;
        if (appropriateMouseInteraction.active) return appropriateMouseInteraction;
        if (tooltipState.keyboardInteraction.active) return tooltipState.keyboardInteraction;
        if (tooltipState.syncInteraction.active && null != tooltipState.syncInteraction.index)
          return tooltipState.syncInteraction;
        var activeFromProps = !0 === tooltipState.settings.active;
        if (
          (function hasBeenActivePreviously(tooltipInteractionState) {
            return null != tooltipInteractionState.index;
          })(appropriateMouseInteraction)
        ) {
          if (activeFromProps)
            return _objectSpread(
              _objectSpread({}, appropriateMouseInteraction),
              {},
              { active: !0 }
            );
        } else if (null != defaultIndex)
          return {
            active: !0,
            coordinate: void 0,
            dataKey: void 0,
            index: defaultIndex,
            graphicalItemId: void 0,
          };
        return _objectSpread(
          _objectSpread({}, _tooltipSlice__WEBPACK_IMPORTED_MODULE_0__.k_),
          {},
          { coordinate: appropriateMouseInteraction.coordinate }
        );
      };
    },
    './node_modules/recharts/es6/state/selectors/combiners/combineTooltipPayload.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { N: () => combineTooltipPayload });
      var _util_DataUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        ),
        _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/util/ChartUtils.js'
        ),
        _util_getSliced__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/util/getSliced.js'
        );
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var combineTooltipPayload = (
        tooltipPayloadConfigurations,
        activeIndex,
        chartDataState,
        tooltipAxisDataKey,
        activeLabel,
        tooltipPayloadSearcher,
        tooltipEventType
      ) => {
        if (null != activeIndex && null != tooltipPayloadSearcher) {
          var { chartData, computedData, dataStartIndex, dataEndIndex } = chartDataState;
          return tooltipPayloadConfigurations.reduce((agg, _ref) => {
            var _settings$dataKey,
              tooltipPayload,
              _getValueByDataKey,
              { dataDefinedOnItem, settings } = _ref,
              finalData = (function selectFinalData(dataDefinedOnItem, dataDefinedOnChart) {
                return null != dataDefinedOnItem ? dataDefinedOnItem : dataDefinedOnChart;
              })(dataDefinedOnItem, chartData),
              sliced = Array.isArray(finalData)
                ? (0, _util_getSliced__WEBPACK_IMPORTED_MODULE_2__.v)(
                    finalData,
                    dataStartIndex,
                    dataEndIndex
                  )
                : finalData,
              finalDataKey =
                null !== (_settings$dataKey = null == settings ? void 0 : settings.dataKey) &&
                void 0 !== _settings$dataKey
                  ? _settings$dataKey
                  : tooltipAxisDataKey,
              finalNameKey = null == settings ? void 0 : settings.nameKey;
            ((tooltipPayload =
              tooltipAxisDataKey &&
              Array.isArray(sliced) &&
              !Array.isArray(sliced[0]) &&
              'axis' === tooltipEventType
                ? (0, _util_DataUtils__WEBPACK_IMPORTED_MODULE_0__.eP)(
                    sliced,
                    tooltipAxisDataKey,
                    activeLabel
                  )
                : tooltipPayloadSearcher(sliced, activeIndex, computedData, finalNameKey)),
            Array.isArray(tooltipPayload))
              ? tooltipPayload.forEach((item) => {
                  var newSettings = _objectSpread(
                    _objectSpread({}, settings),
                    {},
                    { name: item.name, unit: item.unit, color: void 0, fill: void 0 }
                  );
                  agg.push(
                    (0, _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__.GF)({
                      tooltipEntrySettings: newSettings,
                      dataKey: item.dataKey,
                      payload: item.payload,
                      value: (0, _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__.kr)(
                        item.payload,
                        item.dataKey
                      ),
                      name: item.name,
                    })
                  );
                })
              : agg.push(
                  (0, _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__.GF)({
                    tooltipEntrySettings: settings,
                    dataKey: finalDataKey,
                    payload: tooltipPayload,
                    value: (0, _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__.kr)(
                      tooltipPayload,
                      finalDataKey
                    ),
                    name:
                      null !==
                        (_getValueByDataKey = (0, _util_ChartUtils__WEBPACK_IMPORTED_MODULE_1__.kr)(
                          tooltipPayload,
                          finalNameKey
                        )) && void 0 !== _getValueByDataKey
                        ? _getValueByDataKey
                        : null == settings
                          ? void 0
                          : settings.name,
                  })
                );
            return agg;
          }, []);
        }
      };
    },
    './node_modules/recharts/es6/state/selectors/combiners/combineTooltipPayloadConfigurations.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { q: () => combineTooltipPayloadConfigurations });
      var combineTooltipPayloadConfigurations = (
        tooltipState,
        tooltipEventType,
        trigger,
        defaultIndex
      ) => {
        if ('axis' === tooltipEventType) return tooltipState.tooltipItemPayloads;
        if (0 === tooltipState.tooltipItemPayloads.length) return [];
        var filterByGraphicalItemId;
        if (
          null ==
            (filterByGraphicalItemId =
              'hover' === trigger
                ? tooltipState.itemInteraction.hover.graphicalItemId
                : tooltipState.itemInteraction.click.graphicalItemId) &&
          null != defaultIndex
        ) {
          var firstItemPayload = tooltipState.tooltipItemPayloads[0];
          return null != firstItemPayload ? [firstItemPayload] : [];
        }
        return tooltipState.tooltipItemPayloads.filter((tpc) => {
          var _tpc$settings;
          return (
            (null === (_tpc$settings = tpc.settings) || void 0 === _tpc$settings
              ? void 0
              : _tpc$settings.graphicalItemId) === filterByGraphicalItemId
          );
        });
      };
    },
    './node_modules/recharts/es6/state/selectors/containerSelectors.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        A$: () => selectChartHeight,
        HK: () => selectMargin,
        Lp: () => selectChartWidth,
        et: () => selectContainerScale,
      });
      var selectChartWidth = (state) => state.layout.width,
        selectChartHeight = (state) => state.layout.height,
        selectContainerScale = (state) => state.layout.scale,
        selectMargin = (state) => state.layout.margin;
    },
    './node_modules/recharts/es6/state/selectors/dataSelectors.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        LF: () => selectChartDataWithIndexes,
        k$: () => selectChartDataWithIndexesIfNotInPanoramaPosition4,
        rN: () => selectChartDataWithIndexesIfNotInPanoramaPosition3,
        z3: () => selectChartDataAndAlwaysIgnoreIndexes,
      });
      var reselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/reselect/dist/reselect.mjs'
        ),
        selectChartDataWithIndexes = (state) => state.chartData,
        selectChartDataAndAlwaysIgnoreIndexes = (0, reselect__WEBPACK_IMPORTED_MODULE_0__.Mz)(
          [selectChartDataWithIndexes],
          (dataState) => {
            var dataEndIndex = null != dataState.chartData ? dataState.chartData.length - 1 : 0;
            return {
              chartData: dataState.chartData,
              computedData: dataState.computedData,
              dataEndIndex,
              dataStartIndex: 0,
            };
          }
        ),
        selectChartDataWithIndexesIfNotInPanoramaPosition4 = (
          state,
          _unused1,
          _unused2,
          isPanorama
        ) =>
          isPanorama
            ? selectChartDataAndAlwaysIgnoreIndexes(state)
            : selectChartDataWithIndexes(state),
        selectChartDataWithIndexesIfNotInPanoramaPosition3 = (state, _unused1, isPanorama) =>
          isPanorama
            ? selectChartDataAndAlwaysIgnoreIndexes(state)
            : selectChartDataWithIndexes(state);
    },
    './node_modules/recharts/es6/state/selectors/numberDomainEqualityCheck.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { o: () => numberDomainEqualityCheck });
      var numberDomainEqualityCheck = (a, b) =>
        a === b || (null != a && null != b && a[0] === b[0] && a[1] === b[1]);
    },
    './node_modules/recharts/es6/state/selectors/pickAxisId.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { E: () => pickAxisId });
      var pickAxisId = (_state, _axisType, axisId) => axisId;
    },
    './node_modules/recharts/es6/state/selectors/pickAxisType.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { N: () => pickAxisType });
      var pickAxisType = (_state, axisType) => axisType;
    },
    './node_modules/recharts/es6/state/selectors/polarAxisSelectors.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        Be: () => selectAngleAxis,
        Cv: () => selectAngleAxisRange,
        D0: () => selectPolarViewBox,
        Gl: () => selectRadiusAxis,
        Dc: () => selectRadiusAxisRange,
      });
      var reselect = __webpack_require__('./node_modules/reselect/dist/reselect.mjs'),
        containerSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/containerSelectors.js'
        ),
        selectChartOffsetInternal = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
        ),
        PolarUtils = __webpack_require__('./node_modules/recharts/es6/util/PolarUtils.js'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        DefaultZIndexes = __webpack_require__(
          './node_modules/recharts/es6/zIndex/DefaultZIndexes.js'
        ),
        defaultPolarAngleAxisProps_allowDuplicatedCategory = !0,
        defaultPolarAngleAxisProps_angleAxisId = 0,
        defaultPolarAngleAxisProps_reversed = !1,
        defaultPolarAngleAxisProps_scale = 'auto',
        defaultPolarAngleAxisProps_tick = !0,
        defaultPolarAngleAxisProps_type = 'category',
        defaultPolarRadiusAxisProps_allowDataOverflow = (DefaultZIndexes.I.axis, !1),
        defaultPolarRadiusAxisProps_allowDuplicatedCategory = !0,
        defaultPolarRadiusAxisProps_radiusAxisId = 0,
        defaultPolarRadiusAxisProps_scale = 'auto',
        defaultPolarRadiusAxisProps_tick = !0,
        defaultPolarRadiusAxisProps_tickCount = 5,
        defaultPolarRadiusAxisProps_type = 'number',
        combineAxisRangeWithReverse =
          (DefaultZIndexes.I.axis,
          __webpack_require__(
            './node_modules/recharts/es6/state/selectors/combiners/combineAxisRangeWithReverse.js'
          )),
        chartLayoutContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        implicitAngleAxis = {
          allowDataOverflow: !1,
          allowDecimals: !1,
          allowDuplicatedCategory: !1,
          dataKey: void 0,
          domain: void 0,
          id: defaultPolarAngleAxisProps_angleAxisId,
          includeHidden: !1,
          name: void 0,
          reversed: defaultPolarAngleAxisProps_reversed,
          scale: defaultPolarAngleAxisProps_scale,
          tick: defaultPolarAngleAxisProps_tick,
          tickCount: void 0,
          ticks: void 0,
          type: defaultPolarAngleAxisProps_type,
          unit: void 0,
        },
        implicitRadiusAxis = {
          allowDataOverflow: defaultPolarRadiusAxisProps_allowDataOverflow,
          allowDecimals: !1,
          allowDuplicatedCategory: defaultPolarRadiusAxisProps_allowDuplicatedCategory,
          dataKey: void 0,
          domain: void 0,
          id: defaultPolarRadiusAxisProps_radiusAxisId,
          includeHidden: !1,
          name: void 0,
          reversed: !1,
          scale: defaultPolarRadiusAxisProps_scale,
          tick: defaultPolarRadiusAxisProps_tick,
          tickCount: defaultPolarRadiusAxisProps_tickCount,
          ticks: void 0,
          type: defaultPolarRadiusAxisProps_type,
          unit: void 0,
        },
        implicitRadialBarAngleAxis = {
          allowDataOverflow: !1,
          allowDecimals: !1,
          allowDuplicatedCategory: defaultPolarAngleAxisProps_allowDuplicatedCategory,
          dataKey: void 0,
          domain: void 0,
          id: defaultPolarAngleAxisProps_angleAxisId,
          includeHidden: !1,
          name: void 0,
          reversed: !1,
          scale: defaultPolarAngleAxisProps_scale,
          tick: defaultPolarAngleAxisProps_tick,
          tickCount: void 0,
          ticks: void 0,
          type: 'number',
          unit: void 0,
        },
        implicitRadialBarRadiusAxis = {
          allowDataOverflow: defaultPolarRadiusAxisProps_allowDataOverflow,
          allowDecimals: !1,
          allowDuplicatedCategory: defaultPolarRadiusAxisProps_allowDuplicatedCategory,
          dataKey: void 0,
          domain: void 0,
          id: defaultPolarRadiusAxisProps_radiusAxisId,
          includeHidden: !1,
          name: void 0,
          reversed: !1,
          scale: defaultPolarRadiusAxisProps_scale,
          tick: defaultPolarRadiusAxisProps_tick,
          tickCount: defaultPolarRadiusAxisProps_tickCount,
          ticks: void 0,
          type: 'category',
          unit: void 0,
        },
        selectAngleAxis = (state, angleAxisId) =>
          null != state.polarAxis.angleAxis[angleAxisId]
            ? state.polarAxis.angleAxis[angleAxisId]
            : 'radial' === state.layout.layoutType
              ? implicitRadialBarAngleAxis
              : implicitAngleAxis,
        selectRadiusAxis = (state, radiusAxisId) =>
          null != state.polarAxis.radiusAxis[radiusAxisId]
            ? state.polarAxis.radiusAxis[radiusAxisId]
            : 'radial' === state.layout.layoutType
              ? implicitRadialBarRadiusAxis
              : implicitRadiusAxis,
        selectPolarOptions = (state) => state.polarOptions,
        selectMaxRadius = (0, reselect.Mz)(
          [containerSelectors.Lp, containerSelectors.A$, selectChartOffsetInternal.HZ],
          PolarUtils.lY
        ),
        selectInnerRadius = (0, reselect.Mz)(
          [selectPolarOptions, selectMaxRadius],
          (polarChartOptions, maxRadius) => {
            if (null != polarChartOptions)
              return (0, DataUtils.F4)(polarChartOptions.innerRadius, maxRadius, 0);
          }
        ),
        selectOuterRadius = (0, reselect.Mz)(
          [selectPolarOptions, selectMaxRadius],
          (polarChartOptions, maxRadius) => {
            if (null != polarChartOptions)
              return (0, DataUtils.F4)(polarChartOptions.outerRadius, maxRadius, 0.8 * maxRadius);
          }
        ),
        selectAngleAxisRange = (0, reselect.Mz)([selectPolarOptions], (polarOptions) => {
          if (null == polarOptions) return [0, 0];
          var { startAngle, endAngle } = polarOptions;
          return [startAngle, endAngle];
        }),
        selectRadiusAxisRange =
          ((0, reselect.Mz)([selectAngleAxis, selectAngleAxisRange], combineAxisRangeWithReverse.I),
          (0, reselect.Mz)(
            [selectMaxRadius, selectInnerRadius, selectOuterRadius],
            (maxRadius, innerRadius, outerRadius) => {
              if (null != maxRadius && null != innerRadius && null != outerRadius)
                return [innerRadius, outerRadius];
            }
          )),
        selectPolarViewBox =
          ((0, reselect.Mz)(
            [selectRadiusAxis, selectRadiusAxisRange],
            combineAxisRangeWithReverse.I
          ),
          (0, reselect.Mz)(
            [
              chartLayoutContext.fz,
              selectPolarOptions,
              selectInnerRadius,
              selectOuterRadius,
              containerSelectors.Lp,
              containerSelectors.A$,
            ],
            (layout, polarOptions, innerRadius, outerRadius, width, height) => {
              if (
                ('centric' === layout || 'radial' === layout) &&
                null != polarOptions &&
                null != innerRadius &&
                null != outerRadius
              ) {
                var { cx, cy, startAngle, endAngle } = polarOptions;
                return {
                  cx: (0, DataUtils.F4)(cx, width, width / 2),
                  cy: (0, DataUtils.F4)(cy, height, height / 2),
                  innerRadius,
                  outerRadius,
                  startAngle,
                  endAngle,
                  clockWise: !1,
                };
              }
            }
          ));
    },
    './node_modules/recharts/es6/state/selectors/rootPropsSelectors.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        JN: () => selectRootMaxBarSize,
        Lb: () => selectReverseStackOrder,
        _5: () => selectBarGap,
        eC: () => selectStackOffsetType,
        gY: () => selectBarCategoryGap,
        hX: () => selectSyncMethod,
        iO: () => selectChartName,
        lZ: () => selectSyncId,
        pH: () => selectEventEmitter,
        x3: () => selectRootBarSize,
      });
      var selectRootMaxBarSize = (state) => state.rootProps.maxBarSize,
        selectBarGap = (state) => state.rootProps.barGap,
        selectBarCategoryGap = (state) => state.rootProps.barCategoryGap,
        selectRootBarSize = (state) => state.rootProps.barSize,
        selectStackOffsetType = (state) => state.rootProps.stackOffset,
        selectReverseStackOrder = (state) => state.rootProps.reverseStackOrder,
        selectChartName = (state) => state.options.chartName,
        selectSyncId = (state) => state.rootProps.syncId,
        selectSyncMethod = (state) => state.rootProps.syncMethod,
        selectEventEmitter = (state) => state.options.eventEmitter;
    },
    './node_modules/recharts/es6/state/selectors/selectActivePropsFromChartPointer.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { g: () => selectActivePropsFromChartPointer });
      var reselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/reselect/dist/reselect.mjs'
        ),
        _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        _tooltipSelectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/tooltipSelectors.js'
        ),
        _selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
        ),
        _selectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectors.js'
        ),
        _polarAxisSelectors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/polarAxisSelectors.js'
        ),
        _selectTooltipAxisType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipAxisType.js'
        ),
        selectActivePropsFromChartPointer = (0, reselect__WEBPACK_IMPORTED_MODULE_0__.Mz)(
          [
            (_state, chartPointer) => chartPointer,
            _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_1__.fz,
            _polarAxisSelectors__WEBPACK_IMPORTED_MODULE_5__.D0,
            _selectTooltipAxisType__WEBPACK_IMPORTED_MODULE_6__.R,
            _tooltipSelectors__WEBPACK_IMPORTED_MODULE_2__.gL,
            _tooltipSelectors__WEBPACK_IMPORTED_MODULE_2__.R4,
            _selectors__WEBPACK_IMPORTED_MODULE_4__.r1,
            _selectChartOffsetInternal__WEBPACK_IMPORTED_MODULE_3__.HZ,
          ],
          _selectors__WEBPACK_IMPORTED_MODULE_4__.aX
        );
    },
    './node_modules/recharts/es6/state/selectors/selectAllAxes.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        W: () => selectAllYAxes,
        h: () => selectAllXAxes,
      });
      var reselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/reselect/dist/reselect.mjs'
        ),
        selectAllXAxes = (0, reselect__WEBPACK_IMPORTED_MODULE_0__.Mz)(
          (state) => state.cartesianAxis.xAxis,
          (xAxisMap) => Object.values(xAxisMap)
        ),
        selectAllYAxes = (0, reselect__WEBPACK_IMPORTED_MODULE_0__.Mz)(
          (state) => state.cartesianAxis.yAxis,
          (yAxisMap) => Object.values(yAxisMap)
        );
    },
    './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        c2: () => selectAxisViewBox,
        HZ: () => selectChartOffsetInternal,
        Ds: () => selectChartViewBox,
      });
      var reselect = __webpack_require__('./node_modules/reselect/dist/reselect.mjs'),
        sortBy = __webpack_require__('./node_modules/es-toolkit/compat/sortBy.js'),
        sortBy_default = __webpack_require__.n(sortBy),
        selectLegendSettings = (state) => state.legend.settings,
        ChartUtils =
          ((0, reselect.Mz)(
            [(state) => state.legend.payload, selectLegendSettings],
            (payloads, _ref) => {
              var { itemSorter } = _ref,
                flat = payloads.flat(1);
              return itemSorter ? sortBy_default()(flat, itemSorter) : flat;
            }
          ),
          __webpack_require__('./node_modules/recharts/es6/util/ChartUtils.js')),
        containerSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/containerSelectors.js'
        ),
        selectAllAxes = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectAllAxes.js'
        ),
        Constants = __webpack_require__('./node_modules/recharts/es6/util/Constants.js');
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var selectChartOffsetInternal = (0, reselect.Mz)(
          [
            containerSelectors.Lp,
            containerSelectors.A$,
            containerSelectors.HK,
            (state) => state.brush.height,
            function selectLeftAxesOffset(state) {
              return (0, selectAllAxes.W)(state).reduce(
                (result, entry) =>
                  'left' !== entry.orientation || entry.mirror || entry.hide
                    ? result
                    : result + ('number' == typeof entry.width ? entry.width : Constants.tQ),
                0
              );
            },
            function selectRightAxesOffset(state) {
              return (0, selectAllAxes.W)(state).reduce(
                (result, entry) =>
                  'right' !== entry.orientation || entry.mirror || entry.hide
                    ? result
                    : result + ('number' == typeof entry.width ? entry.width : Constants.tQ),
                0
              );
            },
            function selectTopAxesOffset(state) {
              return (0, selectAllAxes.h)(state).reduce(
                (result, entry) =>
                  'top' !== entry.orientation || entry.mirror || entry.hide
                    ? result
                    : result + entry.height,
                0
              );
            },
            function selectBottomAxesOffset(state) {
              return (0, selectAllAxes.h)(state).reduce(
                (result, entry) =>
                  'bottom' !== entry.orientation || entry.mirror || entry.hide
                    ? result
                    : result + entry.height,
                0
              );
            },
            selectLegendSettings,
            (state) => state.legend.size,
          ],
          (
            chartWidth,
            chartHeight,
            margin,
            brushHeight,
            leftAxesOffset,
            rightAxesOffset,
            topAxesOffset,
            bottomAxesOffset,
            legendSettings,
            legendSize
          ) => {
            var offsetH = {
                left: (margin.left || 0) + leftAxesOffset,
                right: (margin.right || 0) + rightAxesOffset,
              },
              offset = _objectSpread(
                _objectSpread(
                  {},
                  {
                    top: (margin.top || 0) + topAxesOffset,
                    bottom: (margin.bottom || 0) + bottomAxesOffset,
                  }
                ),
                offsetH
              ),
              brushBottom = offset.bottom;
            offset.bottom += brushHeight;
            var offsetWidth =
                chartWidth -
                (offset = (0, ChartUtils.s0)(offset, legendSettings, legendSize)).left -
                offset.right,
              offsetHeight = chartHeight - offset.top - offset.bottom;
            return _objectSpread(
              _objectSpread({ brushBottom }, offset),
              {},
              { width: Math.max(offsetWidth, 0), height: Math.max(offsetHeight, 0) }
            );
          }
        ),
        selectChartViewBox = (0, reselect.Mz)(selectChartOffsetInternal, (offset) => ({
          x: offset.left,
          y: offset.top,
          width: offset.width,
          height: offset.height,
        })),
        selectAxisViewBox = (0, reselect.Mz)(
          containerSelectors.Lp,
          containerSelectors.A$,
          (width, height) => ({ x: 0, y: 0, width, height })
        );
    },
    './node_modules/recharts/es6/state/selectors/selectTooltipAxisId.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { M: () => selectTooltipAxisId });
      var selectTooltipAxisId = (state) => state.tooltip.settings.axisId;
    },
    './node_modules/recharts/es6/state/selectors/selectTooltipAxisType.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { R: () => selectTooltipAxisType });
      var _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        selectTooltipAxisType = (state) => {
          var layout = (0, _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_0__.fz)(state);
          return 'horizontal' === layout
            ? 'xAxis'
            : 'vertical' === layout
              ? 'yAxis'
              : 'centric' === layout
                ? 'angleAxis'
                : 'radiusAxis';
        };
    },
    './node_modules/recharts/es6/state/selectors/selectTooltipEventType.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        $g: () => combineTooltipEventType,
        Hw: () => selectValidateTooltipEventTypes,
        Td: () => useTooltipEventType,
        au: () => selectTooltipEventType,
        xH: () => selectDefaultTooltipEventType,
      });
      var _hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        selectDefaultTooltipEventType = (state) => state.options.defaultTooltipEventType,
        selectValidateTooltipEventTypes = (state) => state.options.validateTooltipEventTypes;
      function combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes) {
        if (null == shared) return defaultTooltipEventType;
        var eventType = shared ? 'axis' : 'item';
        return null == validateTooltipEventTypes
          ? defaultTooltipEventType
          : validateTooltipEventTypes.includes(eventType)
            ? eventType
            : defaultTooltipEventType;
      }
      function selectTooltipEventType(state, shared) {
        return combineTooltipEventType(
          shared,
          selectDefaultTooltipEventType(state),
          selectValidateTooltipEventTypes(state)
        );
      }
      function useTooltipEventType(shared) {
        return (0, _hooks__WEBPACK_IMPORTED_MODULE_0__.G)((state) =>
          selectTooltipEventType(state, shared)
        );
      }
    },
    './node_modules/recharts/es6/state/selectors/selectTooltipPayloadSearcher.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { x: () => selectTooltipPayloadSearcher });
      var selectTooltipPayloadSearcher = (state) => state.options.tooltipPayloadSearcher;
    },
    './node_modules/recharts/es6/state/selectors/selectTooltipState.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { J: () => selectTooltipState });
      var selectTooltipState = (state) => state.tooltip;
    },
    './node_modules/recharts/es6/state/selectors/selectors.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        aX: () => combineActiveProps,
        dS: () => selectActiveCoordinate,
        BZ: () => selectActiveLabel,
        pg: () => selectCoordinateForDefaultIndex,
        yn: () => selectIsTooltipActive,
        r1: () => selectOrderedTooltipTicks,
        dp: () => selectTooltipDataKey,
        u9: () => selectTooltipPayload,
        fW: () => useChartName,
      });
      var reselect = __webpack_require__('./node_modules/reselect/dist/reselect.mjs'),
        sortBy = __webpack_require__('./node_modules/es-toolkit/compat/sortBy.js'),
        sortBy_default = __webpack_require__.n(sortBy),
        hooks = __webpack_require__('./node_modules/recharts/es6/state/hooks.js'),
        ChartUtils = __webpack_require__('./node_modules/recharts/es6/util/ChartUtils.js'),
        dataSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/dataSelectors.js'
        ),
        tooltipSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/tooltipSelectors.js'
        ),
        axisSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/axisSelectors.js'
        ),
        rootPropsSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/rootPropsSelectors.js'
        ),
        chartLayoutContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        selectChartOffsetInternal = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
        ),
        containerSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/containerSelectors.js'
        ),
        combineActiveLabel = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineActiveLabel.js'
        ),
        combineTooltipInteractionState = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineTooltipInteractionState.js'
        ),
        combineActiveTooltipIndex = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineActiveTooltipIndex.js'
        ),
        combineCoordinateForDefaultIndex = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineCoordinateForDefaultIndex.js'
        ),
        combineTooltipPayloadConfigurations = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineTooltipPayloadConfigurations.js'
        ),
        selectTooltipPayloadSearcher = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipPayloadSearcher.js'
        ),
        selectTooltipState = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipState.js'
        ),
        combineTooltipPayload = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineTooltipPayload.js'
        ),
        PolarUtils = __webpack_require__('./node_modules/recharts/es6/util/PolarUtils.js'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js');
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var calculateActiveTickIndex = (coordinate, ticks, unsortedTicks, axisType, range) => {
          var _ticks$length,
            len =
              null !== (_ticks$length = null == ticks ? void 0 : ticks.length) &&
              void 0 !== _ticks$length
                ? _ticks$length
                : 0;
          if (len <= 1 || null == coordinate) return 0;
          if (
            'angleAxis' === axisType &&
            null != range &&
            Math.abs(Math.abs(range[1] - range[0]) - 360) <= 1e-6
          )
            for (var i = 0; i < len; i++) {
              var _unsortedTicks,
                _unsortedTicks2,
                _unsortedTicks$i,
                _unsortedTicks$,
                _unsortedTicks3,
                before =
                  i > 0
                    ? null === (_unsortedTicks = unsortedTicks[i - 1]) || void 0 === _unsortedTicks
                      ? void 0
                      : _unsortedTicks.coordinate
                    : null === (_unsortedTicks2 = unsortedTicks[len - 1]) ||
                        void 0 === _unsortedTicks2
                      ? void 0
                      : _unsortedTicks2.coordinate,
                cur =
                  null === (_unsortedTicks$i = unsortedTicks[i]) || void 0 === _unsortedTicks$i
                    ? void 0
                    : _unsortedTicks$i.coordinate,
                after =
                  i >= len - 1
                    ? null === (_unsortedTicks$ = unsortedTicks[0]) || void 0 === _unsortedTicks$
                      ? void 0
                      : _unsortedTicks$.coordinate
                    : null === (_unsortedTicks3 = unsortedTicks[i + 1]) ||
                        void 0 === _unsortedTicks3
                      ? void 0
                      : _unsortedTicks3.coordinate,
                sameDirectionCoord = void 0;
              if (null != before && null != cur && null != after)
                if ((0, DataUtils.sA)(cur - before) !== (0, DataUtils.sA)(after - cur)) {
                  var diffInterval = [];
                  if ((0, DataUtils.sA)(after - cur) === (0, DataUtils.sA)(range[1] - range[0])) {
                    sameDirectionCoord = after;
                    var curInRange = cur + range[1] - range[0];
                    ((diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2)),
                      (diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2)));
                  } else {
                    sameDirectionCoord = before;
                    var afterInRange = after + range[1] - range[0];
                    ((diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2)),
                      (diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2)));
                  }
                  var _unsortedTicks$i2,
                    sameInterval = [
                      Math.min(cur, (sameDirectionCoord + cur) / 2),
                      Math.max(cur, (sameDirectionCoord + cur) / 2),
                    ];
                  if (
                    (coordinate > sameInterval[0] && coordinate <= sameInterval[1]) ||
                    (coordinate >= diffInterval[0] && coordinate <= diffInterval[1])
                  )
                    return null === (_unsortedTicks$i2 = unsortedTicks[i]) ||
                      void 0 === _unsortedTicks$i2
                      ? void 0
                      : _unsortedTicks$i2.index;
                } else {
                  var _unsortedTicks$i3,
                    minValue = Math.min(before, after),
                    maxValue = Math.max(before, after);
                  if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2)
                    return null === (_unsortedTicks$i3 = unsortedTicks[i]) ||
                      void 0 === _unsortedTicks$i3
                      ? void 0
                      : _unsortedTicks$i3.index;
                }
            }
          else if (ticks)
            for (var _i = 0; _i < len; _i++) {
              var curr = ticks[_i];
              if (null != curr) {
                var next = ticks[_i + 1],
                  prev = ticks[_i - 1];
                if (
                  0 === _i &&
                  null != next &&
                  coordinate <= (curr.coordinate + next.coordinate) / 2
                )
                  return curr.index;
                if (
                  _i === len - 1 &&
                  null != prev &&
                  coordinate > (curr.coordinate + prev.coordinate) / 2
                )
                  return curr.index;
                if (
                  _i > 0 &&
                  _i < len - 1 &&
                  null != prev &&
                  null != next &&
                  coordinate > (curr.coordinate + prev.coordinate) / 2 &&
                  coordinate <= (curr.coordinate + next.coordinate) / 2
                )
                  return curr.index;
              }
            }
          return -1;
        },
        useChartName = () => (0, hooks.G)(rootPropsSelectors.iO),
        pickTooltipEventType = (_state, tooltipEventType) => tooltipEventType,
        pickTrigger = (_state, _tooltipEventType, trigger) => trigger,
        pickDefaultIndex = (_state, _tooltipEventType, _trigger, defaultIndex) => defaultIndex,
        selectOrderedTooltipTicks = (0, reselect.Mz)(tooltipSelectors.R4, (ticks) =>
          sortBy_default()(ticks, (o) => o.coordinate)
        ),
        selectTooltipInteractionState = (0, reselect.Mz)(
          [selectTooltipState.J, pickTooltipEventType, pickTrigger, pickDefaultIndex],
          combineTooltipInteractionState.i
        ),
        selectActiveIndex = (0, reselect.Mz)(
          [
            selectTooltipInteractionState,
            tooltipSelectors.n4,
            axisSelectors.K6,
            tooltipSelectors.FO,
          ],
          combineActiveTooltipIndex.P
        ),
        selectTooltipDataKey = (state, tooltipEventType, trigger) => {
          if (null != tooltipEventType) {
            var tooltipState = (0, selectTooltipState.J)(state);
            return 'axis' === tooltipEventType
              ? 'hover' === trigger
                ? tooltipState.axisInteraction.hover.dataKey
                : tooltipState.axisInteraction.click.dataKey
              : 'hover' === trigger
                ? tooltipState.itemInteraction.hover.dataKey
                : tooltipState.itemInteraction.click.dataKey;
          }
        },
        selectTooltipPayloadConfigurations = (0, reselect.Mz)(
          [selectTooltipState.J, pickTooltipEventType, pickTrigger, pickDefaultIndex],
          combineTooltipPayloadConfigurations.q
        ),
        selectCoordinateForDefaultIndex = (0, reselect.Mz)(
          [
            containerSelectors.Lp,
            containerSelectors.A$,
            chartLayoutContext.fz,
            selectChartOffsetInternal.HZ,
            tooltipSelectors.R4,
            pickDefaultIndex,
            selectTooltipPayloadConfigurations,
            selectTooltipPayloadSearcher.x,
          ],
          combineCoordinateForDefaultIndex.o
        ),
        selectActiveCoordinate = (0, reselect.Mz)(
          [selectTooltipInteractionState, selectCoordinateForDefaultIndex],
          (tooltipInteractionState, defaultIndexCoordinate) => {
            var _tooltipInteractionSt;
            return null !== (_tooltipInteractionSt = tooltipInteractionState.coordinate) &&
              void 0 !== _tooltipInteractionSt
              ? _tooltipInteractionSt
              : defaultIndexCoordinate;
          }
        ),
        selectActiveLabel = (0, reselect.Mz)(
          [tooltipSelectors.R4, selectActiveIndex],
          combineActiveLabel.E
        ),
        selectTooltipPayload = (0, reselect.Mz)(
          [
            selectTooltipPayloadConfigurations,
            selectActiveIndex,
            dataSelectors.LF,
            axisSelectors.K6,
            selectActiveLabel,
            selectTooltipPayloadSearcher.x,
            pickTooltipEventType,
          ],
          combineTooltipPayload.N
        ),
        selectIsTooltipActive = (0, reselect.Mz)(
          [selectTooltipInteractionState, selectActiveIndex],
          (tooltipInteractionState, activeIndex) => ({
            isActive: tooltipInteractionState.active && null != activeIndex,
            activeIndex,
          })
        ),
        combineActivePolarProps = (
          chartEvent,
          layout,
          polarViewBox,
          tooltipAxisType,
          tooltipAxisRange,
          tooltipTicks,
          orderedTooltipTicks
        ) => {
          if (chartEvent && tooltipAxisType && tooltipAxisRange && tooltipTicks && polarViewBox) {
            var rangeObj = (0, PolarUtils.yy)(chartEvent, polarViewBox);
            if (rangeObj) {
              var pos = (0, ChartUtils.eB)(rangeObj, layout),
                activeIndex = calculateActiveTickIndex(
                  pos,
                  orderedTooltipTicks,
                  tooltipTicks,
                  tooltipAxisType,
                  tooltipAxisRange
                ),
                activeCoordinate = ((layout, tooltipTicks, activeIndex, rangeObj) => {
                  var entry = tooltipTicks.find((tick) => tick && tick.index === activeIndex);
                  if (entry) {
                    if ('centric' === layout) {
                      var _angle = entry.coordinate,
                        { radius: _radius } = rangeObj;
                      return _objectSpread(
                        _objectSpread(
                          _objectSpread({}, rangeObj),
                          (0, PolarUtils.IZ)(rangeObj.cx, rangeObj.cy, _radius, _angle)
                        ),
                        {},
                        { angle: _angle, radius: _radius }
                      );
                    }
                    var radius = entry.coordinate,
                      { angle } = rangeObj;
                    return _objectSpread(
                      _objectSpread(
                        _objectSpread({}, rangeObj),
                        (0, PolarUtils.IZ)(rangeObj.cx, rangeObj.cy, radius, angle)
                      ),
                      {},
                      { angle, radius }
                    );
                  }
                  return {
                    angle: 0,
                    clockWise: !1,
                    cx: 0,
                    cy: 0,
                    endAngle: 0,
                    innerRadius: 0,
                    outerRadius: 0,
                    radius: 0,
                    startAngle: 0,
                    x: 0,
                    y: 0,
                  };
                })(layout, tooltipTicks, activeIndex, rangeObj);
              return { activeIndex: String(activeIndex), activeCoordinate };
            }
          }
        },
        combineActiveProps = (
          chartEvent,
          layout,
          polarViewBox,
          tooltipAxisType,
          tooltipAxisRange,
          tooltipTicks,
          orderedTooltipTicks,
          offset
        ) => {
          if (chartEvent && layout && tooltipAxisType && tooltipAxisRange && tooltipTicks)
            return 'horizontal' === layout || 'vertical' === layout
              ? ((
                  chartEvent,
                  layout,
                  tooltipAxisType,
                  tooltipAxisRange,
                  tooltipTicks,
                  orderedTooltipTicks,
                  offset
                ) => {
                  if (
                    chartEvent &&
                    tooltipAxisType &&
                    tooltipAxisRange &&
                    tooltipTicks &&
                    (function isInCartesianRange(pointer, offset) {
                      var { chartX: x, chartY: y } = pointer;
                      return (
                        x >= offset.left &&
                        x <= offset.left + offset.width &&
                        y >= offset.top &&
                        y <= offset.top + offset.height
                      );
                    })(chartEvent, offset)
                  ) {
                    var pos = (0, ChartUtils.sr)(chartEvent, layout),
                      activeIndex = calculateActiveTickIndex(
                        pos,
                        orderedTooltipTicks,
                        tooltipTicks,
                        tooltipAxisType,
                        tooltipAxisRange
                      ),
                      activeCoordinate = ((layout, tooltipTicks, activeIndex, pointer) => {
                        var entry = tooltipTicks.find((tick) => tick && tick.index === activeIndex);
                        if (entry) {
                          if ('horizontal' === layout)
                            return { x: entry.coordinate, y: pointer.chartY };
                          if ('vertical' === layout)
                            return { x: pointer.chartX, y: entry.coordinate };
                        }
                        return { x: 0, y: 0 };
                      })(layout, tooltipTicks, activeIndex, chartEvent);
                    return { activeIndex: String(activeIndex), activeCoordinate };
                  }
                })(
                  chartEvent,
                  layout,
                  tooltipAxisType,
                  tooltipAxisRange,
                  tooltipTicks,
                  orderedTooltipTicks,
                  offset
                )
              : combineActivePolarProps(
                  chartEvent,
                  layout,
                  polarViewBox,
                  tooltipAxisType,
                  tooltipAxisRange,
                  tooltipTicks,
                  orderedTooltipTicks
                );
        };
    },
    './node_modules/recharts/es6/state/selectors/tooltipSelectors.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        BZ: () => selectActiveLabel,
        eE: () => selectActiveTooltipCoordinate,
        Xb: () => selectActiveTooltipDataKey,
        fx: () => selectActiveTooltipGraphicalItemId,
        A2: () => selectActiveTooltipIndex,
        AA: () => selectAllGraphicalItemsSettings,
        yn: () => selectIsTooltipActive,
        FO: () => selectTooltipAxisDomain,
        gL: () => selectTooltipAxisRangeWithReverse,
        fl: () => selectTooltipAxisScale,
        R4: () => selectTooltipAxisTicks,
        n4: () => selectTooltipDisplayedData,
      });
      var reselect = __webpack_require__('./node_modules/reselect/dist/reselect.mjs'),
        axisSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/axisSelectors.js'
        ),
        chartLayoutContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        ChartUtils = __webpack_require__('./node_modules/recharts/es6/util/ChartUtils.js'),
        dataSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/dataSelectors.js'
        ),
        rootPropsSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/rootPropsSelectors.js'
        ),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        combineAxisRangeWithReverse = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineAxisRangeWithReverse.js'
        ),
        selectTooltipEventType = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipEventType.js'
        ),
        combineActiveLabel = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineActiveLabel.js'
        ),
        combineTooltipInteractionState = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineTooltipInteractionState.js'
        ),
        combineActiveTooltipIndex = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineActiveTooltipIndex.js'
        ),
        combineCoordinateForDefaultIndex = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineCoordinateForDefaultIndex.js'
        ),
        containerSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/containerSelectors.js'
        ),
        selectChartOffsetInternal = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js'
        ),
        combineTooltipPayloadConfigurations = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineTooltipPayloadConfigurations.js'
        ),
        selectTooltipPayloadSearcher = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipPayloadSearcher.js'
        ),
        selectTooltipState = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipState.js'
        ),
        combineTooltipPayload = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineTooltipPayload.js'
        ),
        selectTooltipAxisId = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipAxisId.js'
        ),
        selectTooltipAxisType = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipAxisType.js'
        ),
        combineDisplayedStackedData = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/combiners/combineDisplayedStackedData.js'
        ),
        StackedGraphicalItem = __webpack_require__(
          './node_modules/recharts/es6/state/types/StackedGraphicalItem.js'
        ),
        isDomainSpecifiedByUser = __webpack_require__(
          './node_modules/recharts/es6/util/isDomainSpecifiedByUser.js'
        ),
        numberDomainEqualityCheck = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/numberDomainEqualityCheck.js'
        ),
        arrayEqualityCheck = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/arrayEqualityCheck.js'
        ),
        selectTooltipAxisRealScaleType = (0, reselect.Mz)(
          [
            axisSelectors.Dn,
            chartLayoutContext.fz,
            axisSelectors.um,
            rootPropsSelectors.iO,
            selectTooltipAxisType.R,
          ],
          axisSelectors.sr
        ),
        selectAllUnfilteredGraphicalItems = (0, reselect.Mz)(
          [
            (state) => state.graphicalItems.cartesianItems,
            (state) => state.graphicalItems.polarItems,
          ],
          (cartesianItems, polarItems) => [...cartesianItems, ...polarItems]
        ),
        selectTooltipAxisPredicate = (0, reselect.Mz)(
          [selectTooltipAxisType.R, selectTooltipAxisId.M],
          axisSelectors.eo
        ),
        selectAllGraphicalItemsSettings = (0, reselect.Mz)(
          [selectAllUnfilteredGraphicalItems, axisSelectors.Dn, selectTooltipAxisPredicate],
          axisSelectors.ec,
          { memoizeOptions: { resultEqualityCheck: arrayEqualityCheck.O } }
        ),
        selectAllStackedGraphicalItemsSettings = (0, reselect.Mz)(
          [selectAllGraphicalItemsSettings],
          (graphicalItems) => graphicalItems.filter(StackedGraphicalItem.g)
        ),
        selectTooltipGraphicalItemsData = (0, reselect.Mz)(
          [selectAllGraphicalItemsSettings],
          axisSelectors.rj,
          { memoizeOptions: { resultEqualityCheck: arrayEqualityCheck.O } }
        ),
        selectTooltipDisplayedData = (0, reselect.Mz)(
          [selectTooltipGraphicalItemsData, dataSelectors.LF],
          axisSelectors.Nk
        ),
        selectTooltipStackedData = (0, reselect.Mz)(
          [selectAllStackedGraphicalItemsSettings, dataSelectors.LF, axisSelectors.Dn],
          combineDisplayedStackedData.A
        ),
        selectAllTooltipAppliedValues = (0, reselect.Mz)(
          [selectTooltipDisplayedData, axisSelectors.Dn, selectAllGraphicalItemsSettings],
          axisSelectors.fb
        ),
        selectTooltipAxisDomainDefinition = (0, reselect.Mz)([axisSelectors.Dn], axisSelectors.S5),
        selectTooltipDataOverflow = (0, reselect.Mz)(
          [axisSelectors.Dn],
          (axisSettings) => axisSettings.allowDataOverflow
        ),
        selectTooltipDomainFromUserPreferences = (0, reselect.Mz)(
          [selectTooltipAxisDomainDefinition, selectTooltipDataOverflow],
          isDomainSpecifiedByUser.f5
        ),
        selectAllStackedGraphicalItems = (0, reselect.Mz)(
          [selectAllGraphicalItemsSettings],
          (graphicalItems) => graphicalItems.filter(StackedGraphicalItem.g)
        ),
        selectTooltipStackGroups = (0, reselect.Mz)(
          [
            selectTooltipStackedData,
            selectAllStackedGraphicalItems,
            rootPropsSelectors.eC,
            rootPropsSelectors.Lb,
          ],
          axisSelectors.MK
        ),
        selectTooltipDomainOfStackGroups = (0, reselect.Mz)(
          [
            selectTooltipStackGroups,
            dataSelectors.LF,
            selectTooltipAxisType.R,
            selectTooltipDomainFromUserPreferences,
          ],
          axisSelectors.pM
        ),
        selectTooltipItemsSettingsExceptStacked = (0, reselect.Mz)(
          [selectAllGraphicalItemsSettings],
          axisSelectors.IO
        ),
        selectDomainOfAllAppliedNumericalValuesIncludingErrorValues = (0, reselect.Mz)(
          [
            selectTooltipDisplayedData,
            axisSelectors.Dn,
            selectTooltipItemsSettingsExceptStacked,
            axisSelectors.CH,
            selectTooltipAxisType.R,
          ],
          axisSelectors.EZ,
          { memoizeOptions: { resultEqualityCheck: numberDomainEqualityCheck.o } }
        ),
        selectReferenceDotsByTooltipAxis = (0, reselect.Mz)(
          [axisSelectors.Kr, selectTooltipAxisType.R, selectTooltipAxisId.M],
          axisSelectors.P9
        ),
        selectTooltipReferenceDotsDomain = (0, reselect.Mz)(
          [selectReferenceDotsByTooltipAxis, selectTooltipAxisType.R],
          axisSelectors.Oz
        ),
        selectReferenceAreasByTooltipAxis = (0, reselect.Mz)(
          [axisSelectors.gT, selectTooltipAxisType.R, selectTooltipAxisId.M],
          axisSelectors.P9
        ),
        selectTooltipReferenceAreasDomain = (0, reselect.Mz)(
          [selectReferenceAreasByTooltipAxis, selectTooltipAxisType.R],
          axisSelectors.q
        ),
        selectReferenceLinesByTooltipAxis = (0, reselect.Mz)(
          [axisSelectors.$X, selectTooltipAxisType.R, selectTooltipAxisId.M],
          axisSelectors.P9
        ),
        selectTooltipReferenceLinesDomain = (0, reselect.Mz)(
          [selectReferenceLinesByTooltipAxis, selectTooltipAxisType.R],
          axisSelectors.bb
        ),
        selectTooltipReferenceElementsDomain = (0, reselect.Mz)(
          [
            selectTooltipReferenceDotsDomain,
            selectTooltipReferenceLinesDomain,
            selectTooltipReferenceAreasDomain,
          ],
          axisSelectors.yi
        ),
        selectTooltipNumericalDomain = (0, reselect.Mz)(
          [
            axisSelectors.Dn,
            selectTooltipAxisDomainDefinition,
            selectTooltipDomainFromUserPreferences,
            selectTooltipDomainOfStackGroups,
            selectDomainOfAllAppliedNumericalValuesIncludingErrorValues,
            selectTooltipReferenceElementsDomain,
            chartLayoutContext.fz,
            selectTooltipAxisType.R,
          ],
          axisSelectors.wL
        ),
        selectTooltipAxisDomain = (0, reselect.Mz)(
          [
            axisSelectors.Dn,
            chartLayoutContext.fz,
            selectTooltipDisplayedData,
            selectAllTooltipAppliedValues,
            rootPropsSelectors.eC,
            selectTooltipAxisType.R,
            selectTooltipNumericalDomain,
          ],
          axisSelectors.tP
        ),
        selectTooltipNiceTicks = (0, reselect.Mz)(
          [selectTooltipAxisDomain, axisSelectors.Dn, selectTooltipAxisRealScaleType],
          axisSelectors.xp
        ),
        selectTooltipAxisDomainIncludingNiceTicks = (0, reselect.Mz)(
          [
            axisSelectors.Dn,
            selectTooltipAxisDomain,
            selectTooltipNiceTicks,
            selectTooltipAxisType.R,
          ],
          axisSelectors.g1
        ),
        selectTooltipAxisRange = (state) => {
          var axisType = (0, selectTooltipAxisType.R)(state),
            axisId = (0, selectTooltipAxisId.M)(state);
          return (0, axisSelectors.D5)(state, axisType, axisId, !1);
        },
        selectTooltipAxisRangeWithReverse = (0, reselect.Mz)(
          [axisSelectors.Dn, selectTooltipAxisRange],
          combineAxisRangeWithReverse.I
        ),
        selectTooltipAxisScale = (0, reselect.Mz)(
          [
            axisSelectors.Dn,
            selectTooltipAxisRealScaleType,
            selectTooltipAxisDomainIncludingNiceTicks,
            selectTooltipAxisRangeWithReverse,
          ],
          axisSelectors.Qn
        ),
        selectTooltipDuplicateDomain = (0, reselect.Mz)(
          [
            chartLayoutContext.fz,
            selectAllTooltipAppliedValues,
            axisSelectors.Dn,
            selectTooltipAxisType.R,
          ],
          axisSelectors.tF
        ),
        selectTooltipCategoricalDomain = (0, reselect.Mz)(
          [
            chartLayoutContext.fz,
            selectAllTooltipAppliedValues,
            axisSelectors.Dn,
            selectTooltipAxisType.R,
          ],
          axisSelectors.iv
        ),
        selectTooltipAxisTicks = (0, reselect.Mz)(
          [
            chartLayoutContext.fz,
            axisSelectors.Dn,
            selectTooltipAxisRealScaleType,
            selectTooltipAxisScale,
            selectTooltipAxisRange,
            selectTooltipDuplicateDomain,
            selectTooltipCategoricalDomain,
            selectTooltipAxisType.R,
          ],
          (
            layout,
            axis,
            realScaleType,
            scale,
            range,
            duplicateDomain,
            categoricalDomain,
            axisType
          ) => {
            if (axis) {
              var { type } = axis,
                isCategorical = (0, ChartUtils._L)(layout, axisType);
              if (scale) {
                var offsetForBand =
                    'scaleBand' === realScaleType && scale.bandwidth ? scale.bandwidth() / 2 : 2,
                  offset =
                    'category' === type && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
                return (
                  (offset =
                    'angleAxis' === axisType &&
                    null != range &&
                    (null == range ? void 0 : range.length) >= 2
                      ? 2 * (0, DataUtils.sA)(range[0] - range[1]) * offset
                      : offset),
                  isCategorical && categoricalDomain
                    ? categoricalDomain.map((entry, index) => ({
                        coordinate: scale(entry) + offset,
                        value: entry,
                        index,
                        offset,
                      }))
                    : scale
                        .domain()
                        .map((entry, index) => ({
                          coordinate: scale(entry) + offset,
                          value: duplicateDomain ? duplicateDomain[entry] : entry,
                          index,
                          offset,
                        }))
                );
              }
            }
          }
        ),
        tooltipSelectors_selectTooltipEventType = (0, reselect.Mz)(
          [selectTooltipEventType.xH, selectTooltipEventType.Hw, (state) => state.tooltip.settings],
          (defaultTooltipEventType, validateTooltipEventType, settings) =>
            (0, selectTooltipEventType.$g)(
              settings.shared,
              defaultTooltipEventType,
              validateTooltipEventType
            )
        ),
        selectTooltipTrigger = (state) => state.tooltip.settings.trigger,
        selectDefaultIndex = (state) => state.tooltip.settings.defaultIndex,
        selectTooltipInteractionState = (0, reselect.Mz)(
          [
            selectTooltipState.J,
            tooltipSelectors_selectTooltipEventType,
            selectTooltipTrigger,
            selectDefaultIndex,
          ],
          combineTooltipInteractionState.i
        ),
        selectActiveTooltipIndex = (0, reselect.Mz)(
          [
            selectTooltipInteractionState,
            selectTooltipDisplayedData,
            axisSelectors.K6,
            selectTooltipAxisDomain,
          ],
          combineActiveTooltipIndex.P
        ),
        selectActiveLabel = (0, reselect.Mz)(
          [selectTooltipAxisTicks, selectActiveTooltipIndex],
          combineActiveLabel.E
        ),
        selectActiveTooltipDataKey = (0, reselect.Mz)(
          [selectTooltipInteractionState],
          (tooltipInteraction) => {
            if (tooltipInteraction) return tooltipInteraction.dataKey;
          }
        ),
        selectActiveTooltipGraphicalItemId = (0, reselect.Mz)(
          [selectTooltipInteractionState],
          (tooltipInteraction) => {
            if (tooltipInteraction) return tooltipInteraction.graphicalItemId;
          }
        ),
        selectTooltipPayloadConfigurations = (0, reselect.Mz)(
          [
            selectTooltipState.J,
            tooltipSelectors_selectTooltipEventType,
            selectTooltipTrigger,
            selectDefaultIndex,
          ],
          combineTooltipPayloadConfigurations.q
        ),
        selectTooltipCoordinateForDefaultIndex = (0, reselect.Mz)(
          [
            containerSelectors.Lp,
            containerSelectors.A$,
            chartLayoutContext.fz,
            selectChartOffsetInternal.HZ,
            selectTooltipAxisTicks,
            selectDefaultIndex,
            selectTooltipPayloadConfigurations,
            selectTooltipPayloadSearcher.x,
          ],
          combineCoordinateForDefaultIndex.o
        ),
        selectActiveTooltipCoordinate = (0, reselect.Mz)(
          [selectTooltipInteractionState, selectTooltipCoordinateForDefaultIndex],
          (tooltipInteractionState, defaultIndexCoordinate) =>
            null != tooltipInteractionState && tooltipInteractionState.coordinate
              ? tooltipInteractionState.coordinate
              : defaultIndexCoordinate
        ),
        selectIsTooltipActive = (0, reselect.Mz)(
          [selectTooltipInteractionState],
          (tooltipInteractionState) => {
            var _tooltipInteractionSt;
            return (
              null !==
                (_tooltipInteractionSt =
                  null == tooltipInteractionState ? void 0 : tooltipInteractionState.active) &&
              void 0 !== _tooltipInteractionSt &&
              _tooltipInteractionSt
            );
          }
        ),
        selectActiveTooltipPayload = (0, reselect.Mz)(
          [
            selectTooltipPayloadConfigurations,
            selectActiveTooltipIndex,
            dataSelectors.LF,
            axisSelectors.K6,
            selectActiveLabel,
            selectTooltipPayloadSearcher.x,
            tooltipSelectors_selectTooltipEventType,
          ],
          combineTooltipPayload.N
        );
      (0, reselect.Mz)([selectActiveTooltipPayload], (payload) => {
        if (null != payload) {
          var dataPoints = payload.map((p) => p.payload).filter((p) => null != p);
          return Array.from(new Set(dataPoints));
        }
      });
    },
    './node_modules/recharts/es6/state/tooltipSlice.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        E1: () => setSyncInteraction,
        En: () => tooltipReducer,
        Ix: () => addTooltipEntrySettings,
        ML: () => setActiveClickItemIndex,
        Nt: () => setMouseOverAxisIndex,
        RD: () => setActiveMouseOverItemIndex,
        UF: () => setTooltipSettingsState,
        XB: () => removeTooltipEntrySettings,
        Zp: () => replaceTooltipEntrySettings,
        jF: () => setMouseClickAxisIndex,
        k_: () => noInteraction,
        o4: () => setKeyboardInteraction,
        oP: () => mouseLeaveItem,
        xS: () => mouseLeaveChart,
      });
      var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs'
        ),
        immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/immer/dist/immer.mjs'
        ),
        noInteraction = {
          active: !1,
          index: null,
          dataKey: void 0,
          graphicalItemId: void 0,
          coordinate: void 0,
        },
        initialState = {
          itemInteraction: { click: noInteraction, hover: noInteraction },
          axisInteraction: { click: noInteraction, hover: noInteraction },
          keyboardInteraction: noInteraction,
          syncInteraction: {
            active: !1,
            index: null,
            dataKey: void 0,
            label: void 0,
            coordinate: void 0,
            sourceViewBox: void 0,
            graphicalItemId: void 0,
          },
          tooltipItemPayloads: [],
          settings: {
            shared: void 0,
            trigger: 'hover',
            axisId: 0,
            active: !1,
            defaultIndex: void 0,
          },
        },
        tooltipSlice = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Z0)({
          name: 'tooltip',
          initialState,
          reducers: {
            addTooltipEntrySettings: {
              reducer(state, action) {
                state.tooltipItemPayloads.push(
                  (0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(action.payload)
                );
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            replaceTooltipEntrySettings: {
              reducer(state, action) {
                var { prev, next } = action.payload,
                  index = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.ss)(
                    state
                  ).tooltipItemPayloads.indexOf((0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(prev));
                index > -1 &&
                  (state.tooltipItemPayloads[index] = (0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(
                    next
                  ));
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            removeTooltipEntrySettings: {
              reducer(state, action) {
                var index = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.ss)(
                  state
                ).tooltipItemPayloads.indexOf(
                  (0, immer__WEBPACK_IMPORTED_MODULE_2__.h4)(action.payload)
                );
                index > -1 && state.tooltipItemPayloads.splice(index, 1);
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            setTooltipSettingsState(state, action) {
              state.settings = action.payload;
            },
            setActiveMouseOverItemIndex(state, action) {
              ((state.syncInteraction.active = !1),
                (state.keyboardInteraction.active = !1),
                (state.itemInteraction.hover.active = !0),
                (state.itemInteraction.hover.index = action.payload.activeIndex),
                (state.itemInteraction.hover.dataKey = action.payload.activeDataKey),
                (state.itemInteraction.hover.graphicalItemId =
                  action.payload.activeGraphicalItemId),
                (state.itemInteraction.hover.coordinate = action.payload.activeCoordinate));
            },
            mouseLeaveChart(state) {
              ((state.itemInteraction.hover.active = !1),
                (state.axisInteraction.hover.active = !1));
            },
            mouseLeaveItem(state) {
              state.itemInteraction.hover.active = !1;
            },
            setActiveClickItemIndex(state, action) {
              ((state.syncInteraction.active = !1),
                (state.itemInteraction.click.active = !0),
                (state.keyboardInteraction.active = !1),
                (state.itemInteraction.click.index = action.payload.activeIndex),
                (state.itemInteraction.click.dataKey = action.payload.activeDataKey),
                (state.itemInteraction.click.graphicalItemId =
                  action.payload.activeGraphicalItemId),
                (state.itemInteraction.click.coordinate = action.payload.activeCoordinate));
            },
            setMouseOverAxisIndex(state, action) {
              ((state.syncInteraction.active = !1),
                (state.axisInteraction.hover.active = !0),
                (state.keyboardInteraction.active = !1),
                (state.axisInteraction.hover.index = action.payload.activeIndex),
                (state.axisInteraction.hover.dataKey = action.payload.activeDataKey),
                (state.axisInteraction.hover.coordinate = action.payload.activeCoordinate));
            },
            setMouseClickAxisIndex(state, action) {
              ((state.syncInteraction.active = !1),
                (state.keyboardInteraction.active = !1),
                (state.axisInteraction.click.active = !0),
                (state.axisInteraction.click.index = action.payload.activeIndex),
                (state.axisInteraction.click.dataKey = action.payload.activeDataKey),
                (state.axisInteraction.click.coordinate = action.payload.activeCoordinate));
            },
            setSyncInteraction(state, action) {
              state.syncInteraction = action.payload;
            },
            setKeyboardInteraction(state, action) {
              ((state.keyboardInteraction.active = action.payload.active),
                (state.keyboardInteraction.index = action.payload.activeIndex),
                (state.keyboardInteraction.coordinate = action.payload.activeCoordinate));
            },
          },
        }),
        {
          addTooltipEntrySettings,
          replaceTooltipEntrySettings,
          removeTooltipEntrySettings,
          setTooltipSettingsState,
          setActiveMouseOverItemIndex,
          mouseLeaveItem,
          mouseLeaveChart,
          setActiveClickItemIndex,
          setMouseOverAxisIndex,
          setMouseClickAxisIndex,
          setSyncInteraction,
          setKeyboardInteraction,
        } = tooltipSlice.actions,
        tooltipReducer = tooltipSlice.reducer;
    },
    './node_modules/recharts/es6/state/touchEventsMiddleware.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        e: () => touchEventAction,
        k: () => touchEventMiddleware,
      });
      var redux_toolkit_modern = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        tooltipSlice = __webpack_require__('./node_modules/recharts/es6/state/tooltipSlice.js'),
        selectActivePropsFromChartPointer = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectActivePropsFromChartPointer.js'
        ),
        getChartPointer = __webpack_require__(
          './node_modules/recharts/es6/util/getChartPointer.js'
        ),
        selectTooltipEventType = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipEventType.js'
        ),
        Constants = __webpack_require__('./node_modules/recharts/es6/util/Constants.js'),
        reselect = __webpack_require__('./node_modules/reselect/dist/reselect.mjs'),
        selectTooltipPayloadSearcher = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipPayloadSearcher.js'
        ),
        selectTooltipState = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/selectTooltipState.js'
        ),
        selectAllTooltipPayloadConfiguration = (0, reselect.Mz)(
          [selectTooltipState.J],
          (tooltipState) => tooltipState.tooltipItemPayloads
        ),
        selectTooltipCoordinate = (0, reselect.Mz)(
          [
            selectAllTooltipPayloadConfiguration,
            selectTooltipPayloadSearcher.x,
            (_state, tooltipIndex) => tooltipIndex,
            (_state, _tooltipIndex, graphicalItemId) => graphicalItemId,
          ],
          (allTooltipConfigurations, tooltipPayloadSearcher, tooltipIndex, graphicalItemId) => {
            var mostRelevantTooltipConfiguration = allTooltipConfigurations.find(
              (tooltipConfiguration) =>
                tooltipConfiguration.settings.graphicalItemId === graphicalItemId
            );
            if (null != mostRelevantTooltipConfiguration) {
              var { positions } = mostRelevantTooltipConfiguration;
              if (null != positions) return tooltipPayloadSearcher(positions, tooltipIndex);
            }
          }
        ),
        tooltipSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/tooltipSelectors.js'
        ),
        touchEventAction = (0, redux_toolkit_modern.VP)('touchMove'),
        touchEventMiddleware = (0, redux_toolkit_modern.Nc)();
      touchEventMiddleware.startListening({
        actionCreator: touchEventAction,
        effect: (action, listenerApi) => {
          var touchEvent = action.payload;
          if (null != touchEvent.touches && 0 !== touchEvent.touches.length) {
            var state = listenerApi.getState(),
              tooltipEventType = (0, selectTooltipEventType.au)(
                state,
                state.tooltip.settings.shared
              );
            if ('axis' === tooltipEventType) {
              var touch = touchEvent.touches[0];
              if (null == touch) return;
              var activeProps = (0, selectActivePropsFromChartPointer.g)(
                state,
                (0, getChartPointer.w)({
                  clientX: touch.clientX,
                  clientY: touch.clientY,
                  currentTarget: touchEvent.currentTarget,
                })
              );
              null != (null == activeProps ? void 0 : activeProps.activeIndex) &&
                listenerApi.dispatch(
                  (0, tooltipSlice.Nt)({
                    activeIndex: activeProps.activeIndex,
                    activeDataKey: void 0,
                    activeCoordinate: activeProps.activeCoordinate,
                  })
                );
            } else if ('item' === tooltipEventType) {
              var _target$getAttribute,
                _touch = touchEvent.touches[0];
              if (null == document.elementFromPoint || null == _touch) return;
              var target = document.elementFromPoint(_touch.clientX, _touch.clientY);
              if (!target || !target.getAttribute) return;
              var itemIndex = target.getAttribute(Constants.F0),
                graphicalItemId =
                  null !== (_target$getAttribute = target.getAttribute(Constants.yU)) &&
                  void 0 !== _target$getAttribute
                    ? _target$getAttribute
                    : void 0,
                settings = (0, tooltipSelectors.AA)(state).find(
                  (item) => item.id === graphicalItemId
                );
              if (null == itemIndex || null == settings || null == graphicalItemId) return;
              var { dataKey } = settings,
                coordinate = selectTooltipCoordinate(state, itemIndex, graphicalItemId);
              listenerApi.dispatch(
                (0, tooltipSlice.RD)({
                  activeDataKey: dataKey,
                  activeIndex: itemIndex,
                  activeCoordinate: coordinate,
                  activeGraphicalItemId: graphicalItemId,
                })
              );
            }
          }
        },
      });
    },
    './node_modules/recharts/es6/state/types/StackedGraphicalItem.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      function isStacked(graphicalItem) {
        return (
          'stackId' in graphicalItem &&
          null != graphicalItem.stackId &&
          null != graphicalItem.dataKey
        );
      }
      __webpack_require__.d(__webpack_exports__, { g: () => isStacked });
    },
    './node_modules/recharts/es6/state/zIndexSlice.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        B8: () => unregisterZIndexPortalElement,
        WO: () => registerZIndexPortalElement,
        ZV: () => unregisterZIndexPortal,
        v3: () => zIndexReducer,
        wR: () => registerZIndexPortal,
      });
      var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs'
        ),
        immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/immer/dist/immer.mjs'
        ),
        _zIndex_DefaultZIndexes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/zIndex/DefaultZIndexes.js'
        );
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var initialState = {
          zIndexMap: Object.values(_zIndex_DefaultZIndexes__WEBPACK_IMPORTED_MODULE_2__.I).reduce(
            (acc, current) =>
              _objectSpread(
                _objectSpread({}, acc),
                {},
                { [current]: { element: void 0, panoramaElement: void 0, consumers: 0 } }
              ),
            {}
          ),
        },
        defaultZIndexSet = new Set(
          Object.values(_zIndex_DefaultZIndexes__WEBPACK_IMPORTED_MODULE_2__.I)
        );
      var zIndexSlice = (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.Z0)({
          name: 'zIndex',
          initialState,
          reducers: {
            registerZIndexPortal: {
              reducer: (state, action) => {
                var { zIndex } = action.payload;
                state.zIndexMap[zIndex]
                  ? (state.zIndexMap[zIndex].consumers += 1)
                  : (state.zIndexMap[zIndex] = {
                      consumers: 1,
                      element: void 0,
                      panoramaElement: void 0,
                    });
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            unregisterZIndexPortal: {
              reducer: (state, action) => {
                var { zIndex } = action.payload;
                state.zIndexMap[zIndex] &&
                  ((state.zIndexMap[zIndex].consumers -= 1),
                  state.zIndexMap[zIndex].consumers <= 0 &&
                    !(function isDefaultZIndex(zIndex) {
                      return defaultZIndexSet.has(zIndex);
                    })(zIndex) &&
                    delete state.zIndexMap[zIndex]);
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            registerZIndexPortalElement: {
              reducer: (state, action) => {
                var { zIndex, element, isPanorama } = action.payload;
                state.zIndexMap[zIndex]
                  ? isPanorama
                    ? (state.zIndexMap[zIndex].panoramaElement = (0,
                      immer__WEBPACK_IMPORTED_MODULE_1__.h4)(element))
                    : (state.zIndexMap[zIndex].element = (0, immer__WEBPACK_IMPORTED_MODULE_1__.h4)(
                        element
                      ))
                  : (state.zIndexMap[zIndex] = {
                      consumers: 0,
                      element: isPanorama
                        ? void 0
                        : (0, immer__WEBPACK_IMPORTED_MODULE_1__.h4)(element),
                      panoramaElement: isPanorama
                        ? (0, immer__WEBPACK_IMPORTED_MODULE_1__.h4)(element)
                        : void 0,
                    });
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
            unregisterZIndexPortalElement: {
              reducer: (state, action) => {
                var { zIndex } = action.payload;
                state.zIndexMap[zIndex] &&
                  (action.payload.isPanorama
                    ? (state.zIndexMap[zIndex].panoramaElement = void 0)
                    : (state.zIndexMap[zIndex].element = void 0));
              },
              prepare: (0, _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.aA)(),
            },
          },
        }),
        {
          registerZIndexPortal,
          unregisterZIndexPortal,
          registerZIndexPortalElement,
          unregisterZIndexPortalElement,
        } = zIndexSlice.actions,
        zIndexReducer = zIndexSlice.reducer;
    },
    './node_modules/recharts/es6/synchronisation/useChartSynchronisation.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        l3: () => useSynchronisedEventsFromOtherCharts,
        m7: () => useTooltipChartSynchronisation,
      });
      var react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        hooks = __webpack_require__('./node_modules/recharts/es6/state/hooks.js'),
        rootPropsSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/rootPropsSelectors.js'
        ),
        eventemitter3 = __webpack_require__('./node_modules/eventemitter3/index.js');
      var Events_eventCenter = new (__webpack_require__.n(eventemitter3)())(),
        optionsSlice = __webpack_require__('./node_modules/recharts/es6/state/optionsSlice.js'),
        tooltipSlice = __webpack_require__('./node_modules/recharts/es6/state/tooltipSlice.js'),
        selectors = __webpack_require__('./node_modules/recharts/es6/state/selectors/selectors.js'),
        tooltipSelectors = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/tooltipSelectors.js'
        );
      function selectSynchronisedTooltipState(state) {
        return state.tooltip.syncInteraction;
      }
      var chartLayoutContext = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        chartDataSlice = __webpack_require__('./node_modules/recharts/es6/state/chartDataSlice.js'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        _excluded = ['x', 'y'];
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function useTooltipSyncEventsListener() {
        var mySyncId = (0, hooks.G)(rootPropsSelectors.lZ),
          myEventEmitter = (0, hooks.G)(rootPropsSelectors.pH),
          dispatch = (0, hooks.j)(),
          syncMethod = (0, hooks.G)(rootPropsSelectors.hX),
          tooltipTicks = (0, hooks.G)(tooltipSelectors.R4),
          layout = (0, chartLayoutContext.WX)(),
          viewBox = (0, chartLayoutContext.sk)(),
          className = (0, hooks.G)((state) => state.rootProps.className);
        (0, react.useEffect)(() => {
          if (null == mySyncId) return DataUtils.lQ;
          var listener = (incomingSyncId, action, emitter) => {
            var _action$payload;
            if (myEventEmitter !== emitter && mySyncId === incomingSyncId)
              if ('index' !== syncMethod) {
                if (null != tooltipTicks) {
                  var activeTick;
                  if ('function' == typeof syncMethod) {
                    var syncMethodParam = {
                        activeTooltipIndex:
                          null == action.payload.index ? void 0 : Number(action.payload.index),
                        isTooltipActive: action.payload.active,
                        activeIndex:
                          null == action.payload.index ? void 0 : Number(action.payload.index),
                        activeLabel: action.payload.label,
                        activeDataKey: action.payload.dataKey,
                        activeCoordinate: action.payload.coordinate,
                      },
                      activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);
                    activeTick = tooltipTicks[activeTooltipIndex];
                  } else
                    'value' === syncMethod &&
                      (activeTick = tooltipTicks.find(
                        (tick) => String(tick.value) === action.payload.label
                      ));
                  var { coordinate } = action.payload;
                  if (
                    null != activeTick &&
                    !1 !== action.payload.active &&
                    null != coordinate &&
                    null != viewBox
                  ) {
                    var { x, y } = coordinate,
                      validateChartX = Math.min(x, viewBox.x + viewBox.width),
                      validateChartY = Math.min(y, viewBox.y + viewBox.height),
                      activeCoordinate = {
                        x: 'horizontal' === layout ? activeTick.coordinate : validateChartX,
                        y: 'horizontal' === layout ? validateChartY : activeTick.coordinate,
                      },
                      syncAction = (0, tooltipSlice.E1)({
                        active: action.payload.active,
                        coordinate: activeCoordinate,
                        dataKey: action.payload.dataKey,
                        index: String(activeTick.index),
                        label: action.payload.label,
                        sourceViewBox: action.payload.sourceViewBox,
                        graphicalItemId: action.payload.graphicalItemId,
                      });
                    dispatch(syncAction);
                  } else
                    dispatch(
                      (0, tooltipSlice.E1)({
                        active: !1,
                        coordinate: void 0,
                        dataKey: void 0,
                        index: null,
                        label: void 0,
                        sourceViewBox: void 0,
                        graphicalItemId: void 0,
                      })
                    );
                }
              } else if (
                viewBox &&
                null != action &&
                null !== (_action$payload = action.payload) &&
                void 0 !== _action$payload &&
                _action$payload.coordinate &&
                action.payload.sourceViewBox
              ) {
                var _action$payload$coord = action.payload.coordinate,
                  { x: _x, y: _y } = _action$payload$coord,
                  otherCoordinateProps = (function _objectWithoutProperties(e, t) {
                    if (null == e) return {};
                    var o,
                      r,
                      i = (function _objectWithoutPropertiesLoose(r, e) {
                        if (null == r) return {};
                        var t = {};
                        for (var n in r)
                          if ({}.hasOwnProperty.call(r, n)) {
                            if (-1 !== e.indexOf(n)) continue;
                            t[n] = r[n];
                          }
                        return t;
                      })(e, t);
                    if (Object.getOwnPropertySymbols) {
                      var n = Object.getOwnPropertySymbols(e);
                      for (r = 0; r < n.length; r++)
                        ((o = n[r]),
                          -1 === t.indexOf(o) &&
                            {}.propertyIsEnumerable.call(e, o) &&
                            (i[o] = e[o]));
                    }
                    return i;
                  })(_action$payload$coord, _excluded),
                  {
                    x: sourceX,
                    y: sourceY,
                    width: sourceWidth,
                    height: sourceHeight,
                  } = action.payload.sourceViewBox,
                  scaledCoordinate = _objectSpread(
                    _objectSpread({}, otherCoordinateProps),
                    {},
                    {
                      x:
                        viewBox.x +
                        (sourceWidth ? (_x - sourceX) / sourceWidth : 0) * viewBox.width,
                      y:
                        viewBox.y +
                        (sourceHeight ? (_y - sourceY) / sourceHeight : 0) * viewBox.height,
                    }
                  );
                dispatch(
                  _objectSpread(
                    _objectSpread({}, action),
                    {},
                    {
                      payload: _objectSpread(
                        _objectSpread({}, action.payload),
                        {},
                        { coordinate: scaledCoordinate }
                      ),
                    }
                  )
                );
              } else dispatch(action);
          };
          return (
            Events_eventCenter.on('recharts.syncEvent.tooltip', listener),
            () => {
              Events_eventCenter.off('recharts.syncEvent.tooltip', listener);
            }
          );
        }, [
          className,
          dispatch,
          myEventEmitter,
          mySyncId,
          syncMethod,
          tooltipTicks,
          layout,
          viewBox,
        ]);
      }
      function useSynchronisedEventsFromOtherCharts() {
        var dispatch = (0, hooks.j)();
        ((0, react.useEffect)(() => {
          dispatch((0, optionsSlice.dl)());
        }, [dispatch]),
          useTooltipSyncEventsListener(),
          (function useBrushSyncEventsListener() {
            var mySyncId = (0, hooks.G)(rootPropsSelectors.lZ),
              myEventEmitter = (0, hooks.G)(rootPropsSelectors.pH),
              dispatch = (0, hooks.j)();
            (0, react.useEffect)(() => {
              if (null == mySyncId) return DataUtils.lQ;
              var listener = (incomingSyncId, action, emitter) => {
                myEventEmitter !== emitter &&
                  mySyncId === incomingSyncId &&
                  dispatch((0, chartDataSlice.M)(action));
              };
              return (
                Events_eventCenter.on('recharts.syncEvent.brush', listener),
                () => {
                  Events_eventCenter.off('recharts.syncEvent.brush', listener);
                }
              );
            }, [dispatch, myEventEmitter, mySyncId]);
          })());
      }
      function useTooltipChartSynchronisation(
        tooltipEventType,
        trigger,
        activeCoordinate,
        activeLabel,
        activeIndex,
        isTooltipActive
      ) {
        var activeDataKey = (0, hooks.G)((state) =>
            (0, selectors.dp)(state, tooltipEventType, trigger)
          ),
          eventEmitterSymbol = (0, hooks.G)(rootPropsSelectors.pH),
          syncId = (0, hooks.G)(rootPropsSelectors.lZ),
          syncMethod = (0, hooks.G)(rootPropsSelectors.hX),
          tooltipState = (0, hooks.G)(selectSynchronisedTooltipState),
          isReceivingSynchronisation = null == tooltipState ? void 0 : tooltipState.active,
          viewBox = (0, chartLayoutContext.sk)();
        (0, react.useEffect)(() => {
          if (!isReceivingSynchronisation && null != syncId && null != eventEmitterSymbol) {
            var syncAction = (0, tooltipSlice.E1)({
              active: isTooltipActive,
              coordinate: activeCoordinate,
              dataKey: activeDataKey,
              index: activeIndex,
              label: 'number' == typeof activeLabel ? String(activeLabel) : activeLabel,
              sourceViewBox: viewBox,
              graphicalItemId: void 0,
            });
            Events_eventCenter.emit(
              'recharts.syncEvent.tooltip',
              syncId,
              syncAction,
              eventEmitterSymbol
            );
          }
        }, [
          isReceivingSynchronisation,
          activeCoordinate,
          activeDataKey,
          activeIndex,
          activeLabel,
          eventEmitterSymbol,
          syncId,
          syncMethod,
          isTooltipActive,
          viewBox,
        ]);
      }
    },
    './node_modules/recharts/es6/util/ActiveShapeUtils.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { y: () => Shape });
      var _templateObject,
        _templateObject2,
        _templateObject3,
        _templateObject4,
        _templateObject5,
        react = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        isPlainObject = __webpack_require__('./node_modules/es-toolkit/compat/isPlainObject.js'),
        isPlainObject_default = __webpack_require__.n(isPlainObject),
        Rectangle = __webpack_require__('./node_modules/recharts/es6/shape/Rectangle.js'),
        clsx = __webpack_require__('./node_modules/clsx/dist/clsx.mjs'),
        resolveDefaultProps = __webpack_require__(
          './node_modules/recharts/es6/util/resolveDefaultProps.js'
        ),
        JavascriptAnimate = __webpack_require__(
          './node_modules/recharts/es6/animation/JavascriptAnimate.js'
        ),
        useAnimationId = __webpack_require__('./node_modules/recharts/es6/util/useAnimationId.js'),
        DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        util = __webpack_require__('./node_modules/recharts/es6/animation/util.js'),
        svgPropertiesAndEvents = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesAndEvents.js'
        ),
        round = __webpack_require__('./node_modules/recharts/es6/util/round.js');
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function _extends() {
        return (
          (_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          _extends.apply(null, arguments)
        );
      }
      function _taggedTemplateLiteral(e, t) {
        return (
          t || (t = e.slice(0)),
          Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } }))
        );
      }
      var getTrapezoidPath = (x, y, upperWidth, lowerWidth, height) => {
          var path,
            widthGap = upperWidth - lowerWidth;
          return (
            (path = (0, round.Y)(
              _templateObject || (_templateObject = _taggedTemplateLiteral(['M ', ',', ''])),
              x,
              y
            )),
            (path += (0, round.Y)(
              _templateObject2 || (_templateObject2 = _taggedTemplateLiteral(['L ', ',', ''])),
              x + upperWidth,
              y
            )),
            (path += (0, round.Y)(
              _templateObject3 || (_templateObject3 = _taggedTemplateLiteral(['L ', ',', ''])),
              x + upperWidth - widthGap / 2,
              y + height
            )),
            (path += (0, round.Y)(
              _templateObject4 || (_templateObject4 = _taggedTemplateLiteral(['L ', ',', ''])),
              x + upperWidth - widthGap / 2 - lowerWidth,
              y + height
            )),
            (path += (0, round.Y)(
              _templateObject5 || (_templateObject5 = _taggedTemplateLiteral(['L ', ',', ' Z'])),
              x,
              y
            ))
          );
        },
        defaultTrapezoidProps = {
          x: 0,
          y: 0,
          upperWidth: 0,
          lowerWidth: 0,
          height: 0,
          isUpdateAnimationActive: !1,
          animationBegin: 0,
          animationDuration: 1500,
          animationEasing: 'ease',
        },
        Trapezoid = (outsideProps) => {
          var trapezoidProps = (0, resolveDefaultProps.e)(outsideProps, defaultTrapezoidProps),
            { x, y, upperWidth, lowerWidth, height, className } = trapezoidProps,
            { animationEasing, animationDuration, animationBegin, isUpdateAnimationActive } =
              trapezoidProps,
            pathRef = (0, react.useRef)(null),
            [totalLength, setTotalLength] = (0, react.useState)(-1),
            prevUpperWidthRef = (0, react.useRef)(upperWidth),
            prevLowerWidthRef = (0, react.useRef)(lowerWidth),
            prevHeightRef = (0, react.useRef)(height),
            prevXRef = (0, react.useRef)(x),
            prevYRef = (0, react.useRef)(y),
            animationId = (0, useAnimationId.n)(outsideProps, 'trapezoid-');
          if (
            ((0, react.useEffect)(() => {
              if (pathRef.current && pathRef.current.getTotalLength)
                try {
                  var pathTotalLength = pathRef.current.getTotalLength();
                  pathTotalLength && setTotalLength(pathTotalLength);
                } catch (_unused) {}
            }, []),
            x !== +x ||
              y !== +y ||
              upperWidth !== +upperWidth ||
              lowerWidth !== +lowerWidth ||
              height !== +height ||
              (0 === upperWidth && 0 === lowerWidth) ||
              0 === height)
          )
            return null;
          var layerClass = (0, clsx.$)('recharts-trapezoid', className);
          if (!isUpdateAnimationActive)
            return react.createElement(
              'g',
              null,
              react.createElement(
                'path',
                _extends({}, (0, svgPropertiesAndEvents.a)(trapezoidProps), {
                  className: layerClass,
                  d: getTrapezoidPath(x, y, upperWidth, lowerWidth, height),
                })
              )
            );
          var prevUpperWidth = prevUpperWidthRef.current,
            prevLowerWidth = prevLowerWidthRef.current,
            prevHeight = prevHeightRef.current,
            prevX = prevXRef.current,
            prevY = prevYRef.current,
            from = '0px '.concat(-1 === totalLength ? 1 : totalLength, 'px'),
            to = ''.concat(totalLength, 'px 0px'),
            transition = (0, util.dl)(['strokeDasharray'], animationDuration, animationEasing);
          return react.createElement(
            JavascriptAnimate.J,
            {
              animationId,
              key: animationId,
              canBegin: totalLength > 0,
              duration: animationDuration,
              easing: animationEasing,
              isActive: isUpdateAnimationActive,
              begin: animationBegin,
            },
            (t) => {
              var currUpperWidth = (0, DataUtils.GW)(prevUpperWidth, upperWidth, t),
                currLowerWidth = (0, DataUtils.GW)(prevLowerWidth, lowerWidth, t),
                currHeight = (0, DataUtils.GW)(prevHeight, height, t),
                currX = (0, DataUtils.GW)(prevX, x, t),
                currY = (0, DataUtils.GW)(prevY, y, t);
              pathRef.current &&
                ((prevUpperWidthRef.current = currUpperWidth),
                (prevLowerWidthRef.current = currLowerWidth),
                (prevHeightRef.current = currHeight),
                (prevXRef.current = currX),
                (prevYRef.current = currY));
              var animationStyle =
                t > 0 ? { transition, strokeDasharray: to } : { strokeDasharray: from };
              return react.createElement(
                'path',
                _extends({}, (0, svgPropertiesAndEvents.a)(trapezoidProps), {
                  className: layerClass,
                  d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
                  ref: pathRef,
                  style: _objectSpread(_objectSpread({}, animationStyle), trapezoidProps.style),
                })
              );
            }
          );
        },
        Sector = __webpack_require__('./node_modules/recharts/es6/shape/Sector.js'),
        Layer = __webpack_require__('./node_modules/recharts/es6/container/Layer.js');
      (Math.abs, Math.atan2);
      const cos = Math.cos,
        sin = (Math.max, Math.min, Math.sin),
        sqrt = Math.sqrt,
        pi = Math.PI,
        tau = 2 * pi;
      const circle = {
          draw(context, size) {
            const r = sqrt(size / pi);
            (context.moveTo(r, 0), context.arc(0, 0, r, 0, tau));
          },
        },
        cross = {
          draw(context, size) {
            const r = sqrt(size / 5) / 2;
            (context.moveTo(-3 * r, -r),
              context.lineTo(-r, -r),
              context.lineTo(-r, -3 * r),
              context.lineTo(r, -3 * r),
              context.lineTo(r, -r),
              context.lineTo(3 * r, -r),
              context.lineTo(3 * r, r),
              context.lineTo(r, r),
              context.lineTo(r, 3 * r),
              context.lineTo(-r, 3 * r),
              context.lineTo(-r, r),
              context.lineTo(-3 * r, r),
              context.closePath());
          },
        },
        tan30 = sqrt(1 / 3),
        tan30_2 = 2 * tan30,
        diamond = {
          draw(context, size) {
            const y = sqrt(size / tan30_2),
              x = y * tan30;
            (context.moveTo(0, -y),
              context.lineTo(x, 0),
              context.lineTo(0, y),
              context.lineTo(-x, 0),
              context.closePath());
          },
        },
        square = {
          draw(context, size) {
            const w = sqrt(size),
              x = -w / 2;
            context.rect(x, x, w, w);
          },
        },
        kr = sin(pi / 10) / sin((7 * pi) / 10),
        kx = sin(tau / 10) * kr,
        ky = -cos(tau / 10) * kr,
        star = {
          draw(context, size) {
            const r = sqrt(0.8908130915292852 * size),
              x = kx * r,
              y = ky * r;
            (context.moveTo(0, -r), context.lineTo(x, y));
            for (let i = 1; i < 5; ++i) {
              const a = (tau * i) / 5,
                c = cos(a),
                s = sin(a);
              (context.lineTo(s * r, -c * r), context.lineTo(c * x - s * y, s * x + c * y));
            }
            context.closePath();
          },
        },
        sqrt3 = sqrt(3),
        triangle = {
          draw(context, size) {
            const y = -sqrt(size / (3 * sqrt3));
            (context.moveTo(0, 2 * y),
              context.lineTo(-sqrt3 * y, -y),
              context.lineTo(sqrt3 * y, -y),
              context.closePath());
          },
        },
        c = -0.5,
        s = sqrt(3) / 2,
        k = 1 / sqrt(12),
        a = 3 * (k / 2 + 1),
        wye = {
          draw(context, size) {
            const r = sqrt(size / a),
              x0 = r / 2,
              y0 = r * k,
              x1 = x0,
              y1 = r * k + r,
              x2 = -x1,
              y2 = y1;
            (context.moveTo(x0, y0),
              context.lineTo(x1, y1),
              context.lineTo(x2, y2),
              context.lineTo(c * x0 - s * y0, s * x0 + c * y0),
              context.lineTo(c * x1 - s * y1, s * x1 + c * y1),
              context.lineTo(c * x2 - s * y2, s * x2 + c * y2),
              context.lineTo(c * x0 + s * y0, c * y0 - s * x0),
              context.lineTo(c * x1 + s * y1, c * y1 - s * x1),
              context.lineTo(c * x2 + s * y2, c * y2 - s * x2),
              context.closePath());
          },
        };
      var constant = __webpack_require__('./node_modules/d3-shape/src/constant.js'),
        src_path = __webpack_require__('./node_modules/d3-shape/src/path.js');
      (sqrt(3), sqrt(3));
      var _excluded = ['type', 'size', 'sizeType'];
      function Symbols_extends() {
        return (
          (Symbols_extends = Object.assign
            ? Object.assign.bind()
            : function (n) {
                for (var e = 1; e < arguments.length; e++) {
                  var t = arguments[e];
                  for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
              }),
          Symbols_extends.apply(null, arguments)
        );
      }
      function Symbols_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function Symbols_objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? Symbols_ownKeys(Object(t), !0).forEach(function (r) {
                Symbols_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : Symbols_ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function Symbols_defineProperty(e, r, t) {
        return (
          (r = (function Symbols_toPropertyKey(t) {
            var i = (function Symbols_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var symbolFactories = {
          symbolCircle: circle,
          symbolCross: cross,
          symbolDiamond: diamond,
          symbolSquare: square,
          symbolStar: star,
          symbolTriangle: triangle,
          symbolWye: wye,
        },
        RADIAN = Math.PI / 180,
        Symbols = (_ref) => {
          var { type = 'circle', size = 64, sizeType = 'area' } = _ref,
            props = Symbols_objectSpread(
              Symbols_objectSpread(
                {},
                (function _objectWithoutProperties(e, t) {
                  if (null == e) return {};
                  var o,
                    r,
                    i = (function _objectWithoutPropertiesLoose(r, e) {
                      if (null == r) return {};
                      var t = {};
                      for (var n in r)
                        if ({}.hasOwnProperty.call(r, n)) {
                          if (-1 !== e.indexOf(n)) continue;
                          t[n] = r[n];
                        }
                      return t;
                    })(e, t);
                  if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    for (r = 0; r < n.length; r++)
                      ((o = n[r]),
                        -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
                  }
                  return i;
                })(_ref, _excluded)
              ),
              {},
              { type, size, sizeType }
            ),
            realType = 'circle';
          'string' == typeof type && (realType = type);
          var { className, cx, cy } = props,
            filteredProps = (0, svgPropertiesAndEvents.a)(props);
          return (0, DataUtils.Et)(cx) && (0, DataUtils.Et)(cy) && (0, DataUtils.Et)(size)
            ? react.createElement(
                'path',
                Symbols_extends({}, filteredProps, {
                  className: (0, clsx.$)('recharts-symbols', className),
                  transform: 'translate('.concat(cx, ', ').concat(cy, ')'),
                  d: (() => {
                    var symbolFactory = ((type) => {
                        var name = 'symbol'.concat((0, DataUtils.Zb)(type));
                        return symbolFactories[name] || circle;
                      })(realType),
                      symbol = (function symbol_Symbol(type, size) {
                        let context = null,
                          path = (0, src_path.i)(symbol);
                        function symbol() {
                          let buffer;
                          if (
                            (context || (context = buffer = path()),
                            type.apply(this, arguments).draw(context, +size.apply(this, arguments)),
                            buffer)
                          )
                            return ((context = null), buffer + '' || null);
                        }
                        return (
                          (type =
                            'function' == typeof type ? type : (0, constant.A)(type || circle)),
                          (size =
                            'function' == typeof size
                              ? size
                              : (0, constant.A)(void 0 === size ? 64 : +size)),
                          (symbol.type = function (_) {
                            return arguments.length
                              ? ((type = 'function' == typeof _ ? _ : (0, constant.A)(_)), symbol)
                              : type;
                          }),
                          (symbol.size = function (_) {
                            return arguments.length
                              ? ((size = 'function' == typeof _ ? _ : (0, constant.A)(+_)), symbol)
                              : size;
                          }),
                          (symbol.context = function (_) {
                            return arguments.length
                              ? ((context = null == _ ? null : _), symbol)
                              : context;
                          }),
                          symbol
                        );
                      })()
                        .type(symbolFactory)
                        .size(
                          ((size, sizeType, type) => {
                            if ('area' === sizeType) return size;
                            switch (type) {
                              case 'cross':
                                return (5 * size * size) / 9;
                              case 'diamond':
                                return (0.5 * size * size) / Math.sqrt(3);
                              case 'square':
                                return size * size;
                              case 'star':
                                var angle = 18 * RADIAN;
                                return (
                                  1.25 *
                                  size *
                                  size *
                                  (Math.tan(angle) - Math.tan(2 * angle) * Math.tan(angle) ** 2)
                                );
                              case 'triangle':
                                return (Math.sqrt(3) * size * size) / 4;
                              case 'wye':
                                return ((21 - 10 * Math.sqrt(3)) * size * size) / 8;
                              default:
                                return (Math.PI * size * size) / 4;
                            }
                          })(size, sizeType, realType)
                        ),
                      s = symbol();
                    if (null !== s) return s;
                  })(),
                })
              )
            : null;
        };
      Symbols.registerSymbol = (key, factory) => {
        symbolFactories['symbol'.concat((0, DataUtils.Zb)(key))] = factory;
      };
      var Curve = __webpack_require__('./node_modules/recharts/es6/shape/Curve.js'),
        ActiveShapeUtils_excluded = ['option', 'shapeType', 'activeClassName'];
      function ActiveShapeUtils_ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function ActiveShapeUtils_objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ActiveShapeUtils_ownKeys(Object(t), !0).forEach(function (r) {
                ActiveShapeUtils_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ActiveShapeUtils_ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function ActiveShapeUtils_defineProperty(e, r, t) {
        return (
          (r = (function ActiveShapeUtils_toPropertyKey(t) {
            var i = (function ActiveShapeUtils_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function ShapeSelector(_ref) {
        var { shapeType, elementProps } = _ref;
        switch (shapeType) {
          case 'rectangle':
            return react.createElement(Rectangle.M, elementProps);
          case 'trapezoid':
            return react.createElement(Trapezoid, elementProps);
          case 'sector':
            return react.createElement(Sector.h, elementProps);
          case 'symbols':
            if (
              (function isSymbolsProps(shapeType, _elementProps) {
                return 'symbols' === shapeType;
              })(shapeType)
            )
              return react.createElement(Symbols, elementProps);
            break;
          case 'curve':
            return react.createElement(Curve.I, elementProps);
          default:
            return null;
        }
      }
      function Shape(_ref2) {
        var shape,
          { option, shapeType, activeClassName = 'recharts-active-shape' } = _ref2,
          props = (function ActiveShapeUtils_objectWithoutProperties(e, t) {
            if (null == e) return {};
            var o,
              r,
              i = (function ActiveShapeUtils_objectWithoutPropertiesLoose(r, e) {
                if (null == r) return {};
                var t = {};
                for (var n in r)
                  if ({}.hasOwnProperty.call(r, n)) {
                    if (-1 !== e.indexOf(n)) continue;
                    t[n] = r[n];
                  }
                return t;
              })(e, t);
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              for (r = 0; r < n.length; r++)
                ((o = n[r]),
                  -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
            }
            return i;
          })(_ref2, ActiveShapeUtils_excluded);
        if ((0, react.isValidElement)(option))
          shape = (0, react.cloneElement)(
            option,
            ActiveShapeUtils_objectSpread(
              ActiveShapeUtils_objectSpread({}, props),
              (function getPropsFromShapeOption(option) {
                return (0, react.isValidElement)(option) ? option.props : option;
              })(option)
            )
          );
        else if ('function' == typeof option) shape = option(props, props.index);
        else if (isPlainObject_default()(option) && 'boolean' != typeof option) {
          var nextProps = (function defaultPropTransformer(option, props) {
            return ActiveShapeUtils_objectSpread(ActiveShapeUtils_objectSpread({}, props), option);
          })(option, props);
          shape = react.createElement(ShapeSelector, { shapeType, elementProps: nextProps });
        } else {
          var elementProps = props;
          shape = react.createElement(ShapeSelector, { shapeType, elementProps });
        }
        return props.isActive
          ? react.createElement(Layer.W, { className: activeClassName }, shape)
          : shape;
      }
    },
    './node_modules/recharts/es6/util/ChartUtils.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        qx: () => MAX_VALUE_REG,
        IH: () => MIN_VALUE_REG,
        s0: () => appendOffsetOfLegend,
        sr: () => calculateCartesianTooltipPos,
        eB: () => calculatePolarTooltipPos,
        YB: () => checkDomainOfScale,
        Hj: () => getBandSizeOfAxis,
        DW: () => getBaseValueOfBar,
        y2: () => getCateCoordinateOfBar,
        Mk: () => getDomainOfStackGroups,
        $8: () => getNormalizedStackId,
        yy: () => getStackedData,
        GF: () => getTooltipEntry,
        uM: () => getTooltipNameProp,
        kr: () => getValueByDataKey,
        _L: () => isCategoricalAxis,
        _f: () => truncateByDomain,
      });
      var sortBy = __webpack_require__('./node_modules/es-toolkit/compat/sortBy.js'),
        sortBy_default = __webpack_require__.n(sortBy),
        get = __webpack_require__('./node_modules/es-toolkit/compat/get.js'),
        get_default = __webpack_require__.n(get);
      function none(series, order) {
        if ((n = series.length) > 1)
          for (var j, s0, n, i = 1, s1 = series[order[0]], m = s1.length; i < n; ++i)
            for (s0 = s1, s1 = series[order[i]], j = 0; j < m; ++j)
              s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
      var array = __webpack_require__('./node_modules/d3-shape/src/array.js'),
        constant = __webpack_require__('./node_modules/d3-shape/src/constant.js');
      function order_none(series) {
        for (var n = series.length, o = new Array(n); --n >= 0; ) o[n] = n;
        return o;
      }
      function stackValue(d, key) {
        return d[key];
      }
      function stackSeries(key) {
        const series = [];
        return ((series.key = key), series);
      }
      var DataUtils = __webpack_require__('./node_modules/recharts/es6/util/DataUtils.js'),
        getSliced = __webpack_require__('./node_modules/recharts/es6/util/getSliced.js'),
        isWellBehavedNumber = __webpack_require__(
          './node_modules/recharts/es6/util/isWellBehavedNumber.js'
        );
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function getValueByDataKey(obj, dataKey, defaultValue) {
        return (0, DataUtils.uy)(obj) || (0, DataUtils.uy)(dataKey)
          ? defaultValue
          : (0, DataUtils.vh)(dataKey)
            ? get_default()(obj, dataKey, defaultValue)
            : 'function' == typeof dataKey
              ? dataKey(obj)
              : defaultValue;
      }
      var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {
          if (legendSettings && legendSize) {
            var { width: boxWidth, height: boxHeight } = legendSize,
              { align, verticalAlign, layout } = legendSettings;
            if (
              ('vertical' === layout || ('horizontal' === layout && 'middle' === verticalAlign)) &&
              'center' !== align &&
              (0, DataUtils.Et)(offset[align])
            )
              return _objectSpread(
                _objectSpread({}, offset),
                {},
                { [align]: offset[align] + (boxWidth || 0) }
              );
            if (
              ('horizontal' === layout || ('vertical' === layout && 'center' === align)) &&
              'middle' !== verticalAlign &&
              (0, DataUtils.Et)(offset[verticalAlign])
            )
              return _objectSpread(
                _objectSpread({}, offset),
                {},
                { [verticalAlign]: offset[verticalAlign] + (boxHeight || 0) }
              );
          }
          return offset;
        },
        isCategoricalAxis = (layout, axisType) =>
          ('horizontal' === layout && 'xAxis' === axisType) ||
          ('vertical' === layout && 'yAxis' === axisType) ||
          ('centric' === layout && 'angleAxis' === axisType) ||
          ('radial' === layout && 'radiusAxis' === axisType),
        checkDomainOfScale = (scale) => {
          var domain = scale.domain();
          if (domain && !(domain.length <= 2)) {
            var len = domain.length,
              range = scale.range(),
              minValue = Math.min(range[0], range[1]) - 1e-4,
              maxValue = Math.max(range[0], range[1]) + 1e-4,
              first = scale(domain[0]),
              last = scale(domain[len - 1]);
            (first < minValue || first > maxValue || last < minValue || last > maxValue) &&
              scale.domain([domain[0], domain[len - 1]]);
          }
        },
        truncateByDomain = (value, domain) => {
          if (
            !domain ||
            2 !== domain.length ||
            !(0, DataUtils.Et)(domain[0]) ||
            !(0, DataUtils.Et)(domain[1])
          )
            return value;
          var minValue = Math.min(domain[0], domain[1]),
            maxValue = Math.max(domain[0], domain[1]),
            result = [value[0], value[1]];
          return (
            (!(0, DataUtils.Et)(value[0]) || value[0] < minValue) && (result[0] = minValue),
            (!(0, DataUtils.Et)(value[1]) || value[1] > maxValue) && (result[1] = maxValue),
            result[0] > maxValue && (result[0] = maxValue),
            result[1] < minValue && (result[1] = minValue),
            result
          );
        },
        STACK_OFFSET_MAP = {
          sign: (series) => {
            var _series$,
              n = series.length;
            if (!(n <= 0)) {
              var m =
                null === (_series$ = series[0]) || void 0 === _series$ ? void 0 : _series$.length;
              if (!(null == m || m <= 0))
                for (var j = 0; j < m; ++j)
                  for (var positive = 0, negative = 0, i = 0; i < n; ++i) {
                    var row = series[i],
                      col = null == row ? void 0 : row[j];
                    if (null != col) {
                      var series1 = col[1],
                        series0 = col[0],
                        value = (0, DataUtils.M8)(series1) ? series0 : series1;
                      value >= 0
                        ? ((col[0] = positive), (col[1] = positive + value), (positive = series1))
                        : ((col[0] = negative), (col[1] = negative + value), (negative = series1));
                    }
                  }
            }
          },
          expand: function expand(series, order) {
            if ((n = series.length) > 0) {
              for (var i, n, y, j = 0, m = series[0].length; j < m; ++j) {
                for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
                if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
              }
              none(series, order);
            }
          },
          none,
          silhouette: function silhouette(series, order) {
            if ((n = series.length) > 0) {
              for (var n, j = 0, s0 = series[order[0]], m = s0.length; j < m; ++j) {
                for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
                s0[j][1] += s0[j][0] = -y / 2;
              }
              none(series, order);
            }
          },
          wiggle: function wiggle(series, order) {
            if ((n = series.length) > 0 && (m = (s0 = series[order[0]]).length) > 0) {
              for (var s0, m, n, y = 0, j = 1; j < m; ++j) {
                for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
                  for (
                    var si = series[order[i]],
                      sij0 = si[j][1] || 0,
                      s3 = (sij0 - (si[j - 1][1] || 0)) / 2,
                      k = 0;
                    k < i;
                    ++k
                  ) {
                    var sk = series[order[k]];
                    s3 += (sk[j][1] || 0) - (sk[j - 1][1] || 0);
                  }
                  ((s1 += sij0), (s2 += s3 * sij0));
                }
                ((s0[j - 1][1] += s0[j - 1][0] = y), s1 && (y -= s2 / s1));
              }
              ((s0[j - 1][1] += s0[j - 1][0] = y), none(series, order));
            }
          },
          positive: (series) => {
            var _series$2,
              n = series.length;
            if (!(n <= 0)) {
              var m =
                null === (_series$2 = series[0]) || void 0 === _series$2
                  ? void 0
                  : _series$2.length;
              if (!(null == m || m <= 0))
                for (var j = 0; j < m; ++j)
                  for (var positive = 0, i = 0; i < n; ++i) {
                    var row = series[i],
                      col = null == row ? void 0 : row[j];
                    if (null != col) {
                      var value = (0, DataUtils.M8)(col[1]) ? col[0] : col[1];
                      value >= 0
                        ? ((col[0] = positive), (col[1] = positive + value), (positive = col[1]))
                        : ((col[0] = 0), (col[1] = 0));
                    }
                  }
            }
          },
        },
        getStackedData = (data, dataKeys, offsetType) => {
          var _STACK_OFFSET_MAP$off,
            offsetAccessor =
              null !== (_STACK_OFFSET_MAP$off = STACK_OFFSET_MAP[offsetType]) &&
              void 0 !== _STACK_OFFSET_MAP$off
                ? _STACK_OFFSET_MAP$off
                : none,
            stack = (function src_stack() {
              var keys = (0, constant.A)([]),
                order = order_none,
                offset = none,
                value = stackValue;
              function stack(data) {
                var i,
                  oz,
                  sz = Array.from(keys.apply(this, arguments), stackSeries),
                  n = sz.length,
                  j = -1;
                for (const d of data)
                  for (i = 0, ++j; i < n; ++i)
                    (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
                for (i = 0, oz = (0, array.A)(order(sz)); i < n; ++i) sz[oz[i]].index = i;
                return (offset(sz, oz), sz);
              }
              return (
                (stack.keys = function (_) {
                  return arguments.length
                    ? ((keys = 'function' == typeof _ ? _ : (0, constant.A)(Array.from(_))), stack)
                    : keys;
                }),
                (stack.value = function (_) {
                  return arguments.length
                    ? ((value = 'function' == typeof _ ? _ : (0, constant.A)(+_)), stack)
                    : value;
                }),
                (stack.order = function (_) {
                  return arguments.length
                    ? ((order =
                        null == _
                          ? order_none
                          : 'function' == typeof _
                            ? _
                            : (0, constant.A)(Array.from(_))),
                      stack)
                    : order;
                }),
                (stack.offset = function (_) {
                  return arguments.length ? ((offset = null == _ ? none : _), stack) : offset;
                }),
                stack
              );
            })()
              .keys(dataKeys)
              .value((d, key) => Number(getValueByDataKey(d, key, 0)))
              .order(order_none)
              .offset(offsetAccessor),
            result = stack(data);
          return (
            result.forEach((series, seriesIndex) => {
              series.forEach((point, pointIndex) => {
                var value = getValueByDataKey(data[pointIndex], dataKeys[seriesIndex], 0);
                Array.isArray(value) &&
                  2 === value.length &&
                  (0, DataUtils.Et)(value[0]) &&
                  (0, DataUtils.Et)(value[1]) &&
                  ((point[0] = value[0]), (point[1] = value[1]));
              });
            }),
            result
          );
        };
      function getNormalizedStackId(publicStackId) {
        return null == publicStackId ? void 0 : String(publicStackId);
      }
      var getCateCoordinateOfBar = (_ref2) => {
          var { axis, ticks, offset, bandSize, entry, index } = _ref2;
          if ('category' === axis.type)
            return ticks[index] ? ticks[index].coordinate + offset : null;
          var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);
          return (0, DataUtils.uy)(value) ? null : axis.scale(value) - bandSize / 2 + offset;
        },
        getBaseValueOfBar = (_ref3) => {
          var { numericAxis } = _ref3,
            domain = numericAxis.scale.domain();
          if ('number' === numericAxis.type) {
            var minValue = Math.min(domain[0], domain[1]),
              maxValue = Math.max(domain[0], domain[1]);
            return minValue <= 0 && maxValue >= 0 ? 0 : maxValue < 0 ? maxValue : minValue;
          }
          return domain[0];
        },
        getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {
          var domain;
          if (null != stackGroups)
            return [
              (domain = Object.keys(stackGroups).reduce(
                (result, stackId) => {
                  var group = stackGroups[stackId];
                  if (!group) return result;
                  var { stackedData } = group,
                    domain = stackedData.reduce(
                      (res, entry) => {
                        var flat,
                          sliced = (0, getSliced.v)(entry, startIndex, endIndex),
                          s =
                            ((flat = sliced.flat(2).filter(DataUtils.Et)),
                            [Math.min(...flat), Math.max(...flat)]);
                        return (0, isWellBehavedNumber.H)(s[0]) && (0, isWellBehavedNumber.H)(s[1])
                          ? [Math.min(res[0], s[0]), Math.max(res[1], s[1])]
                          : res;
                      },
                      [1 / 0, -1 / 0]
                    );
                  return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
                },
                [1 / 0, -1 / 0]
              ))[0] ===
              1 / 0
                ? 0
                : domain[0],
              domain[1] === -1 / 0 ? 0 : domain[1],
            ];
        },
        MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/,
        MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/,
        getBandSizeOfAxis = (axis, ticks, isBar) => {
          if (axis && axis.scale && axis.scale.bandwidth) {
            var bandWidth = axis.scale.bandwidth();
            if (!isBar || bandWidth > 0) return bandWidth;
          }
          if (axis && ticks && ticks.length >= 2) {
            for (
              var orderedTicks = sortBy_default()(ticks, (o) => o.coordinate),
                bandSize = 1 / 0,
                i = 1,
                len = orderedTicks.length;
              i < len;
              i++
            ) {
              var cur = orderedTicks[i],
                prev = orderedTicks[i - 1];
              bandSize = Math.min(
                ((null == cur ? void 0 : cur.coordinate) || 0) -
                  ((null == prev ? void 0 : prev.coordinate) || 0),
                bandSize
              );
            }
            return bandSize === 1 / 0 ? 0 : bandSize;
          }
          return isBar ? void 0 : 0;
        };
      function getTooltipEntry(_ref4) {
        var { tooltipEntrySettings, dataKey, payload, value, name } = _ref4;
        return _objectSpread(
          _objectSpread({}, tooltipEntrySettings),
          {},
          { dataKey, payload, value, name }
        );
      }
      function getTooltipNameProp(nameFromItem, dataKey) {
        return nameFromItem ? String(nameFromItem) : 'string' == typeof dataKey ? dataKey : void 0;
      }
      var calculateCartesianTooltipPos = (coordinate, layout) =>
          'horizontal' === layout
            ? coordinate.chartX
            : 'vertical' === layout
              ? coordinate.chartY
              : void 0,
        calculatePolarTooltipPos = (rangeObj, layout) =>
          'centric' === layout ? rangeObj.angle : rangeObj.radius;
    },
    './node_modules/recharts/es6/util/Constants.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        F0: () => DATA_ITEM_INDEX_ATTRIBUTE_NAME,
        tQ: () => DEFAULT_Y_AXIS_WIDTH,
        yU: () => DATA_ITEM_GRAPHICAL_ITEM_ID_ATTRIBUTE_NAME,
      });
      var DATA_ITEM_INDEX_ATTRIBUTE_NAME = 'data-recharts-item-index',
        DATA_ITEM_GRAPHICAL_ITEM_ID_ATTRIBUTE_NAME = 'data-recharts-item-id',
        DEFAULT_Y_AXIS_WIDTH = 60;
    },
    './node_modules/recharts/es6/util/DOMUtils.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { Pu: () => getStringSize });
      var Global = __webpack_require__('./node_modules/recharts/es6/util/Global.js');
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                DOMUtils_defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function DOMUtils_defineProperty(e, r, t) {
        return (
          (r = (function DOMUtils_toPropertyKey(t) {
            var i = (function DOMUtils_toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var currentConfig = _objectSpread({}, { cacheSize: 2e3, enableCache: !0 }),
        stringCache = new (class LRUCache_LRUCache {
          constructor(maxSize) {
            (_defineProperty(this, 'cache', new Map()), (this.maxSize = maxSize));
          }
          get(key) {
            var value = this.cache.get(key);
            return (
              void 0 !== value && (this.cache.delete(key), this.cache.set(key, value)),
              value
            );
          }
          set(key, value) {
            if (this.cache.has(key)) this.cache.delete(key);
            else if (this.cache.size >= this.maxSize) {
              var firstKey = this.cache.keys().next().value;
              null != firstKey && this.cache.delete(firstKey);
            }
            this.cache.set(key, value);
          }
          clear() {
            this.cache.clear();
          }
          size() {
            return this.cache.size;
          }
        })(currentConfig.cacheSize),
        SPAN_STYLE = {
          position: 'absolute',
          top: '-20000px',
          left: 0,
          padding: 0,
          margin: 0,
          border: 'none',
          whiteSpace: 'pre',
        };
      var measureTextWithDOM = (text, style) => {
          try {
            var measurementSpan = document.getElementById('recharts_measurement_span');
            (measurementSpan ||
              ((measurementSpan = document.createElement('span')).setAttribute(
                'id',
                'recharts_measurement_span'
              ),
              measurementSpan.setAttribute('aria-hidden', 'true'),
              document.body.appendChild(measurementSpan)),
              Object.assign(measurementSpan.style, SPAN_STYLE, style),
              (measurementSpan.textContent = ''.concat(text)));
            var rect = measurementSpan.getBoundingClientRect();
            return { width: rect.width, height: rect.height };
          } catch (_unused) {
            return { width: 0, height: 0 };
          }
        },
        getStringSize = function getStringSize(text) {
          var style = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (null == text || Global.m.isSsr) return { width: 0, height: 0 };
          if (!currentConfig.enableCache) return measureTextWithDOM(text, style);
          var cacheKey = (function createCacheKey(text, style) {
              var fontSize = style.fontSize || '',
                fontFamily = style.fontFamily || '',
                fontWeight = style.fontWeight || '',
                fontStyle = style.fontStyle || '',
                letterSpacing = style.letterSpacing || '',
                textTransform = style.textTransform || '';
              return ''
                .concat(text, '|')
                .concat(fontSize, '|')
                .concat(fontFamily, '|')
                .concat(fontWeight, '|')
                .concat(fontStyle, '|')
                .concat(letterSpacing, '|')
                .concat(textTransform);
            })(text, style),
            cachedResult = stringCache.get(cacheKey);
          if (cachedResult) return cachedResult;
          var result = measureTextWithDOM(text, style);
          return (stringCache.set(cacheKey, result), result);
        };
    },
    './node_modules/recharts/es6/util/DataUtils.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        CG: () => hasDuplicate,
        Et: () => isNumber,
        F4: () => getPercentValue,
        GW: () => interpolate,
        M8: () => isNan,
        NF: () => uniqueId,
        Zb: () => upperFirst,
        _3: () => isPercent,
        eP: () => findEntryInArray,
        lQ: () => noop,
        n9: () => isNotNil,
        sA: () => mathSign,
        uy: () => isNullish,
        vh: () => isNumOrStr,
      });
      var es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/es-toolkit/compat/get.js'
        ),
        es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(
          es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_0__
        ),
        _round__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/util/round.js'
        ),
        mathSign = (value) => (0 === value ? 0 : value > 0 ? 1 : -1),
        isNan = (value) => 'number' == typeof value && value != +value,
        isPercent = (value) => 'string' == typeof value && value.indexOf('%') === value.length - 1,
        isNumber = (value) =>
          ('number' == typeof value || value instanceof Number) && !isNan(value),
        isNumOrStr = (value) => isNumber(value) || 'string' == typeof value,
        idCounter = 0,
        uniqueId = (prefix) => {
          var id = ++idCounter;
          return ''.concat(prefix || '').concat(id);
        },
        getPercentValue = function getPercentValue(percent, totalValue) {
          var value,
            defaultValue = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
            validate = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          if (!isNumber(percent) && 'string' != typeof percent) return defaultValue;
          if (isPercent(percent)) {
            if (null == totalValue) return defaultValue;
            var index = percent.indexOf('%');
            value = (totalValue * parseFloat(percent.slice(0, index))) / 100;
          } else value = +percent;
          return (
            isNan(value) && (value = defaultValue),
            validate && null != totalValue && value > totalValue && (value = totalValue),
            value
          );
        },
        hasDuplicate = (ary) => {
          if (!Array.isArray(ary)) return !1;
          for (var len = ary.length, cache = {}, i = 0; i < len; i++) {
            if (cache[String(ary[i])]) return !0;
            cache[String(ary[i])] = !0;
          }
          return !1;
        };
      function interpolate(start, end, t) {
        return isNumber(start) && isNumber(end)
          ? (0, _round__WEBPACK_IMPORTED_MODULE_1__.L)(start + t * (end - start))
          : end;
      }
      function findEntryInArray(ary, specifiedKey, specifiedValue) {
        if (ary && ary.length)
          return ary.find(
            (entry) =>
              entry &&
              ('function' == typeof specifiedKey
                ? specifiedKey(entry)
                : es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_0___default()(
                    entry,
                    specifiedKey
                  )) === specifiedValue
          );
      }
      var isNullish = (value) => null == value,
        upperFirst = (value) =>
          isNullish(value)
            ? value
            : ''.concat(value.charAt(0).toUpperCase()).concat(value.slice(1));
      function isNotNil(value) {
        return null != value;
      }
      function noop() {}
    },
    './node_modules/recharts/es6/util/Global.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { m: () => Global });
      var Global = {
        devToolsEnabled: !0,
        isSsr: !(
          'undefined' != typeof window &&
          window.document &&
          Boolean(window.document.createElement) &&
          window.setTimeout
        ),
      };
    },
    './node_modules/recharts/es6/util/PolarUtils.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        IZ: () => polarToCartesian,
        Kg: () => RADIAN,
        lY: () => getMaxRadius,
        yy: () => inRangeOfSector,
      });
      __webpack_require__('./node_modules/next/dist/compiled/react/index.js');
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2
            ? ownKeys(Object(t), !0).forEach(function (r) {
                _defineProperty(e, r, t[r]);
              })
            : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
              : ownKeys(Object(t)).forEach(function (r) {
                  Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                });
        }
        return e;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      var RADIAN = Math.PI / 180,
        radianToDegree = (angleInRadian) => (180 * angleInRadian) / Math.PI,
        polarToCartesian = (cx, cy, radius, angle) => ({
          x: cx + Math.cos(-RADIAN * angle) * radius,
          y: cy + Math.sin(-RADIAN * angle) * radius,
        }),
        getMaxRadius = function getMaxRadius(width, height) {
          var offset =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0, brushBottom: 0 };
          return (
            Math.min(
              Math.abs(width - (offset.left || 0) - (offset.right || 0)),
              Math.abs(height - (offset.top || 0) - (offset.bottom || 0))
            ) / 2
          );
        },
        getAngleOfPoint = (_ref, _ref2) => {
          var { x, y } = _ref,
            { cx, cy } = _ref2,
            radius = ((point, anotherPoint) => {
              var { x: x1, y: y1 } = point,
                { x: x2, y: y2 } = anotherPoint;
              return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
            })({ x, y }, { x: cx, y: cy });
          if (radius <= 0) return { radius, angle: 0 };
          var cos = (x - cx) / radius,
            angleInRadian = Math.acos(cos);
          return (
            y > cy && (angleInRadian = 2 * Math.PI - angleInRadian),
            { radius, angle: radianToDegree(angleInRadian), angleInRadian }
          );
        },
        reverseFormatAngleOfSector = (angle, _ref4) => {
          var { startAngle, endAngle } = _ref4,
            startCnt = Math.floor(startAngle / 360),
            endCnt = Math.floor(endAngle / 360);
          return angle + 360 * Math.min(startCnt, endCnt);
        },
        inRangeOfSector = (_ref5, viewBox) => {
          var { chartX: x, chartY: y } = _ref5,
            { radius, angle } = getAngleOfPoint({ x, y }, viewBox),
            { innerRadius, outerRadius } = viewBox;
          if (radius < innerRadius || radius > outerRadius) return null;
          if (0 === radius) return null;
          var inRange,
            { startAngle, endAngle } = ((_ref3) => {
              var { startAngle, endAngle } = _ref3,
                startCnt = Math.floor(startAngle / 360),
                endCnt = Math.floor(endAngle / 360),
                min = Math.min(startCnt, endCnt);
              return { startAngle: startAngle - 360 * min, endAngle: endAngle - 360 * min };
            })(viewBox),
            formatAngle = angle;
          if (startAngle <= endAngle) {
            for (; formatAngle > endAngle; ) formatAngle -= 360;
            for (; formatAngle < startAngle; ) formatAngle += 360;
            inRange = formatAngle >= startAngle && formatAngle <= endAngle;
          } else {
            for (; formatAngle > startAngle; ) formatAngle -= 360;
            for (; formatAngle < endAngle; ) formatAngle += 360;
            inRange = formatAngle >= endAngle && formatAngle <= startAngle;
          }
          return inRange
            ? _objectSpread(
                _objectSpread({}, viewBox),
                {},
                { radius, angle: reverseFormatAngleOfSector(formatAngle, viewBox) }
              )
            : null;
        };
    },
    './node_modules/recharts/es6/util/ReactUtils.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { aS: () => findAllByType });
      var es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/es-toolkit/compat/get.js'
        ),
        es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(
          es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_0__
        ),
        react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        react_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/react-is/index.js'
        ),
        _DataUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        ),
        getDisplayName = (Comp) =>
          'string' == typeof Comp ? Comp : Comp ? Comp.displayName || Comp.name || 'Component' : '',
        lastChildren = null,
        lastResult = null,
        toArray = (children) => {
          if (children === lastChildren && Array.isArray(lastResult)) return lastResult;
          var result = [];
          return (
            react__WEBPACK_IMPORTED_MODULE_1__.Children.forEach(children, (child) => {
              (0, _DataUtils__WEBPACK_IMPORTED_MODULE_3__.uy)(child) ||
                ((0, react_is__WEBPACK_IMPORTED_MODULE_2__.isFragment)(child)
                  ? (result = result.concat(toArray(child.props.children)))
                  : result.push(child));
            }),
            (lastResult = result),
            (lastChildren = children),
            result
          );
        };
      function findAllByType(children, type) {
        var result = [],
          types = [];
        return (
          (types = Array.isArray(type)
            ? type.map((t) => getDisplayName(t))
            : [getDisplayName(type)]),
          toArray(children).forEach((child) => {
            var childType =
              es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_0___default()(
                child,
                'type.displayName'
              ) || es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_0___default()(child, 'type.name');
            childType && -1 !== types.indexOf(childType) && result.push(child);
          }),
          result
        );
      }
    },
    './node_modules/recharts/es6/util/axisPropsAreEqual.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { Q: () => axisPropsAreEqual });
      var _propsAreEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/recharts/es6/util/propsAreEqual.js'
        ),
        _excluded = ['domain', 'range'],
        _excluded2 = ['domain', 'range'];
      function _objectWithoutProperties(e, t) {
        if (null == e) return {};
        var o,
          r,
          i = (function _objectWithoutPropertiesLoose(r, e) {
            if (null == r) return {};
            var t = {};
            for (var n in r)
              if ({}.hasOwnProperty.call(r, n)) {
                if (-1 !== e.indexOf(n)) continue;
                t[n] = r[n];
              }
            return t;
          })(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++)
            ((o = n[r]),
              -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]));
        }
        return i;
      }
      function shortArraysAreEqual(arr1, arr2) {
        return (
          arr1 === arr2 ||
          (!(
            !Array.isArray(arr1) ||
            2 !== arr1.length ||
            !Array.isArray(arr2) ||
            2 !== arr2.length
          ) &&
            arr1[0] === arr2[0] &&
            arr1[1] === arr2[1])
        );
      }
      function axisPropsAreEqual(prevProps, nextProps) {
        if (prevProps === nextProps) return !0;
        var { domain: prevDomain, range: prevRange } = prevProps,
          prevRest = _objectWithoutProperties(prevProps, _excluded),
          { domain: nextDomain, range: nextRange } = nextProps,
          nextRest = _objectWithoutProperties(nextProps, _excluded2);
        return (
          !!shortArraysAreEqual(prevDomain, nextDomain) &&
          !!shortArraysAreEqual(prevRange, nextRange) &&
          (0, _propsAreEqual__WEBPACK_IMPORTED_MODULE_0__.P)(prevRest, nextRest)
        );
      }
    },
    './node_modules/recharts/es6/util/excludeEventProps.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { q: () => isEventKey });
      var EventKeys = [
        'dangerouslySetInnerHTML',
        'onCopy',
        'onCopyCapture',
        'onCut',
        'onCutCapture',
        'onPaste',
        'onPasteCapture',
        'onCompositionEnd',
        'onCompositionEndCapture',
        'onCompositionStart',
        'onCompositionStartCapture',
        'onCompositionUpdate',
        'onCompositionUpdateCapture',
        'onFocus',
        'onFocusCapture',
        'onBlur',
        'onBlurCapture',
        'onChange',
        'onChangeCapture',
        'onBeforeInput',
        'onBeforeInputCapture',
        'onInput',
        'onInputCapture',
        'onReset',
        'onResetCapture',
        'onSubmit',
        'onSubmitCapture',
        'onInvalid',
        'onInvalidCapture',
        'onLoad',
        'onLoadCapture',
        'onError',
        'onErrorCapture',
        'onKeyDown',
        'onKeyDownCapture',
        'onKeyPress',
        'onKeyPressCapture',
        'onKeyUp',
        'onKeyUpCapture',
        'onAbort',
        'onAbortCapture',
        'onCanPlay',
        'onCanPlayCapture',
        'onCanPlayThrough',
        'onCanPlayThroughCapture',
        'onDurationChange',
        'onDurationChangeCapture',
        'onEmptied',
        'onEmptiedCapture',
        'onEncrypted',
        'onEncryptedCapture',
        'onEnded',
        'onEndedCapture',
        'onLoadedData',
        'onLoadedDataCapture',
        'onLoadedMetadata',
        'onLoadedMetadataCapture',
        'onLoadStart',
        'onLoadStartCapture',
        'onPause',
        'onPauseCapture',
        'onPlay',
        'onPlayCapture',
        'onPlaying',
        'onPlayingCapture',
        'onProgress',
        'onProgressCapture',
        'onRateChange',
        'onRateChangeCapture',
        'onSeeked',
        'onSeekedCapture',
        'onSeeking',
        'onSeekingCapture',
        'onStalled',
        'onStalledCapture',
        'onSuspend',
        'onSuspendCapture',
        'onTimeUpdate',
        'onTimeUpdateCapture',
        'onVolumeChange',
        'onVolumeChangeCapture',
        'onWaiting',
        'onWaitingCapture',
        'onAuxClick',
        'onAuxClickCapture',
        'onClick',
        'onClickCapture',
        'onContextMenu',
        'onContextMenuCapture',
        'onDoubleClick',
        'onDoubleClickCapture',
        'onDrag',
        'onDragCapture',
        'onDragEnd',
        'onDragEndCapture',
        'onDragEnter',
        'onDragEnterCapture',
        'onDragExit',
        'onDragExitCapture',
        'onDragLeave',
        'onDragLeaveCapture',
        'onDragOver',
        'onDragOverCapture',
        'onDragStart',
        'onDragStartCapture',
        'onDrop',
        'onDropCapture',
        'onMouseDown',
        'onMouseDownCapture',
        'onMouseEnter',
        'onMouseLeave',
        'onMouseMove',
        'onMouseMoveCapture',
        'onMouseOut',
        'onMouseOutCapture',
        'onMouseOver',
        'onMouseOverCapture',
        'onMouseUp',
        'onMouseUpCapture',
        'onSelect',
        'onSelectCapture',
        'onTouchCancel',
        'onTouchCancelCapture',
        'onTouchEnd',
        'onTouchEndCapture',
        'onTouchMove',
        'onTouchMoveCapture',
        'onTouchStart',
        'onTouchStartCapture',
        'onPointerDown',
        'onPointerDownCapture',
        'onPointerMove',
        'onPointerMoveCapture',
        'onPointerUp',
        'onPointerUpCapture',
        'onPointerCancel',
        'onPointerCancelCapture',
        'onPointerEnter',
        'onPointerEnterCapture',
        'onPointerLeave',
        'onPointerLeaveCapture',
        'onPointerOver',
        'onPointerOverCapture',
        'onPointerOut',
        'onPointerOutCapture',
        'onGotPointerCapture',
        'onGotPointerCaptureCapture',
        'onLostPointerCapture',
        'onLostPointerCaptureCapture',
        'onScroll',
        'onScrollCapture',
        'onWheel',
        'onWheelCapture',
        'onAnimationStart',
        'onAnimationStartCapture',
        'onAnimationEnd',
        'onAnimationEndCapture',
        'onAnimationIteration',
        'onAnimationIterationCapture',
        'onTransitionEnd',
        'onTransitionEndCapture',
      ];
      function isEventKey(key) {
        return 'string' == typeof key && EventKeys.includes(key);
      }
    },
    './node_modules/recharts/es6/util/getChartPointer.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { w: () => getChartPointer });
      var getChartPointer = (event) => {
        var rect = event.currentTarget.getBoundingClientRect(),
          scaleX = rect.width / event.currentTarget.offsetWidth,
          scaleY = rect.height / event.currentTarget.offsetHeight;
        return {
          chartX: Math.round((event.clientX - rect.left) / scaleX),
          chartY: Math.round((event.clientY - rect.top) / scaleY),
        };
      };
    },
    './node_modules/recharts/es6/util/getSliced.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      function getSliced(arr, startIndex, endIndex) {
        return Array.isArray(arr) && arr && startIndex + endIndex !== 0
          ? arr.slice(startIndex, endIndex + 1)
          : arr;
      }
      __webpack_require__.d(__webpack_exports__, { v: () => getSliced });
    },
    './node_modules/recharts/es6/util/isDomainSpecifiedByUser.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        JH: () => isWellFormedNumberDomain,
        f5: () => numericalDomainSpecifiedWithoutRequiringData,
        v1: () => parseNumericalUserDomain,
      });
      var _ChartUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/recharts/es6/util/ChartUtils.js'
        ),
        _DataUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        ),
        _isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/util/isWellBehavedNumber.js'
        );
      function isWellFormedNumberDomain(v) {
        if (Array.isArray(v) && 2 === v.length) {
          var [min, max] = v;
          if (
            (0, _isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_2__.H)(min) &&
            (0, _isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_2__.H)(max)
          )
            return !0;
        }
        return !1;
      }
      function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {
        return allowDataOverflow
          ? providedDomain
          : [
              Math.min(providedDomain[0], boundaryDomain[0]),
              Math.max(providedDomain[1], boundaryDomain[1]),
            ];
      }
      function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {
        if (
          allowDataOverflow &&
          'function' != typeof userDomain &&
          Array.isArray(userDomain) &&
          2 === userDomain.length
        ) {
          var finalMin,
            finalMax,
            [providedMin, providedMax] = userDomain;
          if ((0, _isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_2__.H)(providedMin))
            finalMin = providedMin;
          else if ('function' == typeof providedMin) return;
          if ((0, _isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_2__.H)(providedMax))
            finalMax = providedMax;
          else if ('function' == typeof providedMax) return;
          var candidate = [finalMin, finalMax];
          if (isWellFormedNumberDomain(candidate)) return candidate;
        }
      }
      function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {
        if (allowDataOverflow || null != dataDomain) {
          if ('function' == typeof userDomain && null != dataDomain)
            try {
              var result = userDomain(dataDomain, allowDataOverflow);
              if (isWellFormedNumberDomain(result))
                return extendDomain(result, dataDomain, allowDataOverflow);
            } catch (_unused) {}
          if (Array.isArray(userDomain) && 2 === userDomain.length) {
            var finalMin,
              finalMax,
              [providedMin, providedMax] = userDomain;
            if ('auto' === providedMin) null != dataDomain && (finalMin = Math.min(...dataDomain));
            else if ((0, _DataUtils__WEBPACK_IMPORTED_MODULE_1__.Et)(providedMin))
              finalMin = providedMin;
            else if ('function' == typeof providedMin)
              try {
                null != dataDomain &&
                  (finalMin = providedMin(null == dataDomain ? void 0 : dataDomain[0]));
              } catch (_unused2) {}
            else if (
              'string' == typeof providedMin &&
              _ChartUtils__WEBPACK_IMPORTED_MODULE_0__.IH.test(providedMin)
            ) {
              var match = _ChartUtils__WEBPACK_IMPORTED_MODULE_0__.IH.exec(providedMin);
              if (null == match || null == match[1] || null == dataDomain) finalMin = void 0;
              else {
                var value = +match[1];
                finalMin = dataDomain[0] - value;
              }
            } else finalMin = null == dataDomain ? void 0 : dataDomain[0];
            if ('auto' === providedMax) null != dataDomain && (finalMax = Math.max(...dataDomain));
            else if ((0, _DataUtils__WEBPACK_IMPORTED_MODULE_1__.Et)(providedMax))
              finalMax = providedMax;
            else if ('function' == typeof providedMax)
              try {
                null != dataDomain &&
                  (finalMax = providedMax(null == dataDomain ? void 0 : dataDomain[1]));
              } catch (_unused3) {}
            else if (
              'string' == typeof providedMax &&
              _ChartUtils__WEBPACK_IMPORTED_MODULE_0__.qx.test(providedMax)
            ) {
              var _match = _ChartUtils__WEBPACK_IMPORTED_MODULE_0__.qx.exec(providedMax);
              if (null == _match || null == _match[1] || null == dataDomain) finalMax = void 0;
              else {
                var _value = +_match[1];
                finalMax = dataDomain[1] + _value;
              }
            } else finalMax = null == dataDomain ? void 0 : dataDomain[1];
            var candidate = [finalMin, finalMax];
            if (isWellFormedNumberDomain(candidate))
              return null == dataDomain
                ? candidate
                : extendDomain(candidate, dataDomain, allowDataOverflow);
          }
        }
      }
    },
    './node_modules/recharts/es6/util/isWellBehavedNumber.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      function isWellBehavedNumber(n) {
        return Number.isFinite(n);
      }
      function isPositiveNumber(n) {
        return 'number' == typeof n && n > 0 && Number.isFinite(n);
      }
      __webpack_require__.d(__webpack_exports__, {
        F: () => isPositiveNumber,
        H: () => isWellBehavedNumber,
      });
    },
    './node_modules/recharts/es6/util/propsAreEqual.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { P: () => propsAreEqual });
      var react_redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/react-redux/dist/react-redux.mjs'
        ),
        propsToShallowCompare = new Set([
          'axisLine',
          'tickLine',
          'activeBar',
          'activeDot',
          'activeLabel',
          'activeShape',
          'allowEscapeViewBox',
          'background',
          'cursor',
          'dot',
          'label',
          'line',
          'margin',
          'padding',
          'position',
          'shape',
          'style',
          'tick',
          'wrapperStyle',
          'radius',
        ]);
      function sameValueZero(x, y) {
        return (
          (null == x && null == y) ||
          ('number' == typeof x && 'number' == typeof y ? x === y || (x != x && y != y) : x === y)
        );
      }
      function propsAreEqual(prevProps, nextProps) {
        var allKeys = new Set([...Object.keys(prevProps), ...Object.keys(nextProps)]);
        for (var key of allKeys)
          if (propsToShallowCompare.has(key)) {
            if (null == prevProps[key] && null == nextProps[key]) continue;
            if (!(0, react_redux__WEBPACK_IMPORTED_MODULE_0__.bN)(prevProps[key], nextProps[key]))
              return !1;
          } else if (!sameValueZero(prevProps[key], nextProps[key])) return !1;
        return !0;
      }
    },
    './node_modules/recharts/es6/util/resolveDefaultProps.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          (r &&
            (o = o.filter(function (r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })),
            t.push.apply(t, o));
        }
        return t;
      }
      function _defineProperty(e, r, t) {
        return (
          (r = (function _toPropertyKey(t) {
            var i = (function _toPrimitive(t, r) {
              if ('object' != typeof t || !t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var i = e.call(t, r || 'default');
                if ('object' != typeof i) return i;
                throw new TypeError('@@toPrimitive must return a primitive value.');
              }
              return ('string' === r ? String : Number)(t);
            })(t, 'string');
            return 'symbol' == typeof i ? i : i + '';
          })(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function resolveDefaultProps(realProps, defaultProps) {
        var resolvedProps = (function _objectSpread(e) {
            for (var r = 1; r < arguments.length; r++) {
              var t = null != arguments[r] ? arguments[r] : {};
              r % 2
                ? ownKeys(Object(t), !0).forEach(function (r) {
                    _defineProperty(e, r, t[r]);
                  })
                : Object.getOwnPropertyDescriptors
                  ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
                  : ownKeys(Object(t)).forEach(function (r) {
                      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                    });
            }
            return e;
          })({}, realProps),
          dp = defaultProps;
        return Object.keys(defaultProps).reduce(
          (acc, key) => (void 0 === acc[key] && void 0 !== dp[key] && (acc[key] = dp[key]), acc),
          resolvedProps
        );
      }
      __webpack_require__.d(__webpack_exports__, { e: () => resolveDefaultProps });
    },
    './node_modules/recharts/es6/util/round.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { L: () => round, Y: () => roundTemplateLiteral });
      function round(num) {
        var factor = 10 ** (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4),
          rounded = Math.round(num * factor) / factor;
        return Object.is(rounded, -0) ? 0 : rounded;
      }
      function roundTemplateLiteral(strings) {
        for (
          var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
          _key < _len;
          _key++
        )
          values[_key - 1] = arguments[_key];
        return strings.reduce((result, string, i) => {
          var value = values[i - 1];
          return 'string' == typeof value
            ? result + value + string
            : void 0 !== value
              ? result + round(value) + string
              : result + string;
        }, '');
      }
    },
    './node_modules/recharts/es6/util/stacks/getStackSeriesIdentifier.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      function getStackSeriesIdentifier(graphicalItem) {
        return null == graphicalItem ? void 0 : graphicalItem.id;
      }
      __webpack_require__.d(__webpack_exports__, { x: () => getStackSeriesIdentifier });
    },
    './node_modules/recharts/es6/util/svgPropertiesAndEvents.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { a: () => svgPropertiesAndEvents });
      __webpack_require__('./node_modules/next/dist/compiled/react/index.js');
      var _excludeEventProps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/util/excludeEventProps.js'
        ),
        _svgPropertiesNoEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/util/svgPropertiesNoEvents.js'
        );
      function svgPropertiesAndEvents(obj) {
        var result = {};
        for (var key in obj)
          Object.prototype.hasOwnProperty.call(obj, key) &&
            ((0, _svgPropertiesNoEvents__WEBPACK_IMPORTED_MODULE_2__.Rw)(key) ||
              (0, _svgPropertiesNoEvents__WEBPACK_IMPORTED_MODULE_2__.Xc)(key) ||
              (0, _excludeEventProps__WEBPACK_IMPORTED_MODULE_1__.q)(key)) &&
            (result[key] = obj[key]);
        return result;
      }
    },
    './node_modules/recharts/es6/util/svgPropertiesNoEvents.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        Rw: () => isSvgElementPropKey,
        Xc: () => isDataAttribute,
        ic: () => svgPropertiesNoEventsFromUnknown,
        uZ: () => svgPropertiesNoEvents,
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        SVGElementPropKeySet = new Set([
          'aria-activedescendant',
          'aria-atomic',
          'aria-autocomplete',
          'aria-busy',
          'aria-checked',
          'aria-colcount',
          'aria-colindex',
          'aria-colspan',
          'aria-controls',
          'aria-current',
          'aria-describedby',
          'aria-details',
          'aria-disabled',
          'aria-errormessage',
          'aria-expanded',
          'aria-flowto',
          'aria-haspopup',
          'aria-hidden',
          'aria-invalid',
          'aria-keyshortcuts',
          'aria-label',
          'aria-labelledby',
          'aria-level',
          'aria-live',
          'aria-modal',
          'aria-multiline',
          'aria-multiselectable',
          'aria-orientation',
          'aria-owns',
          'aria-placeholder',
          'aria-posinset',
          'aria-pressed',
          'aria-readonly',
          'aria-relevant',
          'aria-required',
          'aria-roledescription',
          'aria-rowcount',
          'aria-rowindex',
          'aria-rowspan',
          'aria-selected',
          'aria-setsize',
          'aria-sort',
          'aria-valuemax',
          'aria-valuemin',
          'aria-valuenow',
          'aria-valuetext',
          'className',
          'color',
          'height',
          'id',
          'lang',
          'max',
          'media',
          'method',
          'min',
          'name',
          'style',
          'target',
          'width',
          'role',
          'tabIndex',
          'accentHeight',
          'accumulate',
          'additive',
          'alignmentBaseline',
          'allowReorder',
          'alphabetic',
          'amplitude',
          'arabicForm',
          'ascent',
          'attributeName',
          'attributeType',
          'autoReverse',
          'azimuth',
          'baseFrequency',
          'baselineShift',
          'baseProfile',
          'bbox',
          'begin',
          'bias',
          'by',
          'calcMode',
          'capHeight',
          'clip',
          'clipPath',
          'clipPathUnits',
          'clipRule',
          'colorInterpolation',
          'colorInterpolationFilters',
          'colorProfile',
          'colorRendering',
          'contentScriptType',
          'contentStyleType',
          'cursor',
          'cx',
          'cy',
          'd',
          'decelerate',
          'descent',
          'diffuseConstant',
          'direction',
          'display',
          'divisor',
          'dominantBaseline',
          'dur',
          'dx',
          'dy',
          'edgeMode',
          'elevation',
          'enableBackground',
          'end',
          'exponent',
          'externalResourcesRequired',
          'fill',
          'fillOpacity',
          'fillRule',
          'filter',
          'filterRes',
          'filterUnits',
          'floodColor',
          'floodOpacity',
          'focusable',
          'fontFamily',
          'fontSize',
          'fontSizeAdjust',
          'fontStretch',
          'fontStyle',
          'fontVariant',
          'fontWeight',
          'format',
          'from',
          'fx',
          'fy',
          'g1',
          'g2',
          'glyphName',
          'glyphOrientationHorizontal',
          'glyphOrientationVertical',
          'glyphRef',
          'gradientTransform',
          'gradientUnits',
          'hanging',
          'horizAdvX',
          'horizOriginX',
          'href',
          'ideographic',
          'imageRendering',
          'in2',
          'in',
          'intercept',
          'k1',
          'k2',
          'k3',
          'k4',
          'k',
          'kernelMatrix',
          'kernelUnitLength',
          'kerning',
          'keyPoints',
          'keySplines',
          'keyTimes',
          'lengthAdjust',
          'letterSpacing',
          'lightingColor',
          'limitingConeAngle',
          'local',
          'markerEnd',
          'markerHeight',
          'markerMid',
          'markerStart',
          'markerUnits',
          'markerWidth',
          'mask',
          'maskContentUnits',
          'maskUnits',
          'mathematical',
          'mode',
          'numOctaves',
          'offset',
          'opacity',
          'operator',
          'order',
          'orient',
          'orientation',
          'origin',
          'overflow',
          'overlinePosition',
          'overlineThickness',
          'paintOrder',
          'panose1',
          'pathLength',
          'patternContentUnits',
          'patternTransform',
          'patternUnits',
          'pointerEvents',
          'pointsAtX',
          'pointsAtY',
          'pointsAtZ',
          'preserveAlpha',
          'preserveAspectRatio',
          'primitiveUnits',
          'r',
          'radius',
          'refX',
          'refY',
          'renderingIntent',
          'repeatCount',
          'repeatDur',
          'requiredExtensions',
          'requiredFeatures',
          'restart',
          'result',
          'rotate',
          'rx',
          'ry',
          'seed',
          'shapeRendering',
          'slope',
          'spacing',
          'specularConstant',
          'specularExponent',
          'speed',
          'spreadMethod',
          'startOffset',
          'stdDeviation',
          'stemh',
          'stemv',
          'stitchTiles',
          'stopColor',
          'stopOpacity',
          'strikethroughPosition',
          'strikethroughThickness',
          'string',
          'stroke',
          'strokeDasharray',
          'strokeDashoffset',
          'strokeLinecap',
          'strokeLinejoin',
          'strokeMiterlimit',
          'strokeOpacity',
          'strokeWidth',
          'surfaceScale',
          'systemLanguage',
          'tableValues',
          'targetX',
          'targetY',
          'textAnchor',
          'textDecoration',
          'textLength',
          'textRendering',
          'to',
          'transform',
          'u1',
          'u2',
          'underlinePosition',
          'underlineThickness',
          'unicode',
          'unicodeBidi',
          'unicodeRange',
          'unitsPerEm',
          'vAlphabetic',
          'values',
          'vectorEffect',
          'version',
          'vertAdvY',
          'vertOriginX',
          'vertOriginY',
          'vHanging',
          'vIdeographic',
          'viewTarget',
          'visibility',
          'vMathematical',
          'widths',
          'wordSpacing',
          'writingMode',
          'x1',
          'x2',
          'x',
          'xChannelSelector',
          'xHeight',
          'xlinkActuate',
          'xlinkArcrole',
          'xlinkHref',
          'xlinkRole',
          'xlinkShow',
          'xlinkTitle',
          'xlinkType',
          'xmlBase',
          'xmlLang',
          'xmlns',
          'xmlnsXlink',
          'xmlSpace',
          'y1',
          'y2',
          'y',
          'yChannelSelector',
          'z',
          'zoomAndPan',
          'ref',
          'key',
          'angle',
        ]);
      function isSvgElementPropKey(key) {
        return 'string' == typeof key && SVGElementPropKeySet.has(key);
      }
      function isDataAttribute(key) {
        return 'string' == typeof key && key.startsWith('data-');
      }
      function svgPropertiesNoEvents(obj) {
        if ('object' != typeof obj || null === obj) return {};
        var result = {};
        for (var key in obj)
          Object.prototype.hasOwnProperty.call(obj, key) &&
            (isSvgElementPropKey(key) || isDataAttribute(key)) &&
            (result[key] = obj[key]);
        return result;
      }
      function svgPropertiesNoEventsFromUnknown(input) {
        return null == input
          ? null
          : (0, react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(input) &&
              'object' == typeof input.props &&
              null !== input.props
            ? svgPropertiesNoEvents(input.props)
            : 'object' != typeof input || Array.isArray(input)
              ? null
              : svgPropertiesNoEvents(input);
      }
    },
    './node_modules/recharts/es6/util/types.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        TT: () => isPolarCoordinate,
        XC: () => adaptEventsOfChild,
        _U: () => adaptEventHandlers,
      });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        _excludeEventProps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/util/excludeEventProps.js'
        ),
        isPolarCoordinate = (c) => 'radius' in c && 'startAngle' in c && 'endAngle' in c,
        adaptEventHandlers = (props, newHandler) => {
          if (!props || 'function' == typeof props || 'boolean' == typeof props) return null;
          var inputProps = props;
          if (
            ((0, react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(props) &&
              (inputProps = props.props),
            'object' != typeof inputProps && 'function' != typeof inputProps)
          )
            return null;
          var out = {};
          return (
            Object.keys(inputProps).forEach((key) => {
              (0, _excludeEventProps__WEBPACK_IMPORTED_MODULE_1__.q)(key) &&
                (out[key] = newHandler || ((e) => inputProps[key](inputProps, e)));
            }),
            out
          );
        },
        adaptEventsOfChild = (props, data, index) => {
          if (null === props || ('object' != typeof props && 'function' != typeof props))
            return null;
          var out = null;
          return (
            Object.keys(props).forEach((key) => {
              var item = props[key];
              (0, _excludeEventProps__WEBPACK_IMPORTED_MODULE_1__.q)(key) &&
                'function' == typeof item &&
                (out || (out = {}),
                (out[key] = ((originalHandler, data, index) => (e) => (
                  originalHandler(data, index, e),
                  null
                ))(item, data, index)));
            }),
            out
          );
        };
    },
    './node_modules/recharts/es6/util/useAnimationId.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { n: () => useAnimationId });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        _DataUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        );
      function useAnimationId(input) {
        var prefix = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'animation-',
          animationId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(
            (0, _DataUtils__WEBPACK_IMPORTED_MODULE_1__.NF)(prefix)
          ),
          prevProps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(input);
        return (
          prevProps.current !== input &&
            ((animationId.current = (0, _DataUtils__WEBPACK_IMPORTED_MODULE_1__.NF)(prefix)),
            (prevProps.current = input)),
          animationId.current
        );
      }
    },
    './node_modules/recharts/es6/zIndex/DefaultZIndexes.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { I: () => DefaultZIndexes });
      var DefaultZIndexes = {
        grid: -100,
        barBackground: -50,
        area: 100,
        cursorRectangle: 200,
        bar: 300,
        line: 400,
        axis: 500,
        scatter: 600,
        activeBar: 1e3,
        cursorLine: 1100,
        activeDot: 1200,
        label: 2e3,
      };
    },
    './node_modules/recharts/es6/zIndex/ZIndexLayer.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { g: () => ZIndexLayer });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/next/dist/compiled/react/index.js'
        ),
        react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/next/dist/compiled/react-dom/index.js'
        ),
        _util_DataUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/util/DataUtils.js'
        ),
        _state_hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          './node_modules/recharts/es6/state/hooks.js'
        ),
        _zIndexSelectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          './node_modules/recharts/es6/zIndex/zIndexSelectors.js'
        ),
        _state_zIndexSlice__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          './node_modules/recharts/es6/state/zIndexSlice.js'
        ),
        _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          './node_modules/recharts/es6/context/chartLayoutContext.js'
        ),
        _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          './node_modules/recharts/es6/context/PanoramaContext.js'
        );
      function ZIndexLayer(_ref) {
        var { zIndex, children } = _ref,
          shouldRenderInPortal =
            (0, _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_6__.SG)() &&
            void 0 !== zIndex &&
            0 !== zIndex,
          isPanorama = (0, _context_PanoramaContext__WEBPACK_IMPORTED_MODULE_7__.r)(),
          dispatch = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_3__.j)();
        (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(
          () =>
            shouldRenderInPortal
              ? (dispatch((0, _state_zIndexSlice__WEBPACK_IMPORTED_MODULE_5__.wR)({ zIndex })),
                () => {
                  dispatch((0, _state_zIndexSlice__WEBPACK_IMPORTED_MODULE_5__.ZV)({ zIndex }));
                })
              : _util_DataUtils__WEBPACK_IMPORTED_MODULE_2__.lQ,
          [dispatch, zIndex, shouldRenderInPortal]
        );
        var portalElement = (0, _state_hooks__WEBPACK_IMPORTED_MODULE_3__.G)((state) =>
          (0, _zIndexSelectors__WEBPACK_IMPORTED_MODULE_4__.h)(state, zIndex, isPanorama)
        );
        return shouldRenderInPortal
          ? portalElement
            ? (0, react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, portalElement)
            : null
          : children;
      }
    },
    './node_modules/recharts/es6/zIndex/zIndexSelectors.js'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        I: () => selectAllRegisteredZIndexes,
        h: () => selectZIndexPortalElement,
      });
      var reselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          './node_modules/reselect/dist/reselect.mjs'
        ),
        _state_selectors_arrayEqualityCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          './node_modules/recharts/es6/state/selectors/arrayEqualityCheck.js'
        ),
        _DefaultZIndexes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          './node_modules/recharts/es6/zIndex/DefaultZIndexes.js'
        ),
        selectZIndexPortalElement = (0, reselect__WEBPACK_IMPORTED_MODULE_0__.Mz)(
          (state) => state.zIndex.zIndexMap,
          (_, zIndex) => zIndex,
          (_, _zIndex, isPanorama) => isPanorama,
          (zIndexMap, zIndex, isPanorama) => {
            if (null != zIndex) {
              var entry = zIndexMap[zIndex];
              if (null != entry) return isPanorama ? entry.panoramaElement : entry.element;
            }
          }
        ),
        selectAllRegisteredZIndexes = (0, reselect__WEBPACK_IMPORTED_MODULE_0__.Mz)(
          (state) => state.zIndex.zIndexMap,
          (zIndexMap) => {
            var allNumbers = Object.keys(zIndexMap)
              .map((zIndexStr) => parseInt(zIndexStr, 10))
              .concat(Object.values(_DefaultZIndexes__WEBPACK_IMPORTED_MODULE_2__.I));
            return Array.from(new Set(allNumbers)).sort((a, b) => a - b);
          },
          {
            memoizeOptions: {
              resultEqualityCheck:
                _state_selectors_arrayEqualityCheck__WEBPACK_IMPORTED_MODULE_1__.W,
            },
          }
        );
    },
    './node_modules/redux/dist/redux.mjs'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, {
        HY: () => combineReducers,
        Qd: () => isPlainObject,
        Tw: () => applyMiddleware,
        Zz: () => compose,
        ve: () => isAction,
        y$: () => createStore,
      });
      __webpack_require__('./node_modules/console-browserify/index.js');
      function formatProdErrorMessage(code) {
        return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
      }
      var symbol_observable_default = (() =>
          ('function' == typeof Symbol && Symbol.observable) || '@@observable')(),
        randomString = () => Math.random().toString(36).substring(7).split('').join('.'),
        actionTypes_default = {
          INIT: `@@redux/INIT${randomString()}`,
          REPLACE: `@@redux/REPLACE${randomString()}`,
          PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`,
        };
      function isPlainObject(obj) {
        if ('object' != typeof obj || null === obj) return !1;
        let proto = obj;
        for (; null !== Object.getPrototypeOf(proto); ) proto = Object.getPrototypeOf(proto);
        return Object.getPrototypeOf(obj) === proto || null === Object.getPrototypeOf(obj);
      }
      function createStore(reducer, preloadedState, enhancer) {
        if ('function' != typeof reducer) throw new Error(formatProdErrorMessage(2));
        if (
          ('function' == typeof preloadedState && 'function' == typeof enhancer) ||
          ('function' == typeof enhancer && 'function' == typeof arguments[3])
        )
          throw new Error(formatProdErrorMessage(0));
        if (
          ('function' == typeof preloadedState &&
            void 0 === enhancer &&
            ((enhancer = preloadedState), (preloadedState = void 0)),
          void 0 !== enhancer)
        ) {
          if ('function' != typeof enhancer) throw new Error(formatProdErrorMessage(1));
          return enhancer(createStore)(reducer, preloadedState);
        }
        let currentReducer = reducer,
          currentState = preloadedState,
          currentListeners = new Map(),
          nextListeners = currentListeners,
          listenerIdCounter = 0,
          isDispatching = !1;
        function ensureCanMutateNextListeners() {
          nextListeners === currentListeners &&
            ((nextListeners = new Map()),
            currentListeners.forEach((listener, key) => {
              nextListeners.set(key, listener);
            }));
        }
        function getState() {
          if (isDispatching) throw new Error(formatProdErrorMessage(3));
          return currentState;
        }
        function subscribe(listener) {
          if ('function' != typeof listener) throw new Error(formatProdErrorMessage(4));
          if (isDispatching) throw new Error(formatProdErrorMessage(5));
          let isSubscribed = !0;
          ensureCanMutateNextListeners();
          const listenerId = listenerIdCounter++;
          return (
            nextListeners.set(listenerId, listener),
            function unsubscribe() {
              if (isSubscribed) {
                if (isDispatching) throw new Error(formatProdErrorMessage(6));
                ((isSubscribed = !1),
                  ensureCanMutateNextListeners(),
                  nextListeners.delete(listenerId),
                  (currentListeners = null));
              }
            }
          );
        }
        function dispatch(action) {
          if (!isPlainObject(action)) throw new Error(formatProdErrorMessage(7));
          if (void 0 === action.type) throw new Error(formatProdErrorMessage(8));
          if ('string' != typeof action.type) throw new Error(formatProdErrorMessage(17));
          if (isDispatching) throw new Error(formatProdErrorMessage(9));
          try {
            ((isDispatching = !0), (currentState = currentReducer(currentState, action)));
          } finally {
            isDispatching = !1;
          }
          return (
            (currentListeners = nextListeners).forEach((listener) => {
              listener();
            }),
            action
          );
        }
        dispatch({ type: actionTypes_default.INIT });
        return {
          dispatch,
          subscribe,
          getState,
          replaceReducer: function replaceReducer(nextReducer) {
            if ('function' != typeof nextReducer) throw new Error(formatProdErrorMessage(10));
            ((currentReducer = nextReducer), dispatch({ type: actionTypes_default.REPLACE }));
          },
          [symbol_observable_default]: function observable() {
            const outerSubscribe = subscribe;
            return {
              subscribe(observer) {
                if ('object' != typeof observer || null === observer)
                  throw new Error(formatProdErrorMessage(11));
                function observeState() {
                  const observerAsObserver = observer;
                  observerAsObserver.next && observerAsObserver.next(getState());
                }
                observeState();
                return { unsubscribe: outerSubscribe(observeState) };
              },
              [symbol_observable_default]() {
                return this;
              },
            };
          },
        };
      }
      function combineReducers(reducers) {
        const reducerKeys = Object.keys(reducers),
          finalReducers = {};
        for (let i = 0; i < reducerKeys.length; i++) {
          const key = reducerKeys[i];
          (0, 'function' == typeof reducers[key] && (finalReducers[key] = reducers[key]));
        }
        const finalReducerKeys = Object.keys(finalReducers);
        let shapeAssertionError;
        try {
          !(function assertReducerShape(reducers) {
            Object.keys(reducers).forEach((key) => {
              const reducer = reducers[key];
              if (void 0 === reducer(void 0, { type: actionTypes_default.INIT }))
                throw new Error(formatProdErrorMessage(12));
              if (void 0 === reducer(void 0, { type: actionTypes_default.PROBE_UNKNOWN_ACTION() }))
                throw new Error(formatProdErrorMessage(13));
            });
          })(finalReducers);
        } catch (e) {
          shapeAssertionError = e;
        }
        return function combination(state = {}, action) {
          if (shapeAssertionError) throw shapeAssertionError;
          let hasChanged = !1;
          const nextState = {};
          for (let i = 0; i < finalReducerKeys.length; i++) {
            const key = finalReducerKeys[i],
              reducer = finalReducers[key],
              previousStateForKey = state[key],
              nextStateForKey = reducer(previousStateForKey, action);
            if (void 0 === nextStateForKey) {
              action && action.type;
              throw new Error(formatProdErrorMessage(14));
            }
            ((nextState[key] = nextStateForKey),
              (hasChanged = hasChanged || nextStateForKey !== previousStateForKey));
          }
          return (
            (hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length),
            hasChanged ? nextState : state
          );
        };
      }
      function compose(...funcs) {
        return 0 === funcs.length
          ? (arg) => arg
          : 1 === funcs.length
            ? funcs[0]
            : funcs.reduce(
                (a, b) =>
                  (...args) =>
                    a(b(...args))
              );
      }
      function applyMiddleware(...middlewares) {
        return (createStore2) => (reducer, preloadedState) => {
          const store = createStore2(reducer, preloadedState);
          let dispatch = () => {
            throw new Error(formatProdErrorMessage(15));
          };
          const middlewareAPI = {
              getState: store.getState,
              dispatch: (action, ...args) => dispatch(action, ...args),
            },
            chain = middlewares.map((middleware) => middleware(middlewareAPI));
          return ((dispatch = compose(...chain)(store.dispatch)), { ...store, dispatch });
        };
      }
      function isAction(action) {
        return isPlainObject(action) && 'type' in action && 'string' == typeof action.type;
      }
    },
    './node_modules/reselect/dist/reselect.mjs'(
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, { Mz: () => createSelector });
      __webpack_require__('./node_modules/console-browserify/index.js');
      function assertIsFunction(
        func,
        errorMessage = 'expected a function, instead received ' + typeof func
      ) {
        if ('function' != typeof func) throw new TypeError(errorMessage);
      }
      var ensureIsArray = (item) => (Array.isArray(item) ? item : [item]);
      function getDependencies(createSelectorArgs) {
        const dependencies = Array.isArray(createSelectorArgs[0])
          ? createSelectorArgs[0]
          : createSelectorArgs;
        return (
          (function assertIsArrayOfFunctions(
            array,
            errorMessage = 'expected all items to be functions, instead received the following types: '
          ) {
            if (!array.every((item) => 'function' == typeof item)) {
              const itemTypes = array
                .map((item) =>
                  'function' == typeof item ? `function ${item.name || 'unnamed'}()` : typeof item
                )
                .join(', ');
              throw new TypeError(`${errorMessage}[${itemTypes}]`);
            }
          })(
            dependencies,
            'createSelector expects all input-selectors to be functions, but received the following types: '
          ),
          dependencies
        );
      }
      (Symbol(), Object.getPrototypeOf({}));
      var Ref =
        'undefined' != typeof WeakRef
          ? WeakRef
          : class {
              constructor(value) {
                this.value = value;
              }
              deref() {
                return this.value;
              }
            };
      function createCacheNode() {
        return { s: 0, v: void 0, o: null, p: null };
      }
      function weakMapMemoize(func, options = {}) {
        let fnNode = { s: 0, v: void 0, o: null, p: null };
        const { resultEqualityCheck } = options;
        let lastResult,
          resultsCount = 0;
        function memoized() {
          let cacheNode = fnNode;
          const { length } = arguments;
          for (let i = 0, l = length; i < l; i++) {
            const arg = arguments[i];
            if ('function' == typeof arg || ('object' == typeof arg && null !== arg)) {
              let objectCache = cacheNode.o;
              null === objectCache && (cacheNode.o = objectCache = new WeakMap());
              const objectNode = objectCache.get(arg);
              void 0 === objectNode
                ? ((cacheNode = createCacheNode()), objectCache.set(arg, cacheNode))
                : (cacheNode = objectNode);
            } else {
              let primitiveCache = cacheNode.p;
              null === primitiveCache && (cacheNode.p = primitiveCache = new Map());
              const primitiveNode = primitiveCache.get(arg);
              void 0 === primitiveNode
                ? ((cacheNode = createCacheNode()), primitiveCache.set(arg, cacheNode))
                : (cacheNode = primitiveNode);
            }
          }
          const terminatedNode = cacheNode;
          let result;
          if (1 === cacheNode.s) result = cacheNode.v;
          else if (((result = func.apply(null, arguments)), resultsCount++, resultEqualityCheck)) {
            const lastResultValue = lastResult?.deref?.() ?? lastResult;
            null != lastResultValue &&
              resultEqualityCheck(lastResultValue, result) &&
              ((result = lastResultValue), 0 !== resultsCount && resultsCount--);
            lastResult =
              ('object' == typeof result && null !== result) || 'function' == typeof result
                ? new Ref(result)
                : result;
          }
          return ((terminatedNode.s = 1), (terminatedNode.v = result), result);
        }
        return (
          (memoized.clearCache = () => {
            ((fnNode = { s: 0, v: void 0, o: null, p: null }), memoized.resetResultsCount());
          }),
          (memoized.resultsCount = () => resultsCount),
          (memoized.resetResultsCount = () => {
            resultsCount = 0;
          }),
          memoized
        );
      }
      function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
        const createSelectorCreatorOptions =
            'function' == typeof memoizeOrOptions
              ? { memoize: memoizeOrOptions, memoizeOptions: memoizeOptionsFromArgs }
              : memoizeOrOptions,
          createSelector2 = (...createSelectorArgs) => {
            let lastResult,
              recomputations = 0,
              dependencyRecomputations = 0,
              directlyPassedOptions = {},
              resultFunc = createSelectorArgs.pop();
            ('object' == typeof resultFunc &&
              ((directlyPassedOptions = resultFunc), (resultFunc = createSelectorArgs.pop())),
              assertIsFunction(
                resultFunc,
                `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
              ));
            const combinedOptions = { ...createSelectorCreatorOptions, ...directlyPassedOptions },
              {
                memoize,
                memoizeOptions = [],
                argsMemoize = weakMapMemoize,
                argsMemoizeOptions = [],
                devModeChecks = {},
              } = combinedOptions,
              finalMemoizeOptions = ensureIsArray(memoizeOptions),
              finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions),
              dependencies = getDependencies(createSelectorArgs),
              memoizedResultFunc = memoize(
                function recomputationWrapper() {
                  return (recomputations++, resultFunc.apply(null, arguments));
                },
                ...finalMemoizeOptions
              );
            const selector = argsMemoize(
              function dependenciesChecker() {
                dependencyRecomputations++;
                const inputSelectorResults = (function collectInputSelectorResults(
                  dependencies,
                  inputSelectorArgs
                ) {
                  const inputSelectorResults = [],
                    { length } = dependencies;
                  for (let i = 0; i < length; i++)
                    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
                  return inputSelectorResults;
                })(dependencies, arguments);
                return (
                  (lastResult = memoizedResultFunc.apply(null, inputSelectorResults)),
                  lastResult
                );
              },
              ...finalArgsMemoizeOptions
            );
            return Object.assign(selector, {
              resultFunc,
              memoizedResultFunc,
              dependencies,
              dependencyRecomputations: () => dependencyRecomputations,
              resetDependencyRecomputations: () => {
                dependencyRecomputations = 0;
              },
              lastResult: () => lastResult,
              recomputations: () => recomputations,
              resetRecomputations: () => {
                recomputations = 0;
              },
              memoize,
              argsMemoize,
            });
          };
        return (
          Object.assign(createSelector2, { withTypes: () => createSelector2 }),
          createSelector2
        );
      }
      var createSelector = createSelectorCreator(weakMapMemoize),
        createStructuredSelector = Object.assign(
          (inputSelectorsObject, selectorCreator = createSelector) => {
            !(function assertIsObject(
              object,
              errorMessage = 'expected an object, instead received ' + typeof object
            ) {
              if ('object' != typeof object) throw new TypeError(errorMessage);
            })(
              inputSelectorsObject,
              'createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ' +
                typeof inputSelectorsObject
            );
            const inputSelectorKeys = Object.keys(inputSelectorsObject);
            return selectorCreator(
              inputSelectorKeys.map((key) => inputSelectorsObject[key]),
              (...inputSelectorResults) =>
                inputSelectorResults.reduce(
                  (composition, value, index) => (
                    (composition[inputSelectorKeys[index]] = value),
                    composition
                  ),
                  {}
                )
            );
          },
          { withTypes: () => createStructuredSelector }
        );
    },
    './node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      var React = __webpack_require__('./node_modules/next/dist/compiled/react/index.js');
      var objectIs =
          'function' == typeof Object.is
            ? Object.is
            : function is(x, y) {
                return (x === y && (0 !== x || 1 / x == 1 / y)) || (x != x && y != y);
              },
        useState = React.useState,
        useEffect = React.useEffect,
        useLayoutEffect = React.useLayoutEffect,
        useDebugValue = React.useDebugValue;
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return !0;
        }
      }
      var shim =
        'undefined' == typeof window ||
        void 0 === window.document ||
        void 0 === window.document.createElement
          ? function useSyncExternalStore$1(subscribe, getSnapshot) {
              return getSnapshot();
            }
          : function useSyncExternalStore$2(subscribe, getSnapshot) {
              var value = getSnapshot(),
                _useState = useState({ inst: { value, getSnapshot } }),
                inst = _useState[0].inst,
                forceUpdate = _useState[1];
              return (
                useLayoutEffect(
                  function () {
                    ((inst.value = value),
                      (inst.getSnapshot = getSnapshot),
                      checkIfSnapshotChanged(inst) && forceUpdate({ inst }));
                  },
                  [subscribe, value, getSnapshot]
                ),
                useEffect(
                  function () {
                    return (
                      checkIfSnapshotChanged(inst) && forceUpdate({ inst }),
                      subscribe(function () {
                        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
                      })
                    );
                  },
                  [subscribe]
                ),
                useDebugValue(value),
                value
              );
            };
      exports.useSyncExternalStore =
        void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
    },
    './node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      var React = __webpack_require__('./node_modules/next/dist/compiled/react/index.js'),
        shim = __webpack_require__('./node_modules/use-sync-external-store/shim/index.js');
      var objectIs =
          'function' == typeof Object.is
            ? Object.is
            : function is(x, y) {
                return (x === y && (0 !== x || 1 / x == 1 / y)) || (x != x && y != y);
              },
        useSyncExternalStore = shim.useSyncExternalStore,
        useRef = React.useRef,
        useEffect = React.useEffect,
        useMemo = React.useMemo,
        useDebugValue = React.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function (
        subscribe,
        getSnapshot,
        getServerSnapshot,
        selector,
        isEqual
      ) {
        var instRef = useRef(null);
        if (null === instRef.current) {
          var inst = { hasValue: !1, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(
          function () {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                if (
                  ((hasMemo = !0),
                  (memoizedSnapshot = nextSnapshot),
                  (nextSnapshot = selector(nextSnapshot)),
                  void 0 !== isEqual && inst.hasValue)
                ) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return (memoizedSelection = currentSelection);
                }
                return (memoizedSelection = nextSnapshot);
              }
              if (
                ((currentSelection = memoizedSelection), objectIs(memoizedSnapshot, nextSnapshot))
              )
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              return void 0 !== isEqual && isEqual(currentSelection, nextSelection)
                ? ((memoizedSnapshot = nextSnapshot), currentSelection)
                : ((memoizedSnapshot = nextSnapshot), (memoizedSelection = nextSelection));
            }
            var memoizedSnapshot,
              memoizedSelection,
              hasMemo = !1,
              maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function () {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot
                ? void 0
                : function () {
                    return memoizedSelector(maybeGetServerSnapshot());
                  },
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        return (
          useEffect(
            function () {
              ((inst.hasValue = !0), (inst.value = value));
            },
            [value]
          ),
          useDebugValue(value),
          value
        );
      };
    },
    './node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js'(
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      'use strict';
      var React = __webpack_require__('./node_modules/next/dist/compiled/react/index.js');
      var objectIs =
          'function' == typeof Object.is
            ? Object.is
            : function is(x, y) {
                return (x === y && (0 !== x || 1 / x == 1 / y)) || (x != x && y != y);
              },
        useSyncExternalStore = React.useSyncExternalStore,
        useRef = React.useRef,
        useEffect = React.useEffect,
        useMemo = React.useMemo,
        useDebugValue = React.useDebugValue;
    },
    './node_modules/use-sync-external-store/shim/index.js'(
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      'use strict';
      module.exports = __webpack_require__(
        './node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js'
      );
    },
    './node_modules/use-sync-external-store/shim/with-selector.js'(
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      'use strict';
      module.exports = __webpack_require__(
        './node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js'
      );
    },
    './node_modules/use-sync-external-store/with-selector.js'(
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      'use strict';
      __webpack_require__(
        './node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js'
      );
    },
  },
]);
